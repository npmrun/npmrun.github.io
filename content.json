{"pages":[{"title":"国风·周南·关雎","date":"2020-09-20T02:27:34.589Z","path":"about/index.html","text":"关关雎鸠，在河之洲。窈窕淑女，君子好逑。参差荇菜，左右流之。窈窕淑女，寤寐求之。求之不得，寤寐思服。悠哉悠哉，辗转反侧。参差荇菜，左右采之。窈窕淑女，琴瑟友之。参差荇菜，左右芼之。窈窕淑女，钟鼓乐之。"},{"title":"留言板","date":"2020-04-04T17:57:25.000Z","path":"about - 副本/index.html","text":"setTimeout(function(){ (function(){ var myChart = echarts.init(document.getElementById('maindddd')); var option = { title : { text: '', subtext: '', x:'center' }, tooltip : { trigger: 'item', formatter: '{a}{b} : {c} ({d}%)' }, legend: { x : 'center', y : 'bottom', data:['HTML','CSS','Javascript','Node','vue','react','Webpack','Gulp','Python'] }, toolbox: { show : true, feature : { mark : {show: true}, dataView : {show: true, readOnly: false}, magicType : { show: true, type: ['pie', 'funnel'] }, restore : {show: true}, saveAsImage : {show: true} } }, calculable : true, series: [{ name:'熟练度', type:'pie', radius : [30, 110], center : ['50%', '50%'], roseType : 'area', data:[ {value:80, name:'HTML'}, {value:80, name:'CSS'}, {value:80, name:'Javascript'}, {value:70, name:'Node'}, {value:80, name:'vue'}, {value:30, name:'react'}, {value:60, name:'Webpack'}, {value:60, name:'Gulp'}, {value:20, name:'Python'} ] }] }; myChart.setOption(option); })(); },0)"},{"title":"分类","date":"2020-04-04T18:09:58.000Z","path":"categories/index.html","text":""},{"title":"Github","date":"2020-04-23T09:33:29.000Z","path":"github/index.html","text":""},{"title":"友情链接","date":"2018-06-07T22:17:49.000Z","path":"link/index.html","text":""},{"title":"音乐","date":"2020-04-23T09:33:29.000Z","path":"music/index.html","text":""},{"title":"标签","date":"2020-04-04T18:09:58.000Z","path":"tags/index.html","text":""},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"assets/js/APlayer.min.js","text":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"APlayer\",[],t):\"object\"==typeof exports?exports.APlayer=t():e.APlayer=t()}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=41)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=/mobile/i.test(window.navigator.userAgent),a={secondToTime:function(e){var t=Math.floor(e/3600),n=Math.floor((e-3600*t)/60),i=Math.floor(e-3600*t-60*n);return(t>0?[t,n,i]:[n,i]).map(function(e){return e=0;t--){var n=Math.floor(Math.random()*(t+1)),i=e[n];e[n]=e[t],e[t]=i}return e}([].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);ti?t:e+(t-e)*((a=n/i)n?\"function\"==typeof i&&i(t):l(u)}()},n=function(e){if(!e.defaultPrevented){e.preventDefault(),location.hash!==this.hash&&window.history.pushState(null,null,this.hash);var n=document.getElementById(this.hash.substring(1));if(!n)return;t(n,500,function(e){location.replace(\"#\"+e.id)})}};return document.addEventListener(\"DOMContentLoaded\",function(){for(var e,t=document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'),i=t.length;e=t[--i];)e.addEventListener(\"click\",n,!1)}),t}})?i.call(t,n,t,e):i)||(e.exports=a)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;n1),n=0===this.audios.length;this.player.template.listOl.innerHTML+=(0,a.default)({theme:this.player.options.theme,audio:e,index:this.audios.length+1}),this.audios=this.audios.concat(e),t&&this.audios.length>1&&this.player.container.classList.add(\"aplayer-withlist\"),this.player.randomOrder=r.default.randomOrder(this.audios.length),this.player.template.listCurs=this.player.container.querySelectorAll(\".aplayer-list-cur\"),this.player.template.listCurs[this.audios.length-1].style.backgroundColor=e.theme||this.player.options.theme,n&&(\"random\"===this.player.options.order?this.switch(this.player.randomOrder[0]):this.switch(0))}},{key:\"remove\",value:function(e){if(this.player.events.trigger(\"listremove\",{index:e}),this.audios[e])if(this.audios.length>1){var t=this.player.container.querySelectorAll(\".aplayer-list li\");t[e].remove(),this.audios.splice(e,1),this.player.lrc&&this.player.lrc.remove(e),e===this.index&&(this.audios[e]?this.switch(e):this.switch(e-1)),this.index>e&&this.index--;for(var n=e;n"},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"plugins/myjs/autoload.js","text":"// 注意：live2d_path 参数应使用绝对路径 // const live2d_path = \"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\"; //const live2d_path = \"/live2d-widget/\"; const live2d_path = \"/plugins/myjs/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", apiPath: \"https://live2d.fghrsh.net/api/\", //cdnPath: \"https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/\" }); }); } // initWidget 第一个参数为 waifu-tips.json 的路径，第二个参数为 API 地址 // API 后端可自行搭建，参考 https://github.com/fghrsh/live2d_api // 初始化看板娘会自动加载指定目录下的 waifu-tips.json console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);"},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"plugins/myjs/waifu-tips.js","text":"/* * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ function loadWidget(config) { let { waifuPath, apiPath, cdnPath } = config; let useCDN = false, modelList; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } // 检测用户活动状态，并在空闲时显示消息 let userAction = false, userActionTimer, messageTimer, messageArray = [\"好久不见，日子过得好快呢……\", \"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\", \"嗨～快来逗我玩吧！\", \"拿小拳拳锤你胸口！\", \"记得把小家加入 Adblock 白名单哦！\"]; window.addEventListener(\"mousemove\", () => userAction = true); window.addEventListener(\"keydown\", () => userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(randomSelection(messageArray), 6000, 9); }, 20000); } }, 1000); (function registerEventListener() { document.querySelector(\"#waifu-tool .fa-comment\").addEventListener(\"click\", showHitokoto); document.querySelector(\"#waifu-tool .fa-paper-plane\").addEventListener(\"click\", () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { let script = document.createElement(\"script\"); script.src = \"https://cdn.jsdelivr.net/gh/GalaxyMimi/CDN/asteroids.js\"; document.head.appendChild(script); } }); document.querySelector(\"#waifu-tool .fa-user-circle\").addEventListener(\"click\", loadOtherModel); document.querySelector(\"#waifu-tool .fa-street-view\").addEventListener(\"click\", loadRandModel); document.querySelector(\"#waifu-tool .fa-camera-retro\").addEventListener(\"click\", () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; }); document.querySelector(\"#waifu-tool .fa-info-circle\").addEventListener(\"click\", () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); }); document.querySelector(\"#waifu-tool .fa-times\").addEventListener(\"click\", () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.opacity = \"0\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); }); let devtools = () => {}; console.log(\"%c\", devtools); devtools.toString = () => { showMessage(\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\", 6000, 9); }; window.addEventListener(\"copy\", () => { showMessage(\"你都复制了些什么呀，转载要记得加上出处哦！\", 6000, 9); }); window.addEventListener(\"visibilitychange\", () => { if (!document.hidden) showMessage(\"哇，你终于回来了～\", 6000, 9); }); })(); (function welcomeMessage() { let text; if (location.pathname === \"/\") { // 如果是主页 let now = new Date().getHours(); if (now > 5 && now 7 && now 11 && now 13 && now 17 && now 19 && now 21 && now response.json()) .then(result => { let text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); let tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 1; // 模型 ID modelTexturesId = 53; // 材质 ID } loadModel(modelId, modelTexturesId); fetch(waifuPath) .then(response => response.json()) .then(result => { result.mouseover.forEach(tips => { window.addEventListener(\"mouseover\", event => { if (!event.target.matches(tips.selector)) return; let text = randomSelection(tips.text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); }); }); result.click.forEach(tips => { window.addEventListener(\"click\", event => { if (!event.target.matches(tips.selector)) return; let text = randomSelection(tips.text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); }); }); result.seasons.forEach(tips => { let now = new Date(), after = tips.date.split(\"-\")[0], before = tips.date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] response.json()) .then(result => { loadModel(result.model.id, 0, result.model.message); }); } } let waifu= document.getElementById(\"waifu\"); let dx = 0 let dy = 0 let dw = waifu.offsetWidth let dh = waifu.offsetHeight // console.log(waifu.offsetLeft,waifu.offsetTop); setTimeout(() => { document.getElementById(\"waifu\").style.opacity = 1; }, 1000); let downPositon; let width = window.innerWidth let height = window.innerHeight let isClick = false; let left = localStorage.getItem(\"live2d_x\") let top = localStorage.getItem(\"live2d_y\") if (left) { waifu.style.left=left waifu.style.right=\"auto\"; } if (top) { waifu.style.top=top waifu.style.bottom=\"auto\"; } waifu.addEventListener(\"mousedown\",function(e){ isClick=true; dx =waifu.offsetLeft dy =waifu.offsetTop // dh =waifu.offsetHeight // dw =waifu.offsetWidth downPositon = { x:e.x, y:e.y } }) waifu.addEventListener(\"mousemove\",function(e){ if (isClick) { let currPosition = { x:e.x, y:e.y } let left = (currPosition.x - (downPositon.x-dx)); if (left(width- dw)){ left = width- dw; } waifu.style.left= left + \"px\"; let top = (currPosition.y - (downPositon.y-dy)); if (top(height- dh)){ top = height- dh; } waifu.style.top=top + \"px\"; waifu.style.bottom=\"auto\"; waifu.style.right=\"auto\"; } }) waifu.addEventListener(\"mouseup\",function(e){ isClick= false; localStorage.setItem(\"live2d_x\",waifu.style.left) localStorage.setItem(\"live2d_y\",waifu.style.top) }) } function initWidget(config, apiPath = \"/\") { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); let toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.opacity = 1; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } }"},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"plugins/myjs/waifu-tips.json","text":"{\"mouseover\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool .fa-comment\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool .fa-paper-plane\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool .fa-user-circle\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool .fa-street-view\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool .fa-camera-retro\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool .fa-info-circle\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool .fa-times\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-categories\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-archives\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\",\"快看看这里都有什么呢？\"]},{\"selector\":\".menu-item-friends\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\"#qrcode\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".highlight, .gist\",\"text\":[\"代码可以直接点击复制哟。\",\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/']\",\"text\":[\"要去看看首页么？\",\"点它可以去往首页哟！\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/about/']\",\"text\":[\"要去看看主人的个人信息吗？记得过去之后刷新一下哦\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\"a[href^='/archives/']\",\"text\":[\"要去看看 {text} 么？\",\"点它可以查看所有的文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"span[itemprop='name']\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\".site-author-name\",\"text\":[\"我家主人叫 {text} 呦，要记得他哦。\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}]}"},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"plugins/myjs/waifu.css","text":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 12px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; left: 0; line-height: 0; position: fixed; transform: translateY(3px); /* transition: transform .3s ease-in-out, bottom 3s ease-in-out; */ transition: transform .3s ease-in-out, opacity 3s ease-in-out; z-index: 1; opacity: 0; } #waifu:hover { transform: translateY(0); } @media (max-width: 768px) { #waifu { display: none; } } #waifu-tips { pointer-events: none; animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #waifu #live2d { cursor: grab; position: relative; } #waifu #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; right: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { color: #5b6c7d; cursor: pointer; display: block; line-height: 30px; text-align: center; transition: color .3s; } #waifu-tool span:hover { color: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }"},{"title":"","date":"2020-09-20T02:27:34.593Z","path":"plugins/myjs/live2d.min.js","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t"}],"posts":[{"title":"html中offsetTopclientTopscrollTopoffsetTop各属性介绍","date":"2020-08-23T17:43:57.000Z","path":"2020/08/23/前端/html中offsetTopclientTopscrollTopoffsetTop各属性介绍/","text":"主题：html中offsetTop,clientTop,scrollTop,offsetTop各属性介绍概述：html中offsetTop,clientTop,scrollTop,offsetTop各属性介绍 HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidthscrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量 这里是javascript中建造迁移转变代码的常用属性页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth （包含边线的宽）;网页可见区域高： document.body.offsetHeight （包含边线的宽）;网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文项目组上： window.screenTop;网页正文项目组左： window.screenLeft;屏幕辨别率的高： window.screen.height;屏幕辨别率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; 1、offsetXXX假设 obj 为某个 HTML 控件。obj.offsetTop 指 obj 间隔上方或上层控件的地位，整型，单位像素。obj.offsetLeft 指 obj 间隔左方或上层控件的地位，整型，单位像素。obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。 我们对前面提到的“上方或上层”与“左方或上层”控件作个申明。例如： 12345678910111213&lt;div id=\"tool\"&gt; &lt;input type=\"button\" value=\"提交\"&gt; &lt;input type=\"button\" value=\"重置\"&gt;&lt;/div&gt; “提交”按钮的 offsetTop 指“提交”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“重置”按钮的 offsetTop 指“重置”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“提交”按钮的 offsetLeft 指“提交”按钮距“tool”层左边框的间隔，因为距其左边比来的是 “tool” 层的左边框。“重置”按钮的 offsetLeft 指“重置”按钮距“提交”按钮右边框的间隔，因为距其左边比来的是“提交”按钮的右边框。以上属性在 FireFox 中也有效。另 外：我们这里所说的是指 HTML 控件的属性值，并不是 document.body，document.body 的值在不合浏览器中有不合申明（实际上大多半景象是因为对 document.body 申明不合造成的，并不是因为对 offset 申明不合造成的）。 2.offsetTop 与 style.top 的差别我们知道 offsetTop 可以获得 HTML 元素间隔上方或外层元素的地位，style.top 也是可以的，二者的差别是： offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。 offsetTop 只读，而 style.top 可读写。 若是没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。 offsetLeft 与 style.left、offsetWidth 与 style.width、offsetHeight 与 style.height 也是同样事理。 3.clientHeight、offsetHeight和scrollHeight我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。offsetHeightIE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。scrollHeightIE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说clientHeight 就是透过浏览器看内容的这个区域高度。NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。同理clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。然则FF 在不合的 DOCTYPE 中对 clientHeight 的申明不合， xhtml 1 trasitional 中则不是如上申明的。其它浏览器则不存在此题目。 4.scrollTop、scrollLeft、scrollWidth、scrollHeightscrollTop 是“卷”起来的高度值，示例： 1234567&lt;div style=\"width:100px;height:100px;background-color:＃FF0000;overflow:hidden;\" id=\"p\"&gt;&lt;div style=\"width:50px;height:300px;background-color:＃0000FF;\" id=\"t\"&gt;若是为 p 设置了 scrollTop，这些内容可能不会完全显示。&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var p = document.getElementById（\"p\"）; p.scrollTop = 10;&lt;/script&gt; 因为为外层元素 p 设置了 scrollTop，所以内层元素会向上卷。scrollLeft 也是类似事理。我们已经知道 offsetHeight 是自身元素的宽度。而 scrollHeight 是内部元素的绝对宽度，包含内部元素的隐蔽的项目组。上述中 p 的 scrollHeight 为 300，而 p 的 offsetHeight 为 100。scrollWidth 也是类似事理。IE 和 FireFox 周全支撑，而 Netscape 和 Opera 不支撑 scrollTop、scrollLeft（document.body 除外）。 5.offsetTop、offsetLeft、offsetWidth、offsetHeight一向以来对offsetLeft，offsetTop，scrollLeft，scrollTop这几个办法很含混，花了一天的时候好好的进修了一下．得出了以下的成果：1.offsetTop :当前对象到其上级层顶部的间隔.不克不及对其进行赋值.设置对象到页面顶部的间隔请用style.top属性.2.offsetLeft :当前对象到其上级层左边的间隔.不克不及对其进行赋值.设置对象到页面左部的间隔请用style.left属性.3.offsetWidth :当前对象的宽度.与style.width属性的差别在于:如对象的宽度设定值为百分比宽度，则无论页面变大还是变小，style.width都返回此百分比，而offsetWidth则返回在不合页面中对象的宽度值而不是百分比值4.offsetHeight :与style.height属性的差别在于:如对象的宽度设定值为百分比高度，则无论页面变大还是变小，style.height都返回此百分比，而offsetHeight则返回在不合页面中对象的高度值而不是百分比值5.offsetParent :当前对象的上级层对象. 若是对象是包含在一个DIV中时，此DIV不会被当做是此对象的上级层，（即对象的上级层会跳过DIV对象）上级层是Table时则不会有题目.哄骗这个属性，可以获得当前对象在不合大小的页面中的绝对地位． 获得绝对地位脚本代码 123456789101112function GetPosition（obj）&#123; var left = 0; var top = 0; while（obj != document.body） &#123; left = obj.offsetLeft; top = obj.offsetTop; obj = obj.offsetParent; &#125; alert（\"Left Is : \" + left + \"\\r\\n\" + \"Top Is : \" + top）;&#125; 6.scrollLeft :对象的最左边到对象在当前窗口显示的局限内的左边的间隔．便是在呈现了横向迁移转变条的景象下，迁移转变条拉动的间隔．7.scrollTop对象的最顶部到对象在当前窗口显示的局限内的顶边的间隔．便是在呈现了纵向迁移转变条的景象下，迁移转变条拉动的间隔． 页面滚动的时候，元素的offsetXXX不变，要获取页面滚动距离用$(document).scrollTop() 转自：http://blog.csdn.net/fswan/article/details/17238933","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"讲一讲iconfont的三种实现方式以及自定义制作","date":"2020-08-20T23:02:39.000Z","path":"2020/08/20/font/讲一讲iconfont的三种实现方式以及自定义制作/","text":"主题：讲一讲iconfont的三种实现方式以及自定义制作概述：iconfont的图标都挺好看的，但是最近我要自己搞一套UI库的话，不可避免的需要制作一些图标，因此就研究了一下具体的实现方式，统共的话有两种。 unicode：制作自定义字体文件并引入，当在网页上编写特殊的unicode编码的时候可以呈现对应的文字。 font-class: 前一种的变种，不用再费力去看unicode编码，而是直接制作成一个css文件，采用将字符编码以伪类的方式定义在content中，能达到更上面类似的效果。 symbol：这属于Svg了，svg可以设置symbol,然后通过use:xlink引用symbol的id从而实现svg的类似雪碧图效果。这样的方式支持彩色图标。","tags":[],"categories":[{"name":"font","slug":"font","permalink":"https://xieyaxin.top/categories/font/"}]},{"title":"获取元素各种宽高及页面宽高总结","date":"2020-08-19T23:22:44.000Z","path":"2020/08/19/前端/获取元素各种宽高及页面宽高总结/","text":"主题：获取元素各种宽高及页面宽高总结概述：获取元素各种宽高及页面宽高总结 当网页并没有设置overflow:hidden而被卷曲时，卷曲的就是html，可以用document.documentElement.scrollTop获取被卷曲的高度 1234567window.onload&#x3D;function()&#123; var a &#x3D; $(&quot;#div&quot;).width(),&#x2F;&#x2F;width()返回元素的宽高，不包括padding&#x2F;border&#x2F;margin b &#x3D; $(&quot;#div&quot;).innerWidth(),&#x2F;&#x2F;innerWidth()返回元素的宽高 + padding c &#x3D; $(&quot;#div&quot;).outerWidth(),&#x2F;&#x2F;outerWidth()返回元素的宽高 + padding + border d &#x3D; $(&quot;#div&quot;).outerWidth(true);&#x2F;&#x2F;outerWidth(true)返回元素宽高 + padding + border + margin console.log(a,b,c,d);&#125; 获取浏览器显示区域（可视区域）的高度 ：$(window).height(); 获取浏览器显示区域（可视区域）的宽度 ：$(window).width(); 获取页面的文档高度$(document).height(); 获取页面的文档宽度$(document).width(); 浏览器当前窗口文档body的高度$(document.body).height(); 浏览器当前窗口文档body的宽度$(document.body).width(); 获取滚动条到顶部的垂直高度(即网页被卷上去的高度)$(document).scrollTop(); 获取滚动条到左边的垂直宽度$(document).scrollLeft(); 获取或设置元素的宽度$(obj).width(); 获取或设置元素的高度 $(obj).height(); 某个元素的上边界到body最顶部的距离obj.offset().top;（在元素的包含元素不含滚动条的情况下） 某个元素的左边界到body最左边的距离obj.offset().left;（在元素的包含元素不含滚动条的情况下） 返回当前元素的上边界到它的包含元素的上边界的偏移量obj.offset().top（在元素的包含元素含滚动条的情况下） 返回当前元素的左边界到它的包含元素的左边界的偏移量obj.offset().left（在元素的包含元素含滚动条的情况下） Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect https://blog.csdn.net/gs6511/article/details/53900761 https://cloud.tencent.com/developer/article/1106529","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"scrollWidth,clientWidth,offsetWidth的区别","date":"2020-08-19T23:19:47.000Z","path":"2020/08/19/前端/scrollWidth,clientWidth,offsetWidth的区别/","text":"主题：scrollWidth,clientWidth,offsetWidth的区别概述：scrollWidth,clientWidth,offsetWidth的区别 scrollWidth：对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大。 clientWidth：对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变。 offsetWidth：对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变。 示例展示： 该demo就在页面中放一个textarea元素，采用默认宽高显示。 情况1： 元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。 scrollWidth=clientWidth，两者皆为内容可视区的宽度。 offsetWidth为元素的实际宽度。 情况2： 元素的内容超过可视区，滚动条出现和可用的情况下。 scrollWidth&gt;clientWidth。 scrollWidth为实际内容的宽度。 clientWidth是内容可视区的宽度。 offsetWidth是元素的实际宽度。","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"ui组件库之图标的思考","date":"2020-08-19T10:26:05.000Z","path":"2020/08/19/ui/ui组件库之图标的思考/","text":"主题：ui组件库之图标的思考概述：在制作xyx-ui的时候，个人认为这是比较重要的一环，借此机会，将深入了解一下。","tags":[],"categories":[{"name":"ui","slug":"ui","permalink":"https://xieyaxin.top/categories/ui/"}]},{"title":"从零开始搭建一个rollup库","date":"2020-08-17T22:44:20.000Z","path":"2020/08/17/rollup/从零开始搭建一个rollup库/","text":"主题：从零开始搭建一个rollup库概述：从零开始搭建一个rollup库 安装 全局安装 1npm install --global rollup 配置文件","tags":[],"categories":[{"name":"rollup","slug":"rollup","permalink":"https://xieyaxin.top/categories/rollup/"}]},{"title":"CSS3.0使用@font-face自定义字体","date":"2020-08-15T10:34:04.000Z","path":"2020/08/15/font/CSS3.0使用@font-face自定义字体/","text":"主题：CSS3.0使用@font-face自定义字体概述：CSS3.0使用@font-face自定义字体 1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;css3.0 @font-face&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;myblog&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 1234567891011@font-face &#123; font-family: &#39;汉仪雪君体简&#39;; src:url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.ttf&#39;) format(&#39;truetype&#39;)， url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.eot&#39;) format(&#39;embedded-opentype&#39;)， url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.woff&#39;) format(&#39;truetype&#39;); font-weight: normal; font-style: normal;&#125;h1&#123; font-family:&quot;汉仪雪君体简&quot;;&#125; 如以上代码所示，@font-face的语法规则如下: 123456@font-face &#123; font-family: &lt;YourWebFontName&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;];&#125; 注： YourWebFontName:此值为你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如font-family: ‘汉仪雪君体简’; source:此值指的是你自定义的字体的存放路径； format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型： truetype,opentype,truetype-aat,embedded-opentype,avg等。不同浏览器对字体格式的支持不同，一般来说至少需要.woff,.eot两种格式字体，甚至还需要.svg等字体达到更多种浏览版本的支持。 weight和style:weight定义字体是否为粗体，style主要定义字体样式，如斜体。 下载字体：https://www.google.com/fonts 获取@font-face所需字体格式：https://www.fontsquirrel.com/tools/webfont-generator","tags":[],"categories":[{"name":"font","slug":"font","permalink":"https://xieyaxin.top/categories/font/"}]},{"title":"vue中进行多层组件监听","date":"2020-08-14T18:12:07.000Z","path":"2020/08/14/vue/vue/vue中进行多层组件监听/","text":"主题：vue中使用v-bind=”$attrs”和v-on=”$listeners”进行多层组件监听概述： 参考资料： https://www.jianshu.com/p/ce8ca875c337 https://www.cnblogs.com/jin-zhe/p/13099416.html","tags":[],"categories":[{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"}]},{"title":"有关storybookreadme的在vue解析docs标签的问题","date":"2020-08-13T22:24:38.000Z","path":"2020/08/13/storybook/有关storybookreadme的在vue解析docss标签的问题/","text":"主题：概述： 问题：我是根据storybook-readme的文档进行配置的，类似于下面这样 ： 123456789config.module.rules.push(&#123; test: &#x2F;\\.vue$&#x2F;, use: &quot;vue-docgen-loader&quot;, enforce: &quot;post&quot;, &#125;); config.module.rules.push(&#123; resourceQuery: &#x2F;blockType&#x3D;docs&#x2F;, use: [&#39;storybook-readme&#x2F;vue&#x2F;docs-loader&#39;,&#39;html-loader&#39;, &#39;markdown-loader&#39;], &#125;); 然后就出问题了： 经过长时间的尝试，发现这两个错误，在Component.options.__docs后面竟然没有引号，直接接了一串docs的内容，因此我找到那个docs-loader进行修改，修改之后类似于下面这样： 123module.exports &#x3D; function (source, map) &#123; this.callback(null, &#39;module.exports &#x3D; function(Component) &#123;Component.options.__docs &#x3D; &quot;&#39; + source + &#39;&quot;&#125;&#39;, map);&#125;; 然后又除了下面这个问题： 百度得知好像是双引号不能回车，因此我们把加的双引号换车反引号。 1234module.exports &#x3D; function (source, map) &#123; console.log(source) this.callback(null, &#39;module.exports &#x3D; function(Component) &#123;Component.options.__docs &#x3D; &#96;&#39; + source + &#39;&#96;&#125;&#39;, map);&#125;; 通过打印source你会发现又多了一小撮东西，这是因为这个source本质上是一个js文件，需要导入才行，不过我也不知道怎么把字符串当js导入，因此我就直接把html-loader去掉了，这样就行了。能够使用docs标签了。","tags":[],"categories":[{"name":"storybook","slug":"storybook","permalink":"https://xieyaxin.top/categories/storybook/"}]},{"title":"有关构建一个简单的vuex模式，而不引入整个vuex","date":"2020-08-06T16:30:46.000Z","path":"2020/08/06/vue/vue/有关构建一个简单的vuex模式，而不引入整个vuex/","text":"主题：Vue-observable概述：让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的 更新。也可以作为最小化的跨组件状态存储器 简单使用方法： 123456789101112131415161718192021222324252627Vue.prototype.$store&#x3D; Vue.observable(&#123; state: &#123; isLoc: false, addr: &quot;未定位&quot;, &#125;, setLoction(&#123;loc,isLoc&#125;)&#123; this.state.isLoc &#x3D; isLoc; this.state.addr &#x3D; loc if(isLoc)&#123; localStorage.setItem(&quot;cccity&quot;,loc) &#125; &#125;,&#125;) &#x2F;&#x2F; 之后，直接使用就行： &#x2F;&#x2F;计算方法 computed:&#123; addr()&#123; return this.$store.state.addr &#125;, haveCity()&#123; return this.$store.state.isLoc &#125;, &#125;, 执行方法： this.$store.setLoction(&#123;loc:simple[1],isLoc:true&#125;);","tags":[],"categories":[{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"}]},{"title":"TweenMax动画教程","date":"2020-07-19T00:05:05.000Z","path":"2020/07/19/animation/TweenMax动画教程/","text":"主题：TweenMax动画教程概述：主要进行对TweenMax的学习 简单使用 第一步，自然是引入TweenMax库了，这个官方可以找到。 最基础的使用，我们制作一个逐渐隐藏的红色方块吧。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;..&#x2F;lib&#x2F;TweenMax.min.js&quot;&gt; &lt;&#x2F;script&gt; &lt;script&gt; TweenLite.fromTo(&#39;.box1&#39;, 5, &#123;opacity:1&#125;, &#123;opacity:0&#125;); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 同时请注意文档中的这一句话：例子中使用的CSS属性动画（opacity、x等）需要CSSPlugin插件支持，此插件包含在TweenMax.min.js中。如果你使用TweenLite.min.js，需另外加载CSSPlugin.min.js。不是全量引入的话需要额外的css插件支持 TweenLite和TweenMax区别TweenMax和TweenLite差不多，后者是轻量级的，不包含插件，如果需要对应的特性需要引入不同的插件库。这也就导致这一些API的不同，不过这两者大部分的API是一样的。 扩展使用暂停与恢复我们采用实例的方式一步步的学习。经过上面的示例，我们扩展一下，尝试写出一个控制按钮，按一下播放，再按一下暂停。这就需要一个简单的流程： 动画是否再执行中，如果是，暂停 动画是否停止了，如果是，开始 我们可以看到这里的文档,里面有简要的列出一些API，但是我貌似没有看到具体的用法，我们猜测一下: TweenLite或TweenMax写好链式语法后会返回自身的实例，我们可以用它来调用具体方法。 在TweenLite 和TweenMax 共有方法中，我们可以看到我们需要的几个函数：pause(),paused(),resume()这三个是属于暂停的方法，通过英文名大概可以得知，paused()是判断是否暂停的 因此：以下的代码就顺利成章了，可以实验以下是否得到想要的结果。 12345678910111213&lt;div class&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt; &lt;button onclick&#x3D;&quot;toggle()&quot;&gt;播放&lt;&#x2F;button&gt; &lt;script src&#x3D;&quot;..&#x2F;lib&#x2F;TweenMax.min.js&quot;&gt; &lt;&#x2F;script&gt; &lt;script&gt; let anim1 &#x3D; TweenLite.fromTo(&#39;.box1&#39;, 5, &#123;opacity:1&#125;, &#123;opacity:0&#125;); function toggle()&#123; if (anim1.paused()) &#123; anim1.resume() &#125;else&#123; anim1.pause() &#125; &#125; &lt;&#x2F;script&gt; 注意的是这里是暂停与恢复，不能判断是否播放完毕，如果判断播放完毕可以用anim1.progress()判断是否播放到1了: 123456789function toggle()&#123; if (anim1.paused()&amp;&amp;anim1.progress()&lt;1) &#123; anim1.resume() &#125;else if (anim1.progress()&#x3D;&#x3D;1) &#123; anim1.restart() &#125;else&#123; anim1.pause() &#125; &#125; isActive和paused的区别暂时不知道，貌似都是判断是否停止的，暂停之后paused是true,isActive是false, 动画开始之后paused是false,isActive是true,动画停止之后paused是false,isActive是false,","tags":[],"categories":[{"name":"animation","slug":"animation","permalink":"https://xieyaxin.top/categories/animation/"}]},{"title":"有关vmware中主机访问虚拟机端口","date":"2020-07-12T23:03:11.000Z","path":"2020/07/12/虚拟机/有关vmware中主机访问虚拟机端口/","text":"主题：主要是为了试一下nginx配置rtmp的网络推拉流概述：了解以下虚拟机与主机的端口映射基本操作 确认你的虚拟机的网络适配器是NAT 当然，我们首先打开VMware中的虚拟机，我用的是elementoryOS中文版 打开终端，输入ifconfig -a查看你的IP地址，当你看到下面图的时候，不要慌，点击如下图那个图标，会弹出一个页面，里面可能会有你的ip地址显示，没有的话只能自己先去安装一个网络库了。 由于我想要转发是nginx配置的页面，所以先查看以下nginx是否启动了，然后确保你需要转发的端口是真实有效的，如图，我配置过了 nginx，因此就会显示一个网页，我需要的就是转发这个端口 这个时候我们回到vmware上,我们打开，编辑--&gt;虚拟网络地址编辑器 如上图，我们必须要网络管理员的特权，因此点击那个更改设置，这个窗口就会重新加载，这个时候就可以编辑了。这个时候看图步骤操作： ​ 这个时候就需要填你自己的数据了： 名称 描述 不知道的谢我推荐的 主机端口 表示你在你PC上需要用到那个端口跟你虚拟机的映射 12345 类型 直接默认TCP就行了 TCP 虚拟机IP地址 这里填你上面查到的虚拟机的IP地址 192.168.x.x(x可不能乱填) 端口 填nginx中需要映射的端口 9606（我的虚拟机里配置过的网页端口） 描述 随意 写玩点确认就行了，回到上一页的时候确认一下，没问题就表示OK了。 测试，OK，主机上能访问了 注意： 你挂起了或者关闭了虚拟机就没用了。 更高级的用法请参见参考资料中的。 参考资料： 局域网访问电脑中VMware虚拟机","tags":[],"categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://xieyaxin.top/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"关于移动端h5页面不能滑动问题的解决办法","date":"2020-07-08T17:34:36.000Z","path":"2020/07/08/前端/关于移动端h5页面不能滑动问题的解决办法/","text":"主题：概述： 有的人说如果我写很多个p标签不写任何样式看能不能滑动，如果能滑动说明是样式的原因，要是也不能滑动那就应该是js的原因，是有一定的道理的，但是先别忘了看一下你的html或body是不是加了height：100%；overflow：hidden 下面分先说css的问题，主要排查overflow：hidden； 检查也有一定的顺序，检查超出高度的标签是否用了overflow：hidden；最好先检查html或body是不是加了height：100%；overflow：hidden；然后再看包裹在最外边的元素是否加了overflow：hidden; 再说下js方面的问题，主要是有在touchstart、touchmove或touchend等事件中的阻止默认事件的原因 例如： $(&quot;#myCarousel&quot;).on(&quot;touchstart&quot;, function (e) { e.preventDefault(); startX = e.originalEvent.changedTouches[0].pageX, startY = e.originalEvent.changedTouches[0].pageY; })； 这种代码其中e.preventDefault();会阻止掉默认的滚动行为。 我的情况是能上滑，不能下滑经过排查，之前是写了\\* {margin:0;padding: 0;touch-action: none;}代码，是为了解决一个报错的问题，但是在结合mescroll之后，排查问题发现是这里的问题，后来这样改就行了： 12345.list&#123; *&#123; touch-action: auto; &#125;&#125; 就是将手指滑动的区域的touch-action设置为auto.","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Ajax简述","date":"2020-07-05T21:46:16.000Z","path":"2020/07/05/前端/网络相关/Ajax简述/","text":"主题：Ajax的使用与意义概述：为了加深基础的理解，能够在不借助库的情况下实现不同方式的请求才能够更好的理解那些异步请求库的工作流程 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 如上，我们不需要重新加载页面就能够更新页面的数据，AJAX的出现意味着颠覆了传统的开发模式，使得页面更加的流畅，用户体验能够做到极致。 其中，XMLHttpRequest 是 AJAX 的基础。 什么是XMLHttpRequest 呢？所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 发送一个请求我们需要分几步实现： 创建 XMLHttpRequest 对象 确定请求方式以及传递的数据 接收数据的递回做下一步的处理 创建 XMLHttpRequest 对象由于老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象，为了做部分的兼容，我们可以做以下的方式的创建： 123456789var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; 向服务器发送请求现在我们可以配置需要发送给服务器数据的东西了。 一般来说，只需要下面这两个就能够发送了： 12xmlhttp.open(\"GET\",\"test1.txt\",true);xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） send(string) 将请求发送到服务器。string：仅用于 POST 请求 GET 还是 POST？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 12xmlhttp.open(\"GET\",\"demo_get.asp\",true);xmlhttp.send(); POST 12xmlhttp.open(\"POST\",\"demo_post.asp\",true);xmlhttp.send(); 设置请求头 请求头也是一个必须要配置的东西： 123xmlhttp.open(\"POST\",\"ajax_test.asp\",true);xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");xmlhttp.send(\"fname=Bill&amp;lname=Gates\"); 方法 描述 setRequestHeader(header,value) 向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 有关同步与异步的分别Async = true(异步) 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数： 123456789xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open(\"GET\",\"test1.txt\",true);xmlhttp.send(); Async = false（同步） 如需使用 async=false，请将 open() 方法中的第三个参数改为 false： 1xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false); 我们不推荐使用async=false，但是对于一些小型的请求，也是可以的。 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注释：当您使用async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可： 123xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);xmlhttp.send();document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText; 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText属性 如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此您可以这样使用： responseXML 属性 如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML属性： 请求 books.xml 文件，并解析响应： 12345678xmlDoc=xmlhttp.responseXML;txt=\"\";x=xmlDoc.getElementsByTagName(\"ARTIST\");for (i=0;i&lt;x.length;i++) &#123; txt=txt + x[i].childNodes[0].nodeValue + \"&lt;br /&gt;\"; &#125;document.getElementById(\"myDiv\").innerHTML=txt; 附录（onreadystatechange 事件）当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK”404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 1234567xmlhttp.onreadystatechange&#x3D;function() &#123; if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText; &#125; &#125; 注释：onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState的每个变化。 来源： w3school","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"网络相关","slug":"前端/网络相关","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"}]},{"title":"html的加载事件DOMContentLoaded和load","date":"2020-07-04T18:21:39.000Z","path":"2020/07/04/前端/知识/html的加载事件DOMContentLoaded和load/","text":"主题：html的加载事件DOMContentLoaded和load概述：有关html的加载事件的粗略整理，用于后面快速理解 页面加载方式 解析HTML结构。 加载并解析外部脚本。 DOM树构建完成，执行脚本。//DOMInteractive –&gt; DOMContentLoaded 加载图片、样式表文件等外部文件。 页面加载完毕。//window.onload 涉及到的事件 window.onload:当页面全部加载完成（包括所有资源） document.onload:当整个html文档加载的时候就触发了，也就是在body元素加载之前就开始执行了 DOMContentLoaded:当页面的DOM树解析好并且需要等待JS执行完才触发DOMContentLoaded事件不直接等待CSS文件、图片的加载完成 onreadytstatechange:当对象状态变更时触发这个事件，一旦document的readyState属性发生变化就会触发 DOMContentLoaded：dom内容加载完毕当输入一个URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发DOMContentLoaded事件。而这段时间就是HTML文档被加载和解析完成。 load页面所有内容（包括图像、脚本文件、CSS 文件等）对象已加载时触发；1）支持DOMContentLoaded事件的，就使用DOMContentLoaded事件；2）IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。 3) 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(“left”); 可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。 1234567891011121314151617181920212223242526272829function ready(fn)&#123; if(document.addEventListener) &#123; document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123; document.removeEventListener(&#39;DOMContentLoaded&#39;,arguments.callee, false); fn(); &#125;, false); &#125; &#x2F;&#x2F; 如果IE else if(document.attachEvent) &#123; &#x2F;&#x2F; 确保当页面是在iframe中加载时，事件依旧会被安全触发 document.attachEvent(&#39;onreadystatechange&#39;, function() &#123; if(document.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123; document.detachEvent(&#39;onreadystatechange&#39;, arguments.callee); fn(); &#125; &#125;); &#x2F;&#x2F; 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕 if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123; try&#123; document.documentElement.doScroll(&#39;left&#39;); &#125; catch(error)&#123; return setTimeout(arguments.callee, 20); &#125;; fn(); &#125; &#125;&#125;; document.ready的实现作用：监控dom是否加载完毕，dom加载完毕时及资源加载之前触发 123456789101112$(function()&#123; &#125;); $(document).ready(function()&#123; &#125;); &#x2F;&#x2F;jquery中默认为document对象$().ready(function()&#123; &#125;); 转载： https://blog.csdn.net/u011700203/article/details/47656857","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"知识","slug":"前端/知识","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E7%9F%A5%E8%AF%86/"}]},{"title":"scss主题切换功能","date":"2020-05-14T14:01:07.000Z","path":"2020/05/14/前端/scss主题切换功能/","text":"主题：scss主题切换功能概述：该文章主要为了实现css切换主题的功能，这只是一种方法，别的方式也可以实现。 结构类似下面这样： index.html 1234567891011121314151617&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body data-theme&#x3D;&quot;light&quot;&gt; &lt;div class&#x3D;&quot;app-home&quot;&gt; dsakdjsafs &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; index.scss 12345678@import &#39;.&#x2F;_themeify.scss&#39;;.app-home &#123; font-size: 18px; @include themeify &#123; color: themed(&#39;text-color-primary&#39;); &#125;&#125; _themeify.scss 1234567891011121314@import &#39;.&#x2F;_themes.scss&#39;;@mixin themeify &#123; @each $theme-name, $theme-map in $themes &#123; $theme-map: $theme-map !global; body[data-theme&#x3D;#&#123;$theme-name&#125;] &amp; &#123; @content; &#125; &#125;&#125;@function themed($key) &#123; @return map-get($theme-map, $key);&#125; _themes.scss 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$themes: ( default: ( &#x2F;* font-size *&#x2F; font-size-default: 14px, font-size-lg: 16px, font-size-sm: 12px, color-white: #FFF, &#x2F;* Color *&#x2F; color-success: #13CE66, color-error: #FF4949, color-warning: #FFC82C, color-info: #78A4FA, &#x2F;&#x2F; Text Color text-color-primary: #dc2b34, text-color-white: #ffffff, text-color-black: #000000, text-color-default: #4a4a4a, text-color-placeholder: #C9C9C9, text-color-disabled: #CCCCCC, &#x2F;&#x2F; Background Color bg-color-primary: #d91720, bg-color-primary-light: #b51d29, bg-color-white: #ffffff, bg-color-grey: #F7F7F7, bg-color-light: #ECF5FD, bg-color-verifycode: #cfcfcf, &#x2F;&#x2F; Border Color borer-color-primary: #e64644, borer-color-primary-light: #dc2b34, borer-color-white: #ffffff, borer-color-default: #CCCCCC, &#x2F;&#x2F; Link Color link-color-primary: #d91721, link-color-primary-light: #b51d29, link-color: #6190E8, link-color-light: #79A1EB, link-color-disabled: #BFBFBF, &#x2F;&#x2F; Icon Color icon-color-base: #CCC, ), light: ( &#x2F;* font-size *&#x2F; font-size-default: 14px, font-size-lg: 16px, font-size-sm: 12px, color-white: #FFF, &#x2F;* Color *&#x2F; color-success: #13CE66, color-error: #FF4949, color-warning: #FFC82C, color-info: #78A4FA, &#x2F;&#x2F; Text Color text-color-primary: #78A4FA, text-color-white: #ffffff, text-color-black: #000000, text-color-default: #4a4a4a, text-color-placeholder: #C9C9C9, text-color-disabled: #CCCCCC, &#x2F;&#x2F; Background Color bg-color-primary: #d91720, bg-color-primary-light: #b51d29, bg-color-white: #ffffff, bg-color-grey: #F7F7F7, bg-color-light: #ECF5FD, bg-color-verifycode: #cfcfcf, &#x2F;&#x2F; Border Color borer-color-primary: #e64644, borer-color-primary-light: #dc2b34, borer-color-white: #ffffff, borer-color-default: #CCCCCC, &#x2F;&#x2F; Link Color link-color-primary: #d91721, link-color-primary-light: #b51d29, link-color: #6190E8, link-color-light: #79A1EB, link-color-disabled: #BFBFBF, &#x2F;&#x2F; Icon Color icon-color-base: #CCC, ),); 上面只需要切换data-theme的名字就行了，一共内置了两套主题。 编译过后的css 1234567@charset &quot;UTF-8&quot;;.app-home &#123; font-size: 18px; &#125; body[data-theme&#x3D;default] .app-home &#123; color: #dc2b34; &#125; body[data-theme&#x3D;light] .app-home &#123; color: #78A4FA; &#125; 可以看出就是做了两套兼容而已。","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"内网穿透","date":"2020-04-23T13:32:36.000Z","path":"2020/04/23/工具/内网穿透/","text":"主题：内网穿透概述：这是工具推荐类文章，推荐的是frp库，经由国人开发，主要是把内网的网页进行映射，使得可以再公网访问，前提是有一个公网服务器。 准备 公网服务器 IP 140.140.192.192 域名 www.good.com 解析至上面的服务器 本地运行的服务 效果利用frp，可以实现任何人都可以通过配置的端口如 www.good.com:7001 访问我本机的hbuilder网页应用 方法服务器和内网本机分别下载对应系统平台的frp，这里ubuntu服务器需要下载linux_arm_64， mac本机是frp_0.32.1_windows_amd64.zip 先配服务端 linux_arm_64文件包在服务器上下载解压，编辑 frps.ini， 然后启动 ./frps -c ./frps.ini，放后台启动命令 nohup ./frps -c ./frps.ini &amp;，配置修改如下 1234[common]bind_port = 7000 # 自己设定的frp服务端端口# 客户端定义的端口,自己设定的http访问端口，通过这里就能访问内网了vhost_http_port = 7001 配置客户端 frp_0.32.1_windows_amd64.zip文件包解压，编辑 frpc.ini,然后启动 frpc -c ./frpc.ini,可以自己放在后台执行，配置如下： 123456789[common]server_addr = 140.140.192.192 #公网服务器ip frp服务端的ip（也就是外网主机的IP）server_port = 7000 #与服务端bind_port一致 #公网访问内部web服务器以http方式[web]type = http #访问协议local_port = 4200 #内网web服务的端口号custom_domains = www.good.com #所绑定的公网服务器域名，一级、二级域名都可以 配置服务端面板修改服务端的 frps.ini， 添加 dashboard 信息，重启启动后可以通过140.140.192.192:7500打开控制面板 123456789[common]bind_port = 7000# 客户端定义的端口vhost_http_port = 7001dashboard_port = 7002# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin 然后访问http://www.good.top:7001/ 就行了 可以配置一个naginx的网址，指向本地的7001端口就可以不带端口访问了 注意 Invalid Host header 如果本机的web项目用了webpack server(目前vue cli, react cli, angular 本地开发用的都是这个) , 这个是webpack server的安全策略，如果是angular项目，需要在启动配置中加上 --disable-host-check 类似 ng serve --open --host $IP --port $PORT --disable-host-check。 如果是uniapp项目，进行如下配置： 参考文档 https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81 https://www.jianshu.com/p/d579c2156311 https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/ https://www.it72.com/12580-1.htm https://cloud.tencent.com/developer/article/1572324","tags":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"git本地多账号配置","date":"2020-04-20T10:59:02.000Z","path":"2020/04/20/git/git本地多账号配置/","text":"前提条件 git环境 生成第一个账号的密钥先确保你已经有多个git账号（如：一个github的账号、一个码云的账号、…）。 在Git Bash Here的控制台里输入： git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; 这里的邮箱是你申请git账号时的邮箱，不报错就是正确的，继续往下走 输入 ssh-keygen -t rsa -C &quot;你的邮箱&quot; 回车，再连续3次回车见下图： 此时看下图中有一行提示：Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub 到该路径（C/Users/xxx/.ssh）可以看见两个文件：id_rsa、id_rsa.pub 。 把密钥添加进git账号中： 用编辑器打开id_rsa.pub，推荐使用Notepad++，不要使用记事本打开，因为记事本的默认编码不是utf-8，拷贝里面的全部内容，登录你其中一个git 账号，例如:我登录github平台，后添加公钥里把它添加进去，公钥名称可以随便写。提交保存，输入你的github登录密码并提示添加成功。 测试刚才添加的github密钥是否成功： 在Git Bash Here中输入 ssh git@github.com 回车 会出现一个提示，输入 yes 回车，可以看见一个successfully的提示信息，说明添加成功，可以使用了。 生成第二个账号的密钥重复上面的步骤，那用户名和邮箱改成另一个账号的 注：在输入ssh-keygen -t rsa -C &quot;你的邮箱&quot;的第一个选择存储路径的时候请自行改成自己的自定义名字，例如输入：smalldemons，这个时候一般是在C/Users/xxx/.ssh目录下就会又增加两个文件：smalldemons、smalldemons.pub,如果没看到的话，一般是在命令行打开的当前目录下，把这两个文件复制过去就行了 添加多账号配置文件config（C/Users/xxx/.ssh）： 里面的代码 如下： Host 配置的别名 HostName 填写改git账号的官网地址 IdentityFile：是对应的密钥文件 如此就可以在多个账号间切换使用了 注意这样的话只能使用git@github.com:xxxx/xxxx.git的方式拉取或推送代码，另一种我试的是失效的，得再看一下。 切换npmrun账号: 12345git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; # 上面两步不是必须的git@npmrun.github.com:npmrun&#x2F;npmrun.github.io.git&#x2F;&#x2F; 注意前面的 git@npmrun.github.com,我加了npmrun,对应的是config里面的Host 切换1549469775账号: 12345git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; # 上面两步不是必须的git@1549469775.github.com:npmrun&#x2F;1549469775.github.io.git&#x2F;&#x2F; 注意前面的 git@1549469775.github.com,我加了1549469775,对应的是config里面的Host 查看自己的用户名和邮箱地址 12$ git config user.name$ git config user.email 注意别把两个账号的ssh密钥都放一个账号里去了，会出问题，我就是有一个放一起了，结果两个配置访问的都是一个账号下的仓库了。 此时由于你的id_rsa存放的是1549469775的密钥，于是在使用ssh git@github.com发送的是默认的这个密钥，如果要修改默认登录的账号，可以在config文件里添加如下面的代码： 12345&gt;#npmrun Git账号&gt;Host github.com&gt;HostName github.com&gt;User git&gt;IdentityFile ~&#x2F;.ssh&#x2F;npmrun 就是把github.com默认指向npmrun这个账号 之后可以自己添加对应的git的，如： 12345#poorman账号,这是我自建的git网站Host git.poorman.topHostName git.poorman.topUser xxx #IdentityFile ~&#x2F;.ssh&#x2F;poorman 有关别的账号使用默认配置 1234&gt;## 加在最下面&gt;Host *&gt;User git&gt;IdentityFile ~&#x2F;.ssh&#x2F;id_rsa 参考 https://www.cnblogs.com/fanbi/p/7825746.html","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"cocos creator常用api","date":"2020-04-07T13:41:11.000Z","path":"2020/04/07/cocos/cocos-creator常用api/","text":"主题：cocos creator常用api概述：收集cocos creator常用的函数，防止老年痴呆，记得东西太多会使自己混乱，写下来才是王道。 https://blog.csdn.net/sotmwhat/article/details/93884076 给自己的忠告 异步读取的必须要判断节点或者组件是否isValid可用 龙骨动画节点中途中断并重新执行，异步的情况下并不会触发结束，导致后面的代码无法执行，处理时开一个定时器当作判断，而不是用动画结束判断 文件名就算在不同文件夹最好也不要一样 文件名里面注意可能手贱多打的空格，cocos不会帮你清掉 处理每一个需求的时候先考虑高可用性，而不是性能，毕竟手机越来越好，放弃低端机 ts文件只导出一个对象的时候，游戏可能报错，这时候在这个文件中随便改点东西保存就好了 依赖的路径一定要写对，最好全部用绝对路径，按住ctrl能打开的那种 场景加载123cc.director.loadScene('场景名称');//场景跳转cc.director.preloadScene('场景名称');//预加载场景cc.director.getScene();//获取当前场景 获取节点1234567891011121314151617181920212223242526272829303132var node = cc.find(\"Canvas/bg\");//通过访问路径来获取节点var a = this.node.getChildByName('name');//通过名字获取子节点node.getComponent(cc.Label).string = 'abc';//获取节点上的组件值var a = cc.find(\"Canvas/bg\").getComponent(cc.Sprite);//通过访问路径来获取节点，及获取该节点的指定组件this.node .getChildByName('节点名称').getComponent(cc.Label)//通过节点名获取子节点，获取该节点指定组件var a = this.node;//获取当前脚本所在的节点var a = this.node.parent;//获取父节点var a = this.node.getChildByTag(1001);//通过标签获取子节点var a = cc.find(\"bg/score\",this.node);//通过指定节点下的路径获取节点var a = this.node.children;//获取所有子节点var a = this.node.childrenCount;//获取子节点数量var a = cc.director.getScene();//获取场景主节点var a = cc.instantiate(node);//克隆节点this.node.parent = cc.find('Canvas');//绑定父节点this.node.addChild(nodeName,zIndex,tag);//添加子节点,可设置层级和标签this.node.removeChild(nodeName);//通过名字移除子节点this.node.removeChildByTag (nodeTag);//通过标签移除子节点this.node.destroy();//销毁节点this.node.isValid;//判定节点是否可用this.node.removeChild(newNode);//移除节点中指定的子节点this.node.removeChildByTag(1001);//通过标签移除节点中指定的子节点this.node.removeAllChildren();//移除所有子节点this.node.destroyAllChildren();//销毁所有子节点this.node.cleanup();//停止所有正在播放的动作和计时器var sprites = this.node.getComponentsInChildren(cc.Label);//递归查找自身及所有子节点中指定类型的组件 获取节点位置，设置节点1234567891011121314151617181920212223242526var a = node.getPositionX();或 getPositionY() //获取节点的X轴或Y轴坐标var a = node.getScaleX(); 或getScaleY() //获取节点的X轴或Y轴缩放比例node.x = 100;//设置节点x轴坐标node.y = 100;//设置节点y轴坐标node.setPosition(x,y); //设置节点坐标node.rotation = 90; //设置节点旋转角度node.scaleX = 2; //设置节点x轴缩放倍数node.scaleY = 2; //设置节点y轴缩放倍数node.setScale(2); //设置节点整体缩放倍数node.width = 100; //设置节点宽度大小node.height = 100; //设置节点高度大小node.setContentSize(100, 100); //设置节点宽高尺寸大小node.anchorX = 1; //设置节点x轴锚点坐标node.anchorY = 0; //设置节点y轴锚点坐标node.setAnchorPoint(1, 0); //设置节点锚点坐标node.opacity = 128; //设置节点透明度大小（0-255）node.setOpacity(20); //设置节点透明度（0~255）node.color = new cc.color(100,100,100,255); //设置节点颜色（R,G,B,透明度）if (cc.isValid(this.label.node) ) //判定节点是否存在node.destroy(); //销毁节点this.cannons = [];this.cannons = node.getChildren(); //获取所有子节点this.cannons = node.getChildrenCount(); //获取子节点数量node.active = false; //关闭节点(隐藏节点)cc.game.addPersistRootNode(myNode); //常驻节点（全局变量）cc.game.removePersistRootNode(myNode); //取消常驻节点 动作操作12345678910111213141516171819202122232425cc.show()&#x2F;&#x2F;立即显示cc.hide ()&#x2F;&#x2F;立即隐藏cc.toggleVisibility()&#x2F;&#x2F;显隐切换cc.fadeIn(1)&#x2F;&#x2F;渐显效果cc.fadeOut(1)&#x2F;&#x2F;渐隐效果cc.delayTime(1)&#x2F;&#x2F;等待1秒node.runAction(cc.moveTo(1,0,0)); &#x2F;&#x2F;移动到当前节点（时间（s），X轴坐标，Y 轴坐标）node.runAction(cc.scaleTo(1,0.7,0.8));&#x2F;&#x2F;缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）node.runAction(cc.rotateTo(1,160,160));&#x2F;&#x2F;旋转到指定角度（时间（s），X轴角度，Y 轴角度）node.runAction(cc.skewTo(1,5,-5));&#x2F;&#x2F;变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）node.runAction(cc.fadeTo(2,0));&#x2F;&#x2F;变化当前节点的透明度（时间（s），透明度）node.runAction(cc.tintTo(2,255,255,0));&#x2F;&#x2F;变化当前节点颜色（时间，R,G,B）node.stopAllActions();&#x2F;&#x2F;停止所有动作&#x2F;&#x2F;自定义动作var action &#x3D; cc.moveTo(2, 100, 100);&#x2F;&#x2F; 创建一个移动动作node.runAction(action);&#x2F;&#x2F; 执行动作node.stopAction(action);&#x2F;&#x2F; 停止一个动作cc.sequence(action1,action2); &#x2F;&#x2F;按顺序连续执行，先action1，后action2cc.spawn(action1，action2); &#x2F;&#x2F;同时执行，action1和action2一起执行cc.repeatForever(cc.sequence(action1,action2)); &#x2F;&#x2F;一直重复括号里的动作 计时器1234567891011121314151617181920212223242526&#x2F;&#x2F;只用1次的计时器,2秒后执行 this.scheduleOnce(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,2); &#x2F;&#x2F;(function()&#123;&#125;,时间（s）)&#x2F;&#x2F;每隔5秒执行1次 this.schedule(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,5);&#x2F;&#x2F;计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次） this.schedule(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,0.1,10,1); &#x2F;&#x2F;(function()&#123;&#125;,间隔时间，次数，多久后开始)this.unscheduleAllCallbacks(this);&#x2F;&#x2F;停止某组件的所有计时器&#x2F;&#x2F;自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）var cb&#x3D; function()&#123; &#x2F;&#x2F;do something&#125;;this.schedule(cb,1);&#x2F;&#x2F;启动定时器this.unschedule(cb);&#x2F;&#x2F;取消定时器 事件监听12345678910(开始：&#39;touchstart&#39;，移动：&#39;touchmove&#39;，结束：&#39;touchend&#39;，取消：&#39;touchcancel&#39;)node.on(&#39;touchstart&#39;,function(event)&#123; this.doSomething();&#125;,this); var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的IDvar a &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的坐标Xvar b &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的坐标Ycc.eventManager.addListener(&#123; event: cc.EventListener.KEYBOARD&#x2F;TOUCH_ONE_BY_ONE,myfunction&#125;,self.node); 分辨率12345678&#x2F;&#x2F;获得设备分辨率var b &#x3D; cc.director.getWinSizeInPixels()var bx &#x3D; b.widthvar by &#x3D; b.heightcc.view.getCanvasSize().width;&#x2F;&#x2F;获得设备分辨率的宽度cc.view.getCanvasSize().height;&#x2F;&#x2F;获得设备分辨率的高度cc.director.setDisplayStats(true);&#x2F;&#x2F;显示帧数信息 音频控制1234567cc.audioEngine.playMusic(this.BGAudio,true);&#x2F;&#x2F;播放音乐（true代表循环）cc.audioEngine.stopMusic()&#x2F;&#x2F;停止播放背景音乐cc.audioEngine.playEffect(this.ClickAudio,false);&#x2F;&#x2F;播放音效（false代表只播放一次）cc.audioEngine.stopEffect(音效变量名);&#x2F;&#x2F;停止指定音效（需要先把音效赋值给变量）cc.audioEngine.AllEffects();&#x2F;&#x2F;停止所有音效cc.audioEngine.setMusicVolume(参数); &#x2F;&#x2F;设置背景音乐的音量（该参数范围是0到1）cc.audioEngine.setEffectsVolume(参数); &#x2F;&#x2F;设置音效的音量（该参数范围是0到1） 存档操作12345678910cc.sys.localStorage.setItem(&#39;存储标识名&#39;,变量名);&#x2F;&#x2F;存储存档数据var a &#x3D; cc.sys.localStorage.getItem(&#39;存储标识名&#39;);&#x2F;&#x2F;读取存档数据cc.sys.localStorage.removeItem(&#39;存储标识名&#39;);&#x2F;&#x2F;擦除存档数据userData &#x3D; &#123; name: &#39;Tracer&#39;, level: 1, gold: 100&#125;;cc.sys.localStorage.setItem(&#39;userData&#39;, JSON.stringify(userData));&#x2F;&#x2F;存取复杂对象数据var userData &#x3D; JSON.parse(cc.sys.localStorage.getItem(&#39;userData&#39;));&#x2F;&#x2F;读取复杂对象数据 判断平台12345678910cc.sys.isNative &#x2F;&#x2F;是否是本地cc.sys.isBrowser &#x2F;&#x2F;是否是网页cc.sys.isMobile &#x2F;&#x2F;是否是移动系统cc.sys.platform &#x2F;&#x2F;正在运行的平台cc.sys.language &#x2F;&#x2F;当前运行系统的语言cc.sys.os &#x2F;&#x2F;当前正在运行的系统cc.sys.OS_IOS &#x2F;&#x2F;是否是IOS系统cc.sys.OS_ANDROID &#x2F;&#x2F;是否是android系统cc.sys.OS_WINDOWS &#x2F;&#x2F;是否是windows系统cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;); &#x2F;&#x2F;打开网页 监听和发射事件1234567891011121314151617181920212223242526272829303132333435this.node.pauseSystemEvents(true);&#x2F;&#x2F;暂停节点系统事件this.node.resumeSystemEvents(true);&#x2F;&#x2F;恢复节点系统事件this.node.targetOff(this);&#x2F;&#x2F;移除所有注册事件触摸监听：开始&#39;touchstart&#39;,移动&#39;touchmove&#39;,结束&#39;touchend&#39;,取消&#39;touchcancel&#39;var pos &#x3D; event.getLocation();&#x2F;&#x2F;获取触摸点的坐标(包含X和Y)var x &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的X坐标var y &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的Y坐标var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID鼠标监听：鼠标按下&#39;mousedown&#39;,移入节点&#39;mouseenter&#39;,节点中移动&#39;mousemove&#39;,移出节点&#39;mouseleave,&#39;松开鼠标&#39;mouseup&#39;var a &#x3D; event.getScrollY();&#x2F;&#x2F;获取滚轮滚动的 Y 轴距离，只有滚动时才有效var a &#x3D; event.getLocation();&#x2F;&#x2F;获取鼠标位置对象，对象包含 x 和 y 属性输入框监听：获得焦点&#39;editing-did-began&#39;,文字变化&#39;text-changed&#39;,失去焦点&#39;editing-did-ended&#39;,按下回车&#39;editing-return&#39;属性变化监听：位置&#39;position-changed&#39;,宽高 &#39;size-changed&#39;,旋转&#39;rotation-changed&#39;,缩放&#39;scale-changed&#39;ScrollView控件监听：滚动中&#39;scrolling&#39;,停止滚动&#39;scroll-ended&#39;用户自定义事件:this.node.on(&#39;事件名&#39;,function,this);&#x2F;&#x2F;注册监听this.node.emit(&#39;事件名&#39;);&#x2F;&#x2F;发送监听广播this.node.off(&#39;事件名&#39;,function,this);&#x2F;&#x2F;关闭监听&#x2F;&#x2F;注册带参数监听this.node.on(&#39;事件名&#39;,function(event)&#123;“具体方法函数内容”&#125;,this);&#x2F;&#x2F;发送带参数的监听this.node.emit(&#39;事件名&#39;,&#123;id:1001&#125;);cc.eventManager.addListener(listener, node);&#x2F;&#x2F;添加事件cc.eventManager.removeListener((listener);&#x2F;&#x2F;移除事件 其他操作123456789cc.director.pause();&#x2F;&#x2F;暂停cc.director.resume();&#x2F;&#x2F;继续cc.director.end();&#x2F;&#x2F;退出整个应用cc.log(变量) 或 console.log(something);&#x2F;&#x2F;输出想要的信息let self &#x3D; this;&#x2F;&#x2F;锁定当前使用的this指向node.getLocalZOrder();&#x2F;&#x2F;层级获取node.setLocalZOrder(1);&#x2F;&#x2F;层级改变cc.find(&#39;canvas&#x2F;map&#39; + num)&#x2F;&#x2F;读取带变量的路径cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);&#x2F;&#x2F;打开网页 全屏123if (cc.screen.fullScreen()) &#123; cc.screen.exitFullScreen();&#125;else cc.screen.requestFullScreen();","tags":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"}],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"font","slug":"font","permalink":"https://xieyaxin.top/categories/font/"},{"name":"ui","slug":"ui","permalink":"https://xieyaxin.top/categories/ui/"},{"name":"rollup","slug":"rollup","permalink":"https://xieyaxin.top/categories/rollup/"},{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"},{"name":"storybook","slug":"storybook","permalink":"https://xieyaxin.top/categories/storybook/"},{"name":"animation","slug":"animation","permalink":"https://xieyaxin.top/categories/animation/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://xieyaxin.top/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"网络相关","slug":"前端/网络相关","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"},{"name":"知识","slug":"前端/知识","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"},{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"}]}