{"pages":[{"title":"留言板","date":"2020-04-04T17:57:25.000Z","path":"about/index.html","text":"setTimeout(function(){ (function(){ var myChart = echarts.init(document.getElementById('maindddd')); var option = { title : { text: '编程语言掌握图', subtext: '', x:'center' }, tooltip : { trigger: 'item', formatter: '{a}{b} : {c} ({d}%)' }, legend: { x : 'center', y : 'bottom', data:['HTML','CSS','Javascript','Node','vue','react','Webpack','Gulp','Python'] }, toolbox: { show : true, feature : { mark : {show: true}, dataView : {show: true, readOnly: false}, magicType : { show: true, type: ['pie', 'funnel'] }, restore : {show: true}, saveAsImage : {show: true} } }, calculable : true, series: [{ name:'熟练度', type:'pie', radius : [30, 110], center : ['50%', '50%'], roseType : 'area', data:[ {value:80, name:'HTML'}, {value:80, name:'CSS'}, {value:80, name:'Javascript'}, {value:70, name:'Node'}, {value:80, name:'vue'}, {value:30, name:'react'}, {value:60, name:'Webpack'}, {value:60, name:'Gulp'}, {value:20, name:'Python'} ] }] }; myChart.setOption(option); })(); },0)"},{"title":"分类","date":"2020-04-04T18:09:58.000Z","path":"categories/index.html","text":""},{"title":"友情链接","date":"2018-06-07T22:17:49.000Z","path":"link/index.html","text":""},{"title":"音乐","date":"2020-04-23T09:33:29.000Z","path":"music/index.html","text":""},{"title":"标签","date":"2020-04-04T18:09:58.000Z","path":"tags/index.html","text":""},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"assets/js/APlayer.min.js","text":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"APlayer\",[],t):\"object\"==typeof exports?exports.APlayer=t():e.APlayer=t()}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=41)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=/mobile/i.test(window.navigator.userAgent),a={secondToTime:function(e){var t=Math.floor(e/3600),n=Math.floor((e-3600*t)/60),i=Math.floor(e-3600*t-60*n);return(t>0?[t,n,i]:[n,i]).map(function(e){return e=0;t--){var n=Math.floor(Math.random()*(t+1)),i=e[n];e[n]=e[t],e[t]=i}return e}([].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);ti?t:e+(t-e)*((a=n/i)n?\"function\"==typeof i&&i(t):l(u)}()},n=function(e){if(!e.defaultPrevented){e.preventDefault(),location.hash!==this.hash&&window.history.pushState(null,null,this.hash);var n=document.getElementById(this.hash.substring(1));if(!n)return;t(n,500,function(e){location.replace(\"#\"+e.id)})}};return document.addEventListener(\"DOMContentLoaded\",function(){for(var e,t=document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'),i=t.length;e=t[--i];)e.addEventListener(\"click\",n,!1)}),t}})?i.call(t,n,t,e):i)||(e.exports=a)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;n1),n=0===this.audios.length;this.player.template.listOl.innerHTML+=(0,a.default)({theme:this.player.options.theme,audio:e,index:this.audios.length+1}),this.audios=this.audios.concat(e),t&&this.audios.length>1&&this.player.container.classList.add(\"aplayer-withlist\"),this.player.randomOrder=r.default.randomOrder(this.audios.length),this.player.template.listCurs=this.player.container.querySelectorAll(\".aplayer-list-cur\"),this.player.template.listCurs[this.audios.length-1].style.backgroundColor=e.theme||this.player.options.theme,n&&(\"random\"===this.player.options.order?this.switch(this.player.randomOrder[0]):this.switch(0))}},{key:\"remove\",value:function(e){if(this.player.events.trigger(\"listremove\",{index:e}),this.audios[e])if(this.audios.length>1){var t=this.player.container.querySelectorAll(\".aplayer-list li\");t[e].remove(),this.audios.splice(e,1),this.player.lrc&&this.player.lrc.remove(e),e===this.index&&(this.audios[e]?this.switch(e):this.switch(e-1)),this.index>e&&this.index--;for(var n=e;n"},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"plugins/myjs/autoload.js","text":"// 注意：live2d_path 参数应使用绝对路径 // const live2d_path = \"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\"; //const live2d_path = \"/live2d-widget/\"; const live2d_path = \"/plugins/myjs/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", apiPath: \"https://live2d.fghrsh.net/api/\", //cdnPath: \"https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/\" }); }); } // initWidget 第一个参数为 waifu-tips.json 的路径，第二个参数为 API 地址 // API 后端可自行搭建，参考 https://github.com/fghrsh/live2d_api // 初始化看板娘会自动加载指定目录下的 waifu-tips.json console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);"},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"plugins/myjs/waifu-tips.js","text":"/* * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ function loadWidget(config) { let { waifuPath, apiPath, cdnPath } = config; let useCDN = false, modelList; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } // 检测用户活动状态，并在空闲时显示消息 let userAction = false, userActionTimer, messageTimer, messageArray = [\"好久不见，日子过得好快呢……\", \"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\", \"嗨～快来逗我玩吧！\", \"拿小拳拳锤你胸口！\", \"记得把小家加入 Adblock 白名单哦！\"]; window.addEventListener(\"mousemove\", () => userAction = true); window.addEventListener(\"keydown\", () => userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(randomSelection(messageArray), 6000, 9); }, 20000); } }, 1000); (function registerEventListener() { document.querySelector(\"#waifu-tool .fa-comment\").addEventListener(\"click\", showHitokoto); document.querySelector(\"#waifu-tool .fa-paper-plane\").addEventListener(\"click\", () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { let script = document.createElement(\"script\"); script.src = \"https://cdn.jsdelivr.net/gh/GalaxyMimi/CDN/asteroids.js\"; document.head.appendChild(script); } }); document.querySelector(\"#waifu-tool .fa-user-circle\").addEventListener(\"click\", loadOtherModel); document.querySelector(\"#waifu-tool .fa-street-view\").addEventListener(\"click\", loadRandModel); document.querySelector(\"#waifu-tool .fa-camera-retro\").addEventListener(\"click\", () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; }); document.querySelector(\"#waifu-tool .fa-info-circle\").addEventListener(\"click\", () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); }); document.querySelector(\"#waifu-tool .fa-times\").addEventListener(\"click\", () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.opacity = \"0\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); }); let devtools = () => {}; console.log(\"%c\", devtools); devtools.toString = () => { showMessage(\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\", 6000, 9); }; window.addEventListener(\"copy\", () => { showMessage(\"你都复制了些什么呀，转载要记得加上出处哦！\", 6000, 9); }); window.addEventListener(\"visibilitychange\", () => { if (!document.hidden) showMessage(\"哇，你终于回来了～\", 6000, 9); }); })(); (function welcomeMessage() { let text; if (location.pathname === \"/\") { // 如果是主页 let now = new Date().getHours(); if (now > 5 && now 7 && now 11 && now 13 && now 17 && now 19 && now 21 && now response.json()) .then(result => { let text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); let tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 1; // 模型 ID modelTexturesId = 53; // 材质 ID } loadModel(modelId, modelTexturesId); fetch(waifuPath) .then(response => response.json()) .then(result => { result.mouseover.forEach(tips => { window.addEventListener(\"mouseover\", event => { if (!event.target.matches(tips.selector)) return; let text = randomSelection(tips.text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); }); }); result.click.forEach(tips => { window.addEventListener(\"click\", event => { if (!event.target.matches(tips.selector)) return; let text = randomSelection(tips.text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); }); }); result.seasons.forEach(tips => { let now = new Date(), after = tips.date.split(\"-\")[0], before = tips.date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] response.json()) .then(result => { loadModel(result.model.id, 0, result.model.message); }); } } let waifu= document.getElementById(\"waifu\"); let dx = 0 let dy = 0 let dw = waifu.offsetWidth let dh = waifu.offsetHeight // console.log(waifu.offsetLeft,waifu.offsetTop); setTimeout(() => { document.getElementById(\"waifu\").style.opacity = 1; }, 1000); let downPositon; let width = window.innerWidth let height = window.innerHeight let isClick = false; let left = localStorage.getItem(\"live2d_x\") let top = localStorage.getItem(\"live2d_y\") if (left) { waifu.style.left=left waifu.style.right=\"auto\"; } if (top) { waifu.style.top=top waifu.style.bottom=\"auto\"; } waifu.addEventListener(\"mousedown\",function(e){ isClick=true; dx =waifu.offsetLeft dy =waifu.offsetTop // dh =waifu.offsetHeight // dw =waifu.offsetWidth downPositon = { x:e.x, y:e.y } }) waifu.addEventListener(\"mousemove\",function(e){ if (isClick) { let currPosition = { x:e.x, y:e.y } let left = (currPosition.x - (downPositon.x-dx)); if (left(width- dw)){ left = width- dw; } waifu.style.left= left + \"px\"; let top = (currPosition.y - (downPositon.y-dy)); if (top(height- dh)){ top = height- dh; } waifu.style.top=top + \"px\"; waifu.style.bottom=\"auto\"; waifu.style.right=\"auto\"; } }) waifu.addEventListener(\"mouseup\",function(e){ isClick= false; localStorage.setItem(\"live2d_x\",waifu.style.left) localStorage.setItem(\"live2d_y\",waifu.style.top) }) } function initWidget(config, apiPath = \"/\") { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); let toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.opacity = 1; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } }"},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"plugins/myjs/waifu-tips.json","text":"{\"mouseover\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool .fa-comment\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool .fa-paper-plane\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool .fa-user-circle\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool .fa-street-view\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool .fa-camera-retro\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool .fa-info-circle\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool .fa-times\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-categories\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-archives\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\",\"快看看这里都有什么呢？\"]},{\"selector\":\".menu-item-friends\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\"#qrcode\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".highlight, .gist\",\"text\":[\"代码可以直接点击复制哟。\",\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/']\",\"text\":[\"要去看看首页么？\",\"点它可以去往首页哟！\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/about/']\",\"text\":[\"要去看看主人的个人信息吗？记得过去之后刷新一下哦\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\"a[href^='/archives/']\",\"text\":[\"要去看看 {text} 么？\",\"点它可以查看所有的文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"span[itemprop='name']\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\".site-author-name\",\"text\":[\"我家主人叫 {text} 呦，要记得他哦。\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}]}"},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"plugins/myjs/waifu.css","text":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 12px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; left: 0; line-height: 0; position: fixed; transform: translateY(3px); /* transition: transform .3s ease-in-out, bottom 3s ease-in-out; */ transition: transform .3s ease-in-out, opacity 3s ease-in-out; z-index: 1; opacity: 0; } #waifu:hover { transform: translateY(0); } @media (max-width: 768px) { #waifu { display: none; } } #waifu-tips { pointer-events: none; animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #waifu #live2d { cursor: grab; position: relative; } #waifu #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; right: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { color: #5b6c7d; cursor: pointer; display: block; line-height: 30px; text-align: center; transition: color .3s; } #waifu-tool span:hover { color: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }"},{"title":"","date":"2020-06-28T04:50:58.472Z","path":"plugins/myjs/live2d.min.js","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t"}],"posts":[{"title":"Git出现Pathspec &#x27;xxx&#x27; is in submodule解决方案","date":"2020-06-28T12:04:13.000Z","path":"2020/06/28/git/Git出现Pathspec 'xxx' is in submodule解决方案/","text":"更新了七牛的SDK， 目录为vendor/crazyfd/yii2-qiniu, 下面有4个文件， LICENSE Qiniu.php README.md composer.json 使用git status查看，没有任何提交，后手动删除重新copy了文件，再次使用git status： modified: vendor/crazyfd/yii2-qiniu (modified content) git add后只增加了文件夹，但是没有文件。手动Add:git add vendor/crazyfd/yii2-qiniu/Qiniu.php 报出错误信息：fatal: Pathspec &#39;xxx&#39; is in submodule 解决方案发现vendor/crazyfd下面并没有.git文件所以使用下面命令： 12git rm -rf --cached vendor&#x2F;crazyfd&#x2F;yii2-qiniugit add vendor&#x2F;crazyfd&#x2F;yii2-qiniu&#x2F;* 再次使用git status查看发现文件已经成功添加： 1234567Changes to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)deleted: vendor&#x2F;crazyfd&#x2F;yii2-qiniunew file: vendor&#x2F;crazyfd&#x2F;yii2-qiniu&#x2F;LICENSEnew file: vendor&#x2F;crazyfd&#x2F;yii2-qiniu&#x2F;Qiniu.phpnew file: vendor&#x2F;crazyfd&#x2F;yii2-qiniu&#x2F;README.mdnew file: vendor&#x2F;crazyfd&#x2F;yii2-qiniu&#x2F;composer.json","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"","date":"2020-06-28T04:51:36.217Z","path":"2020/06/28/随想/readme/","text":"这是一个electron项目，属于聚合项目，集合多种功能，方便我的使用 用于开发一个代码笔记项目。记录灵感释放的瞬间。 提供markdown项目部署","tags":[],"categories":[{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"}]},{"title":"","date":"2020-06-28T04:51:36.213Z","path":"2020/06/28/随想/as/","text":"这是一个导航网站项目，旨在收集网络资源。为了提供更好的体验，必须提供后台，用于对网站数据的编辑 整理需求，功能列举 设计页面，配色，主题 后台数据库设计，接口开发 前端页面实现","tags":[],"categories":[{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"}]},{"title":"MDN技术学习","date":"2020-06-27T23:04:01.000Z","path":"2020/06/27/技术积累/MDN/MDN技术学习/","text":"参考文献 mozilla文档","tags":[],"categories":[{"name":"技术积累","slug":"技术积累","permalink":"https://xieyaxin.top/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"MDN","slug":"技术积累/MDN","permalink":"https://xieyaxin.top/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/MDN/"}]},{"title":"西风颂---灵感","date":"2020-06-23T12:30:49.000Z","path":"2020/06/23/小说/西风颂---灵感/","text":"墟城废墟城主角生活在废墟城城郊，主要工作是一个企业的小职员，大学毕业就来到了这个城市，然后准备干一番事业。这个世界是力量与科技的结合，修仙者吸收天地源力，凡人追寻科技进步。又力量的差距，必定存在着等级的差距，现在凡人的科技尚弱，但是表现的威力开始引起了修仙者的注意，也是此时，修仙者开始入世。 主角所在的是一个小公司，主要靠接客户的订单完成相应的任务赚取酬劳。","tags":[],"categories":[{"name":"小说","slug":"小说","permalink":"https://xieyaxin.top/categories/%E5%B0%8F%E8%AF%B4/"}]},{"title":"西风颂","date":"2020-06-23T12:27:49.000Z","path":"2020/06/23/小说/西风颂/","text":"知道吗？修炼乃逆天而为，想要攀上至强的高峰，所付出的一定是你的一切。问题是，你愿意赌上你的一切去追寻那虚无缥缈的未来吗？会么？ 远方的来客","tags":[],"categories":[{"name":"小说","slug":"小说","permalink":"https://xieyaxin.top/categories/%E5%B0%8F%E8%AF%B4/"}]},{"title":"inquirer的试用","date":"2020-06-23T10:31:48.000Z","path":"2020/06/23/npm/试用/inquirer的试用/","text":"开始通过npm init 创建package.json的时候就有大量与用户的交互(当然也可以通过参数来忽略输入)；而现在大多数工程都是通过脚手架来创建的，使用脚手架的时候最明显的就是与命令行的交互，如果想自己做一个脚手架或者在某些时候要与用户进行交互，这个时候就不得不提到inquirer.js了。 介绍由于交互的问题种类不同，inquirer为每个问题提供很多参数： type：表示提问的类型，包括：input, confirm, list, rawlist, expand, checkbox, password, editor； name: 存储当前问题回答的变量； message：问题的描述； default：默认值； choices：列表选项，在某些type下可用，并且包含一个分隔符(separator)； validate：对用户的回答进行校验； filter：对用户的回答进行过滤处理，返回处理后的值； transformer：对用户回答的显示效果进行处理(如：修改回答的字体或背景颜色)，但不会影响最终的答案的内容； when：根据前面问题的回答，判断当前问题是否需要被回答； pageSize：修改某些type类型下的渲染行数； prefix：修改message默认前缀； suffix：修改message默认后缀 上面的属性(除transformer外)在下面都有对应使用。 使用语法结构123456789const inquirer &#x3D; require(&#39;inquirer&#39;);const promptList &#x3D; [ &#x2F;&#x2F; 具体交互内容];inquirer.prompt(promptList).then(answers &#x3D;&gt; &#123; console.log(answers); &#x2F;&#x2F; 返回的结果&#125;) input12345678910111213141516const promptList &#x3D; [&#123; type: &#39;input&#39;, message: &#39;设置一个用户名:&#39;, name: &#39;name&#39;, default: &quot;test_user&quot; &#x2F;&#x2F; 默认值&#125;,&#123; type: &#39;input&#39;, message: &#39;请输入手机号:&#39;, name: &#39;phone&#39;, validate: function(val) &#123; if(val.match(&#x2F;\\d&#123;11&#125;&#x2F;g)) &#123; &#x2F;&#x2F; 校验位数 return val; &#125; return &quot;请输入11位数字&quot;; &#125;&#125;]; 效果： confirm1234567891011121314const promptList &#x3D; [&#123; type: &quot;confirm&quot;, message: &quot;是否使用监听？&quot;, name: &quot;watch&quot;, prefix: &quot;前缀&quot;&#125;,&#123; type: &quot;confirm&quot;, message: &quot;是否进行文件过滤？&quot;, name: &quot;filter&quot;, suffix: &quot;后缀&quot;, when: function(answers) &#123; &#x2F;&#x2F; 当watch为true的时候才会提问当前问题 return answers.watch &#125;&#125;]; 效果： list12345678910111213const promptList &#x3D; [&#123; type: &#39;list&#39;, message: &#39;请选择一种水果:&#39;, name: &#39;fruit&#39;, choices: [ &quot;Apple&quot;, &quot;Pear&quot;, &quot;Banana&quot; ], filter: function (val) &#123; &#x2F;&#x2F; 使用filter将回答变为小写 return val.toLowerCase(); &#125;&#125;]; 效果： rawlist12345678910const promptList &#x3D; [&#123; type: &#39;rawlist&#39;, message: &#39;请选择一种水果:&#39;, name: &#39;fruit&#39;, choices: [ &quot;Apple&quot;, &quot;Pear&quot;, &quot;Banana&quot; ]&#125;]; 效果： expand12345678910111213141516171819202122const promptList &#x3D; [&#123; type: &quot;expand&quot;, message: &quot;请选择一种水果：&quot;, name: &quot;fruit&quot;, choices: [ &#123; key: &quot;a&quot;, name: &quot;Apple&quot;, value: &quot;apple&quot; &#125;, &#123; key: &quot;O&quot;, name: &quot;Orange&quot;, value: &quot;orange&quot; &#125;, &#123; key: &quot;p&quot;, name: &quot;Pear&quot;, value: &quot;pear&quot; &#125; ]&#125;]; 效果： checkbox1234567891011121314151617181920212223242526272829303132333435const promptList &#x3D; [&#123; type: &quot;checkbox&quot;, message: &quot;选择颜色:&quot;, name: &quot;color&quot;, choices: [ &#123; name: &quot;red&quot; &#125;, new inquirer.Separator(), &#x2F;&#x2F; 添加分隔符 &#123; name: &quot;blur&quot;, checked: true &#x2F;&#x2F; 默认选中 &#125;, &#123; name: &quot;green&quot; &#125;, new inquirer.Separator(&quot;--- 分隔符 ---&quot;), &#x2F;&#x2F; 自定义分隔符 &#123; name: &quot;yellow&quot; &#125; ]&#125;];&#x2F;&#x2F; 或者下面这样const promptList &#x3D; [&#123; type: &quot;checkbox&quot;, message: &quot;选择颜色:&quot;, name: &quot;color&quot;, choices: [ &quot;red&quot;, &quot;blur&quot;, &quot;green&quot;, &quot;yellow&quot; ], pageSize: 2 &#x2F;&#x2F; 设置行数&#125;]; 效果： password12345const promptList &#x3D; [&#123; type: &quot;password&quot;, &#x2F;&#x2F; 密码为密文输入 message: &quot;请输入密码：&quot;, name: &quot;pwd&quot;&#125;]; 效果： editor12345const promptList &#x3D; [&#123; type: &quot;editor&quot;, message: &quot;请输入备注：&quot;, name: &quot;editor&quot;&#125;]; 效果：","tags":[],"categories":[{"name":"npm","slug":"npm","permalink":"https://xieyaxin.top/categories/npm/"},{"name":"试用","slug":"npm/试用","permalink":"https://xieyaxin.top/categories/npm/%E8%AF%95%E7%94%A8/"}]},{"title":"npm库","date":"2020-06-23T10:29:31.000Z","path":"2020/06/23/npm/npm库/","text":"命令行相关 commander.js node.js命令行开发工具开发库，使node.js开发CLI工具变得简单，允许快捷的定义形如&lt;command&gt; [options]的命令。 inquirer.js node.js 交互式命令行界面开发库，允许方便的定义使用上下左右进行列表选择等交互式命令。 ora 优雅的命令行Loading动画。","tags":[],"categories":[{"name":"npm","slug":"npm","permalink":"https://xieyaxin.top/categories/npm/"}]},{"title":"CSS可替换元素","date":"2020-06-14T18:34:12.000Z","path":"2020/06/14/前端/css/CSS可替换元素/","text":"解释在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。 简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 [&lt;iframe&gt;](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe)元素，可能具有自己的样式表，但它们不会继承父文档的样式。 CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的控制内容框中的对象位置。 可替换元素典型的可替换元素有： &lt;iframe&gt; https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe &lt;video&gt; https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video &lt;embed&gt; https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed &lt;img&gt; https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img 有些元素仅在特定情况下被作为可替换元素处理，例如： &lt;option&gt; audio canvas object applet HTML 规范也说了 &lt;input&gt; 元素可替换，因为 &quot;image&quot; 类型的 &lt;input&gt; 元素就像&lt;img&gt;一样被替换。但是其他形式的控制元素，包括其他类型的 &lt;input&gt; 元素，被明确地列为非可替换元素（non-replaced elements）。该规范用术语小挂件（Widgets）来描述它们默认的限定平台的渲染行为。 用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。 CSS 与可替换元素CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值。 需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align。只有可替换元素才能具有这种自带值。 控制内容框中的对象位置 某些CSS属性可用于指定 可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式。这些属性的具体定义可以在 CSS Images Module Level 3 和 CSS Images Module Level 4 规范中找到： object-fit 指定可替换元素的内容对象在元素盒区域中的填充方式。（有些类似于 background-size ） object-position 指定可替换元素的内容对象在元素盒区域中的位置。（类似于 background-position ） 参见 https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element 可替换元素的 HTML 规范 CSS Key Concepts: CSS 语法, @规则, 注释, 优先级和继承, the 盒模型, 布局模式和视觉格式化模型，以及外边距合并，或者初始、计算、解析、指定、使用和实际值。 Definitions of 值语法、简写属性和可替换元素。","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"}]},{"title":"前端SVG库","date":"2020-06-14T12:20:31.000Z","path":"2020/06/14/收集/前端SVG库/","text":"VivusVivus 是一个能动画js类库，它能够给SVG图像显示出被画出来的过程。Vivus是没有其他类库依赖的（比如jQuery)。你仅仅需要在页面中加入这个.js文件，然后传入需要被用来动画的SVG部分就行。同时通过指定一些配置，它能够在页面加载后直接显示动画效果 BonsaiBonsai 是一个功能丰富的 JS 类库，你能够用它来画和 animate 动态内容在网站上。这些内容包括了 HTML5 video、变化的 Canvas 和 SVG。通过 Bonsai 框架，你能画一个简单的矩形、甚至一段矩形，如果你喜欢甚至可以画一个丰富的多人卡通游戏进去。 VelocityVelocity 是一个 JS 类库，它是用来做频繁动画用的。Velocity 的 js 动画“速度”是非常快的。它比JQuery 快，甚至比 CSS 动画还要快。Velocity 的 API 和 $.fn.animate 很像，都是通过$()来操作。velocity()是另一种方法，相比 $().animate()。总而言之，你应该使用一致的animate效果，包括 fadeIn 和 fadeOut 方法（译者：Velocity 提供了 fadeIn 和 fadeOut 方法）。 RaphaelRaphaelJS 也通常是用来在网页上画SVG图和动画的。它兼容各种windows浏览器一直到IE6，因为如此，Raphael成为了市面上最受信赖的js（svg）类库。有了它，你可以制作分析图表、地图、游戏就像在厨房做饭一样。 SnapSnapSVG 是另一个知名 JS 类库，它是由 Dmitry Baranovskiy 开发的（Raphael 同样也是）。同样它也是 Adobe Web Software Group 来维护。和 Raphael 不同的是，它只提供了 ie 最新版支持。这使得 SnapSVG 在体积上小了许多（相比 Raphel）以实现相同的功能（比如 trim）和支持最新的功能。 Lazy Line PainterLaid back Range Painter 是一个 jQuery 插件，通常被用来作绘制图集，有点像 Vivus。通常你会吐槽的是它的也就只有这么一个特殊的功能。让我来解释下，如果你是用Illustrator 或者Inkscape制作的SVG图像，而且SVG图像没有任何颜色上的变化，仅仅是轨迹的变化，可以用它。 SVG.jsSVG.js 是一个轻量级的操作和动画 SVG 类库。你能够操作变化方向、位置和颜色。这还没完，你甚至可以自己实现插件等一些其他功能。这个实例可以attach一些插件，比如svg.filter.js，他可以为你的图片实现 Gaussian blur, desaturase, compare, sepia 等等功能。 WalkwayWalkway 支持3种方式, path, line 和 用polyline来画的svg线。它提供了一个很好的例子，绘制了一个PlayStation 的集合动画。 Progressbar.jsProgressBar.js 是一个可爱的和易于接受的增长曲线图用来绘制卡通SVG线条。有了它，各种形状都可以用作增长曲线。它集成了一些实用的形状如Range,Circle和Block，你甚至可以自行开发一个增长图通过Illustrator或者其他的矢量图绘制工具。 ProgressBar.js 是轻量级，MIT许可的而且支持IE9+。你可以通过它修改大型柱状增长图。你还可以改变属性生成动画，比如stroke breadth, load opacity, load coloring等等。 Chartlist.jsChartist.js 是一个简单的容易被接受的图标库，它是通过SVG绘制的。Chartist的宗旨是提供一个简单的，轻量级的，非侵入式的图表库。你需要提供一些javascript配置对象做一些自定义配置，要不然它会使用默认的配置，即已经默认是排序过后的。 Chartist是通过 inline-SVG绘制的，所以它对DOM操作影响很小，相对于它提供的功能来说。而且意味着Chartist不会提供个人控制、水印、行为等等一些你能够通过简单的HTML, JavaScript and CSS实现的。","tags":[],"categories":[{"name":"收集","slug":"收集","permalink":"https://xieyaxin.top/categories/%E6%94%B6%E9%9B%86/"}]},{"title":"前端Canvas库","date":"2020-06-14T12:18:47.000Z","path":"2020/06/14/收集/前端Canvas库/","text":"开源 JavaScript Canvas 库 Processing.js Processing.js是一个开放的编程语言，在不使用Flash或Java小程序的前提下，可以实现程序图像、动画和互动的应用。Processing.js是轻量，易于了解掌握的理想工具，可用于可视化的数据，创建用户界面和开发基于Web的游戏。 FABRIC.JS FABRIC.JS是一款简单而强大的JavaScript Canvas 库，提供了互动的对象模型，同时还包含 Canvas-to-SVG 解析器。 oCanvas oCanvas是一个JavaScript框架，用于简化HTML5 Canvas标签的使用，可以利用对象来代替像素。 oCanvas 可以帮助你很容易的在 HTML5 的 Canvas 标签上创建对象，并且创建这些对象的动画 jCanvas jCanvas 就是一个 jQuery 的绘图插件，它封装了一些绘制图形的方法，只需编写几行代码即可生成图形。 RGraph RGraph是一个使用HTML5 Canvas标签实现的图表制作Library。利用该Library生成的Chart具有可交互性，当鼠标点击或移过时会显示相应的信息，可以动态加载Chart或对特殊点进行缩放。 Two.js Two.js 是面向现代 Web 浏览器的一个二维绘图 API。Two.js 可以用于多个场合：SVG，Canvas 和 WebGL，旨在使平面形状和动画的创建更方便，更简洁。 Paper.js Paper.js是一款开源的矢量图形脚本框架，基于 HTML5 Canvas 开发，提供清晰的场景图、DOM和大量强大的功能用来创建各种向量图和贝塞尔曲线。 EaselJS EaselJS 是一个封装了 HTML5 画布(Canvas) 元素的 JavaScript 库。 Kinetic.JS Kinetic.JS 是一个封装了 HTML5 Canvas的JavaScript 库，能为桌面和移动应用提供高性能动画，转场效果，节点嵌套，分层，滤镜，缓存，事件处理以及更多功能。 Pixi.js Pixi.js 是一个 2D webGL 渲染器，提供无缝 Canvas 回退，支持主流浏览器，包括桌面和移动。","tags":[],"categories":[{"name":"收集","slug":"收集","permalink":"https://xieyaxin.top/categories/%E6%94%B6%E9%9B%86/"}]},{"title":"前端动画库","date":"2020-06-14T12:17:46.000Z","path":"2020/06/14/收集/前端动画库/","text":"https://www.uisdc.com/10-best-free-animation-libraries GSAP https://greensock.com/gsap Anime.js http://animejs.com/ Wicked CSS Animate CSS Tuesday CSShake http://csshake.surge.sh/ Mo.js http://mojs.io/ Animate Plus Bounce.js Magic wow.js https://www.delac.io/wow/ GreenSock https://www.tweenmax.com.cn/ 可以用作一镜到底的动画制作 fullPage.js http://www.dowebok.com/demo/2014/77/ 视差动画库 http://matthew.wagerfield.com/parallax/","tags":[],"categories":[{"name":"收集","slug":"收集","permalink":"https://xieyaxin.top/categories/%E6%94%B6%E9%9B%86/"}]},{"title":"Nginx中server_name 参数详解","date":"2020-06-11T12:01:02.000Z","path":"2020/06/11/知识/nginx/Nginx中server_name 参数详解/","text":"Nginx中的server_name指令主要用于配置基于名称的虚拟主机，server_name指令在接到请求后的匹配顺序分别为： 1、准确的server_name匹配，例如： 12345server &#123; listen 80; server_name domain.com www.domain.com; ...&#125; 2、以*通配符开始的字符串： 1234server &#123; listen 80; server_name *.domain.com; ...&#125; 3、以*通配符结束的字符串： 12345server &#123; listen 80; server_name www.*; ...&#125; 4、匹配正则表达式： 1234server &#123; listen 80; server_name ~^(?.+)\\.domain\\.com$; ...&#125; nginx将按照1,2,3,4的顺序对server name进行匹配，只有有一项匹配以后就会停止搜索，所以我们在使用这个指令的时候一定要分清楚它的匹配顺序（类似于location指令）。 server_name指令一项很实用的功能便是可以在使用正则表达式的捕获功能，这样可以尽量精简配置文件，毕竟太长的配置文件日常维护也很不方便。下面是2个具体的应用： 1、在一个server块中配置多个站点： 1234567server &#123; listen 80; server_name ~^(www\\.)?(.+)$; index index.php index.html; root &#x2F;data&#x2F;wwwsite&#x2F;$2; &#125; 站点的主目录应该类似于这样的结构： 1234&#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;data&#x2F;wwwsite&#x2F;nginx.org&#x2F;data&#x2F;wwwsite&#x2F;baidu.com&#x2F;data&#x2F;wwwsite&#x2F;google.com 这样就可以只使用一个server块来完成多个站点的配置。 2、在一个server块中为一个站点配置多个二级域名。 实际网站目录结构中我们通常会为站点的二级域名独立创建一个目录，同样我们可以使用正则的捕获来实现在一个server块中配置多个二级域名： 12345678910server &#123; listen 80; server_name ~^(.+)?\\.domain\\.com$; index index.html; if ($host &#x3D; domain.com)&#123; rewrite ^ http:&#x2F;&#x2F;www.domain.com permanent; &#125; root &#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;$1&#x2F;; &#125; 站点的目录结构应该如下： 12&#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;www&#x2F;&#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;nginx&#x2F; 这样访问www.domain.com时root目录为/data/wwwsite/domain.com/www/，nginx.domain.com时为/data/wwwsite/domain.com/nginx/，以此类推。 后面if语句的作用是将domain.com的方位重定向到www.domain.com，这样既解决了网站的主目录访问，又可以增加seo中对www.domain.com的域名权重。 server_name同样也可以使用 ip进行匹配，以下是自己使用IP进行配置单的： 123456789101112131415161718 upstream web_app &#123; server 127.0.0.1:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s; server 127.0.0.1:8081 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;&#125; server&#123; listen 8093; \\#server_name 127.0.0.1:8093; server_name 192.168.47.128:8093 access_log logs&#x2F;host.access.log main; location &#x2F; &#123; proxy_next_upstream http_502 http_504 error timeout invalid_header; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http:&#x2F;&#x2F;web_app; expires 3d; &#125; 以上配置的为用两个tomcat做负载均衡，分别为8080、8081，当通过 192.168.47.128:8093 访问时会随机分配到这两个tomcat上,但是在配置时我把 listen 换成 80 就会访问不到，原因还没弄清楚，有知道原因的还请留言告知，不胜感激！！！！","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"nginx","slug":"知识/nginx","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/nginx/"}]},{"title":"JavaScript与有限状态机","date":"2020-06-09T10:38:54.000Z","path":"2020/06/09/知识/JavaScript与有限状态机/","text":"有限状态机（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物。 简单说，它有三个特征： * 状态总数（state）是有限的。 * 任一时刻，只处在一种状态之中。 * 某种条件下，会从一种状态转变（transition）到另一种状态。 它对JavaScript的意义在于，很多对象可以写成有限状态机。 举例来说，网页上有一个菜单元素。鼠标悬停的时候，菜单显示；鼠标移开的时候，菜单隐藏。如果使用有限状态机描述，就是这个菜单只有两种状态（显示和隐藏），鼠标会引发状态转变。 代码可以写成下面这样： 12345678910111213141516171819202122232425 var menu &#x3D; &#123; &#x2F;&#x2F; 当前状态 currentState: &#39;hide&#39;, &#x2F;&#x2F; 绑定事件 initialize: function() &#123; var self &#x3D; this; self.on(&quot;hover&quot;, self.transition); &#125;, &#x2F;&#x2F; 状态转换 transition: function(event)&#123; switch(this.currentState) &#123; case &quot;hide&quot;: this.currentState &#x3D; &#39;show&#39;; doSomething(); break; case &quot;show&quot;: this.currentState &#x3D; &#39;hide&#39;; doSomething(); break; default: console.log(&#39;Invalid State!&#39;); break; &#125; &#125; &#125;; 可以看到，有限状态机的写法，逻辑清晰，表达力强，有利于封装事件。一个对象的状态越多、发生的事件越多，就越适合采用有限状态机的写法。 另外，JavaScript语言是一种异步操作特别多的语言，常用的解决方法是指定回调函数，但这样会造成代码结构混乱、难以测试和除错等问题。有限状态机提供了更好的办法：把异步操作与对象的状态改变挂钩，当异步操作结束的时候，发生相应的状态改变，由此再触发其他操作。这要比回调函数、事件监听、发布/订阅等解决方案，在逻辑上更合理，更易于降低代码的复杂度。 下面介绍一个有限状态机的函数库Javascript Finite State Machine。这个库非常好懂，可以帮助我们加深理解，而且功能一点都不弱。 该库提供一个全局对象StateMachine，使用该对象的create方法，可以生成有限状态机的实例。 1var fsm &#x3D; StateMachine.create(); 生成的时候，需要提供一个参数对象，用来描述实例的性质。比如，交通信号灯（红绿灯）可以这样描述： 1234567891011 var fsm &#x3D; StateMachine.create(&#123; initial: &#39;green&#39;, events: [ &#123; name: &#39;warn&#39;, from: &#39;green&#39;, to: &#39;yellow&#39; &#125;, &#123; name: &#39;stop&#39;, from: &#39;yellow&#39;, to: &#39;red&#39; &#125;, &#123; name: &#39;ready&#39;, from: &#39;red&#39;, to: &#39;yellow&#39; &#125;, &#123; name: &#39;go&#39;, from: &#39;yellow&#39;, to: &#39;green&#39; &#125; ] &#125;); 交通信号灯的初始状态（initial）为green，events属性是触发状态改变的各种事件，比如warn事件使得green状态变成yellow状态，stop事件使得yellow状态变成red状态等等。 生成实例以后，就可以随时查询当前状态。 fsm.current ：返回当前状态。 fsm.is(s) ：返回一个布尔值，表示状态s是否为当前状态。 fsm.can(e) ：返回一个布尔值，表示事件e是否能在当前状态触发。 fsm.cannot(e) ：返回一个布尔值，表示事件e是否不能在当前状态触发。 Javascript Finite State Machine允许为每个事件指定两个回调函数，以warn事件为例： onbeforewarn：在warn事件发生之前触发。 onafterwarn（可简写成onwarn） ：在warn事件发生之后触发。 同时，它也允许为每个状态指定两个回调函数，以green状态为例： onleavegreen ：在离开green状态时触发。 onentergreen（可简写成ongreen） ：在进入green状态时触发。 假定warn事件使得状态从green变为yellow，上面四类回调函数的发生顺序如下：onbeforewarn → onleavegreen → onenteryellow → onafterwarn。 除了为每个事件和状态单独指定回调函数，还可以为所有的事件和状态指定通用的回调函数。 1234* onbeforeevent ：任一事件发生之前触发。* onleavestate ：离开任一状态时触发。* onenterstate ：进入任一状态时触发。* onafterevent ：任一事件结束后触发。 如果事件的回调函数里面有异步操作（比如与服务器进行Ajax通信），这时我们可能希望等到异步操作结束，再发生状态改变。这就要用到transition方法。 123456fsm.onleavegreen = function()&#123; light.fadeOut('slow', function() &#123; fsm.transition(); &#125;); return StateMachine.ASYNC; &#125;; 上面代码的回调函数里面，有一个异步操作（light.fadeOut）。如果不希望状态立即改变，就要让回调函数返回StateMachine.ASYNC，表示状态暂时不改变；等到异步操作结束，再调用transition方法，使得状态发生改变。 Javascript Finite State Machine还允许指定错误处理函数，当发生了当前状态不可能发生的事件时自动触发。 1234567var fsm &#x3D; StateMachine.create(&#123; &#x2F;&#x2F; ... error: function(eventName, from, to, args, errorCode, errorMessage) &#123; return &#39;event &#39; + eventName + &#39;: &#39; + errorMessage; &#125;, &#x2F;&#x2F; ... &#125;); 比如，当前状态是green，理论上这时只可能发生warn事件。要是这时发生了stop事件，就会触发上面的错误处理函数。 Javascript Finite State Machine的基本用法就是上面这些，更详细的介绍可以参见它的主页。 （完） 参考文献： https://github.com/yhanwen/fsm","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"}]},{"title":"tsconfig.json模板文件","date":"2020-06-09T09:14:43.000Z","path":"2020/06/09/ts/tsconfig.json模板文件/","text":"123456789101112131415&#123; &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;sourceMap&quot;: true, &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@&#x2F;*&quot;: [&quot;.&#x2F;source&#x2F;*&quot;] &#125; &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot; ]&#125;","tags":[],"categories":[{"name":"ts","slug":"ts","permalink":"https://xieyaxin.top/categories/ts/"}]},{"title":"捕鱼轨迹的心路历程","date":"2020-06-08T15:05:30.000Z","path":"2020/06/08/随想/捕鱼轨迹的心路历程/","text":"新的任务需求，要求上手一款捕鱼进行定制化修改，好在这款产品仍然处于初期状态，这样也就有了足够的时间来进行代码的梳理以及结构的调整。其中主要运用的是观察者发布者模式，其中提供一个中央事件总线进行管理。这些都是比较简单的，逻辑思维没啥比较绕的部分，不过在实现中，考虑到一些原因，现在记录下市面上一些捕鱼的轨迹实现，主要是为了能够方面的实现界面重绘。 前提： 鱼的路线是一段一段的路径点，是一个一个点之间移动的。单条鱼的路径不需要特别的说明，比较难的是鱼阵的实现方式，考虑到鱼阵需要重新绘制，因此如果采用计时器方法周期性出鱼的话就会导致无法比较精确的重绘鱼，而且也会使得不知道当前需要出第几条鱼，除非服务器端有非常详细的出鱼时间。当前暂没有服务器端配合，我考虑的是一次性绘制出所有的鱼群，这样就能直接移动偏移就行了. 思路: A-&gt;B-&gt;C-&gt;D-&gt;F…….鱼是按照这样一个一个点的走,中间AB间的过度采用的是匀速直线前进(有些人采用的是中间用内塞尔算法平滑过渡,但是这样我暂时没有办法让他匀速.控制不了速度感觉就如脱缰的野马一样). 我们先绘制出鱼阵的路线,编上号,在让每一条鱼根据对应的编号走就行了. demo暂缓","tags":[],"categories":[{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"}]},{"title":"JS中自定义事件的使用与触发","date":"2020-06-01T11:09:33.000Z","path":"2020/06/01/前端/javascript/JS中自定义事件的使用与触发/","text":"1. 事件的创建JS中，最简单的创建事件方法，是使用Event构造器： 1var myEvent &#x3D; new Event(&#39;event_name&#39;); 但是为了能够传递数据，就需要使用 CustomEvent 构造器： 123456var myEvent &#x3D; new CustomEvent(&#39;event_name&#39;, &#123; detail:&#123; &#x2F;&#x2F; 将需要传递的数据写在detail中，以便在EventListener中获取 &#x2F;&#x2F; 数据将会在event.detail中得到 &#125;,&#125;); 2. 事件的监听JS的EventListener是根据事件的名称来进行监听的，比如我们在上文中已经创建了一个名称为‘event_name’ 的事件，那么当某个元素需要监听它的时候，就需要创建相应的监听器： 1234567&#x2F;&#x2F;假设listener注册在window对象上window.addEventListener(&#39;event_name&#39;, function(event)&#123; &#x2F;&#x2F; 如果是CustomEvent，传入的数据在event.detail中 console.log(&#39;得到数据为：&#39;, event.detail); &#x2F;&#x2F; ...后续相关操作&#125;); 至此，window对象上就有了对‘event_name’ 这个事件的监听器，当window上触发这个事件的时候，相关的callback就会执行。 3. 事件的触发对于一些内置（built-in）的事件，通常都是有一些操作去做触发，比如鼠标单击对应MouseEvent的click事件，利用鼠标（ctrl+滚轮上下）去放大缩小页面对应WheelEvent的resize事件。然而，自定义的事件由于不是JS内置的事件，所以我们需要在JS代码中去显式地触发它。方法是使用 dispatchEvent 去触发（IE8低版本兼容，使用fireEvent）： 1234567891011121314&#x2F;&#x2F; 首先需要提前定义好事件，并且注册相关的EventListenervar myEvent &#x3D; new CustomEvent(&#39;event_name&#39;, &#123; detail: &#123; title: &#39;This is title!&#39;&#125;,&#125;);window.addEventListener(&#39;event_name&#39;, function(event)&#123; console.log(&#39;得到标题为：&#39;, event.detail.title);&#125;);&#x2F;&#x2F; 随后在对应的元素上触发该事件if(window.dispatchEvent) &#123; window.dispatchEvent(myEvent);&#125; else &#123; window.fireEvent(myEvent);&#125;&#x2F;&#x2F; 根据listener中的callback函数定义，应当会在console中输出 &quot;得到标题为： This is title!&quot; 需要特别注意的是，当一个事件触发的时候，如果相应的element及其上级元素没有对应的EventListener，就不会有任何回调操作。对于子元素的监听，可以对父元素添加事件托管，让事件在事件冒泡阶段被监听器捕获并执行。这时候，使用event.target就可以获取到具体触发事件的元素。","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"前端/javascript","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/javascript/"}]},{"title":"cocos中getLocation以左下角为坐标原点问题","date":"2020-05-27T16:58:32.000Z","path":"2020/05/27/cocos/cocos中getLocation以左下角为坐标原点问题/","text":"参考链接 https://forum.cocos.org/t/creator/85600 按下面这样从世界坐标转化为本地节点坐标就行了 123456 this.map.on(cc.Node.EventType.MOUSE_DOWN,function(event) &#123; let pos = this.map.convertToNodeSpaceAR(event.getLocation()); this.graphics.fillColor = new cc.Color().fromHEX('#0000ff'); this.graphics.circle(pos.x,pos.y,10) this.graphics.fill();&#125;,this)","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"JavaScript项目中锁定npm依赖包版本","date":"2020-05-26T13:41:59.000Z","path":"2020/05/26/知识/前端/JavaScript项目中锁定npm依赖包版本/","text":"前言：最近使用cnpm安装项目依赖后，运行项目出现样式错乱问题。 描述：最近升级项目webpack的时候，删除了node_modules，重新安装了，cnpm install，运行项目发现有些地方样式和之前样式不一样，样式变得错乱了，然后就开始找问题,找到运行正常的同事对比了package.json发现版本信息都一样，问题就很奇怪，按理package.json里面一样，node_modules也一样才对。 然后把同事的node_modules拷贝过来，结果运行正常， 为什么node_modules会不一样？和同事对比了依赖的版本，发现还是有差异的，左边是有错误的，右边是正确; 然后我安装成右边正确的版本，发现样式问题都好了。为什么会造成安装的版本不一样？图下是本地项目package.json依赖 网上找了下 包里面的^是什么意思,示例如下：1.2.1-匹配指定版本，这里是匹配1.2.1。 ^1.0.0匹配 &gt;=1.0.0 且 &lt;2.0.0的版本。^ 前缀意为 与指定的版本兼容 。^ 前缀表示最左边的非0段不允许改变，该段之后的段可以为更高版，所以^1.1.0 匹配 &gt;=1.1.0 且 &lt;2.0.0^0.0.3 匹配 &gt;=0.0.3 且 &lt;0.0.4 latest当前发布版本。这是一个标记（tag，详见 dist-tag |npm Documentation），默认情况下 npm install 安装的就是这个 latest 标记。 常见的标记还有 next stable beta canary 。 ^5.x匹配 &gt;=5.0.0 且 &lt;6.0.0。X, x 及 * 为通配符，版本号尾部省略的段等同于通配符，所以匹配 &gt;=0.0.01 匹配 &gt;=1.0.0 且 &lt;2.0.01.2 匹配 &gt;=1.2.0 且 &lt;1.3.0 ~0.1.1匹配 &gt;=0.1.1 且 &lt;0.2.0。 ~前缀意为 约等于版本如果存在次版本号，则允许修订号为更高版，否则允许次版本号为更高版。 ~1匹配 &gt;=1.0.0 且 &lt;2.0.0匹配 &gt;=0.0.0 =3.0.0同字面意义 &gt;=3.0.0。 &lt; &lt;= &gt; &gt;= =多个表达式之间用 空格 分隔表示并集，用 || 分隔交集。 1.30.2 - 2.30.2匹配 &gt;=1.30.2 且 &lt;=2.30.2 原因已经找到了，怎么来解决这个问题？我们安装依赖常用的方式有3种cnpm、npm、yarn: cnpm：优点是速度快，缺点是没办法保证每个同事安装依赖的时候版本一致，就会出现依赖升级不兼容性问题 npm：优点是通过package-lock.json文件能够锁定版本，缺点是安装速度慢。 yarn：优点是速度比npm快、yarn.lock文件能够锁定版本,缺点是学习成本相对高。 基于团队考虑，还是使用的yarn来控制项目依赖的版本,yarn使用起来和npm 大同小异，学习起来还是比较快的。问题解决了，开心。下面解释下yarn常用方法， yarn 使用方法安装yarn1brew install yarn 安装项目的全部依赖1yarn || yarn install 添加依赖包分别添加到 devDependencies、peerDependencies 和 optionalDependencies 类别中：yarn 类型npm installyarn add [name] --devyarn add [name] --peeryarn add [name] --optional 更新依赖123yarn upgrade [package] --dev&#96;&#96;yarn upgrade [package]@[version] --dev&#96;&#96;yarn upgrade [package]@[tag] --dev 删除依赖1yarn remove [package] 总结一直都是使用cnpm来安装依赖，安装速度快，也比较方便，但是多人协作开发是容易出现问题，多人协作开发依赖版本应该保持一致。避免依赖版本不兼容项目出现问题。","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"知识/前端","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/"}]},{"title":"圣杯布局,双飞翼布局","date":"2020-05-25T23:33:31.000Z","path":"2020/05/25/前端/css/圣杯布局,双飞翼布局/","text":"作者：放羊的小桃桃链接：https://www.jianshu.com/p/81ef7e7094e8来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。参考： https://www.cnblogs.com/imwtr/p/4441741.html 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个 两侧宽度固定，中间宽度自适应的三栏布局。 圣杯布局来源于文章In Search of the Holy Grail，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点： 两侧宽度固定，中间宽度自适应 中间部分在DOM结构上优先，以便先行渲染 允许三列中的任意一列成为最高列 只需要使用一个额外的&lt;div&gt;标签 圣杯布局DOM结构1234567&lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;container&quot;&gt; &lt;div id&#x3D;&quot;center&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; 首先定义出整个布局的DOM结构，主体部分是由container包裹的center,left,right三列，其中center定义在最前面。 CSS代码假设左侧的固定宽度为200px，右侧的固定宽度为150px，则首先在container上设置： 1234#container &#123; padding-left: 200px; padding-right: 150px;&#125; 为左右两列预留出相应的空间，得到如下示意图： 随后分别为三列设置宽度与浮动，同时对footer设置清除浮动： 12345678910111213141516171819#container .column &#123; float: left;&#125;#center &#123; width: 100%;&#125;#left &#123; width: 200px; &#125;#right &#123; width: 150px; &#125;#footer &#123; clear: both;&#125; 得到如下效果： 根据浮动的特性，由于center的宽度为100%，即占据了第一行的所有空间，所以left和right被“挤”到了第二行。 接下来的工作是将left放置到之前预留出的位置上，这里使用 负外边距（nagetive margin）： 12345#left &#123; width: 200px; &#x2F;&#x2F;这里是父元素宽度的% margin-left: -100%;&#125; 得到： 随后还需要使用定位(position)方法： 123456#left &#123; width: 200px; margin-left: -100%; position: relative; right: 200px;&#125; 这里使用position: relative和right: 200px将left的位置在原有位置基础上左移200px，以完成left的放置： 接下来放置right，只需添加一条声明即可： 1234#right &#123; width: 150px; margin-right: -150px; &#125; 得到最终的效果图： 至此，布局效果完成。不过还需要考虑最后一步，那就是页面的最小宽度：要想保证该布局效果正常显示，由于两侧都具有固定的宽度，所以需要给定页面一个最小的宽度，但这并不只是简单的200+150=350px。回想之前left使用了position: relative，所以就意味着在center开始的区域，还存在着一个left的宽度。所以页面的最小宽度应该设置为200+150+200=550px： 123body &#123; min-width: 550px;&#125; 综上所述，圣杯布局的CSS代码为： 1234567891011121314151617181920212223242526272829303132body &#123; min-width: 550px;&#125;#container &#123; padding-left: 200px; padding-right: 150px;&#125;#container .column &#123; float: left;&#125;#center &#123; width: 100%;&#125;#left &#123; width: 200px; margin-left: -100%; position: relative; right: 200px;&#125;#right &#123; width: 150px; margin-right: -150px; &#125;#footer &#123; clear: both;&#125; 关于圣杯布局的示例，可参考：圣杯布局 最后提醒一下很多朋友可能会忽略的小细节：在#center中，包含了一条声明width: 100%，这是中间栏能够做到自适应的关键。可能会有朋友认为不需要设置这条声明，因为觉得center在不设置宽度的情况下会默认将宽度设置为父元素(container)的100%宽度。但需要注意到，center是浮动元素，由于浮动具有包裹性，在不显式设置宽度的情况下会自动“收缩”到内容的尺寸大小。如果去掉width: 100%，则当中间栏不包含或者包含较少内容时，整个布局会“崩掉”，而达不到这样的效果： 双飞翼布局DOM结构123456789&lt;body&gt; &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;column&quot;&gt; &lt;div id&#x3D;&quot;center&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;&lt;body&gt; 双飞翼布局的DOM结构与圣杯布局的区别是用container仅包裹住center，另外将.column类从center移至container上。 CSS代码按照与圣杯布局相同的思路，首先设置各列的宽度与浮动，并且为左右两列预留出空间，以及为footer设置浮动清除： 123456789101112131415161718192021222324#container &#123; width: 100%;&#125;.column &#123; float: left;&#125;#center &#123; margin-left: 200px; margin-right: 150px;&#125;#left &#123; width: 200px; &#125;#right &#123; width: 150px; &#125;#footer &#123; clear: both;&#125; 得到如下效果示意图: 以上代码将container,left,right设置为float: left，而在container内部，center由于没有设置浮动，所以其宽度默认为container的100%宽度，通过对其设置margin-left和margin-right为左右两列预留出了空间。 将left放置到预留位置： 1234#left &#123; width: 200px; margin-left: -100%;&#125; 得到：将right放置到预留位置： 1234#right &#123; width: 150px; margin-left: -150px;&#125; 得到最终效果： 最后计算最小页面宽度：由于双飞翼布局没有用到position:relative进行定位，所以最小页面宽度应该为200+150=350px。但是当页面宽度缩小到350px附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖，如下所示： 因此在设置最小页面宽度时，应该适当增加一些宽度以供中间栏使用（假设为150px），则有： 123body &#123; min-width: 500px;&#125; 至此双飞翼布局大功告成！其布局整体代码为： 123456789101112131415161718192021222324252627282930body &#123; min-width: 500px;&#125;#container &#123; width: 100%;&#125;.column &#123; float: left;&#125; #center &#123; margin-left: 200px; margin-right: 150px;&#125; #left &#123; width: 200px; margin-left: -100%;&#125; #right &#123; width: 150px; margin-left: -150px;&#125; #footer &#123; clear: both;&#125; 关于双飞翼布局的示例，可参考：双飞翼布局 总结与思考通过对圣杯布局和双飞翼布局的介绍可以看出，圣杯布局在DOM结构上显得更加直观和自然，且在日常开发过程中，更容易形成这样的DOM结构（通常&lt;aside&gt;和&lt;article&gt;/&lt;section&gt;一起被嵌套在&lt;main&gt;中）；而双飞翼布局在实现上由于不需要使用定位，所以更加简洁，且允许的页面最小宽度通常比圣杯布局更小。 其实通过思考不难发现，两者在代码实现上都额外引入了一个标签，其目的都是为了既能保证中间栏产生浮动（浮动后还必须显式设置宽度），又能限制自身宽度为两侧栏留出空间。 从这个角度出发，如果去掉额外添加的标签，能否完成相同的布局呢？答案是肯定的，不过这需要在兼容性上做出牺牲： DOM结构12345&lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;center&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt; 去掉额外的&lt;div&gt;标签后，得到的DOM结构如上所示，基于双飞翼布局的实现思路，只需要在center上做出修改： 使用calc()123456789.column &#123; float: left;&#125; #center &#123; margin-left: 200px; margin-right: 150px; width: calc(100% - 350px);&#125; 通过calc()可以十分方便地计算出center应该占据的自适应宽度，目前calc()支持到IE9。 使用border-box12345678910.column &#123; float: left;&#125; #center &#123; padding-left: 200px; padding-right: 150px; box-sizing: border-box; width: 100%;&#125; 使用border-box可以将center的整个盒模型宽度设置为父元素的100%宽度，此时再利用padding-left和padding-right可以自动得到中间栏的自适应宽度。不过需要注意的是，由于padding是盒子的一部分，所以padding部分会具有中间栏的背景色，当中间栏高于侧栏时，会出现这样的情况： 目前box-sizing支持到IE8。 使用flex这里使用flex还是需要与圣杯布局相同的DOM结构，不过在实现上将更加简单： 123456&lt;!-- DOM结构 --&gt;&lt;div id&#x3D;&quot;container&quot;&gt; &lt;div id&#x3D;&quot;center&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 12345678910111213141516#container &#123; display: flex;&#125;#center &#123; flex: 1;&#125;#left &#123; flex: 0 0 200px; order: -1;&#125;#right &#123; flex: 0 0 150px;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"}]},{"title":"自定义设置hr的颜色","date":"2020-05-25T23:32:31.000Z","path":"2020/05/25/前端/css/自定义设置hr的颜色/","text":"1、hr的颜色不能使用color来控制，要使用background-color来控制 2、hr的高度不能为 0 3,、还会有灰色的阴影，设置border:none 默认的hr样式 自定的hr样式： 附上代码： 12345hr &#123; height: 1px; background-color: #6EECB4; border: none;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"}]},{"title":"让容器充满屏幕高度或自适应剩余高度","date":"2020-05-25T23:28:43.000Z","path":"2020/05/25/前端/css/让容器充满屏幕高度或自适应剩余高度/","text":"在前端页面布局中，经常会碰到要让容器充满整个屏幕高度或者剩余屏幕高度的需求。一般这时候都会想当然的使用 height:100% 这样的 CSS 来写。这样写的话，当容器内内容很多的时候是没有问题的，可以达到预期的效果，但是如果容器内内容比较少，不足以撑起足够的高度的话，这个CSS 样式实际上是没起作用的。那要怎么解决这个问题呢？ 让容器高度充满这个屏幕 在容器内容很少的情况下，要想让这个容器充满整个屏幕可以这样： 123.container&#123; min-height:100vh;&#125; 这个新的单位可能有的老浏览器不支持（说的是谁你们都知道的）。可以去caniuse看一下 让容器高度充满剩余屏幕高度 上面说的让容器充满整个屏幕是一个比较简单的情况，实际项目中这种简单情况是非常少的，一般碰到比较多的可能是要让容器充满屏幕的剩余高度，有了上面的那个做基础，这个需求也就简单了，用 vh 结合 flex 布局就可以很容器的实现。直接看代码： 12345678910111213.container&#123; min-height:100vh; display:flex;&#125;.header&#123; height:100px&#125;.content&#123; flex:1;&#125;.footer&#123; height:100px;&#125; 使用上面的样式就可以让 content 的高度自适应屏幕的剩余高度，简单方便。同样可能会面临老浏览器适配的问题。因为我做的项目主要是在移动端使用，所以就不管那老掉牙的家伙了。","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"}]},{"title":"css 伪类实现弧形","date":"2020-05-25T23:26:47.000Z","path":"2020/05/25/前端/css/css 伪类实现弧形/","text":"在实现页面五花八门的有特色的ui时，我们有时会遇到要用实现一个弧形，而这样的弧形要怎么实现呢？用图片？好像不大现实，因为这样就要无故多加载一张图片了，这里我们来说说怎么用css的after伪类来实现弧形。 ![img](/static/前端/css/css 伪类实现弧形/images/7513201-18bc753766c1fc46.png) 先是一写元素，再给这个元素设置样式和伪类样式 &lt;view class=&quot;pure_top&quot;&gt;&lt;/view&gt; 比如说这个pure_top元素(因为这里是小程序所以用的是view，h5也是一样实现的啦)，我设置的样式如下: 12345678910111213141516171819.pure_top &#123; width: 100%; height: 100px; position: relative; z-index: -1; overflow: hidden;&#125;.pure_top::after &#123; content: &#39;&#39;; width: 140%; height: 100px; position: absolute; left: -20%; top: 0; z-index: -1; border-radius: 0 0 50% 50%; background: #1496f1;&#125; 如何在元素后追加一个after，当然是元素自身定位为relative，伪类设置content:‘’，并相对定位为absolute，再设置下left ,top 值，使伪类元素的位置摆放的合理就行了。 这里需要注意的是我把z-index值设为-1，因为弧形一般是作为背景图的，所有层级自然要放低些。 实现效果如下图： ![img](/static/前端/css/css 伪类实现弧形/images/7513201-4d0d0a9438d118e3.png) 上面的图看起来好像弧度太大，几乎要看不出。依上面的实现原理，弧度要多少可以是自己微调。看上面的伪类.pure_top::after { content: &#39;&#39;;width: 140%;}宽度为140%，难怪弧度那么大呢？半径越大，弧度就越大(我应该没记错吧哈哈哈哈哈哈)，那我们是不是可以减小半径来达到变小弧度的需求？看下图的实现： ![img](/static/前端/css/css 伪类实现弧形/images/7513201-8833cd268690e1c6.png) 123456789101112131415161718.gradient_top &#123; width:100%; height: 330rpx; position: relative; z-index: -1; overflow: hidden;&#125;.gradient_top::after &#123; content: &#39;&#39;; width: 100%; height: 330rpx; position: absolute; left: 0; top:0; z-index: -1; border-radius: 0 0 80% 80%; background: linear-gradient(160deg,#1496f1, #E0F0FA);&#125; 这里把伪类的宽设为100%，left ， top值自然就为0了。 这里可以看到，如果要设置渐变，把background设为渐变就可以了，但是注意，我都是把颜色设置在伪类上的。 学会了就快去实现你丰富多彩的界面吧~","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"}]},{"title":"animation动画结束后css样式怎么保留最后状态","date":"2020-05-25T23:25:14.000Z","path":"2020/05/25/css/知识/animation动画结束后css样式怎么保留最后状态/","text":"1animation-fill-mode:forwards","tags":[],"categories":[{"name":"css","slug":"css","permalink":"https://xieyaxin.top/categories/css/"},{"name":"知识","slug":"css/知识","permalink":"https://xieyaxin.top/categories/css/%E7%9F%A5%E8%AF%86/"}]},{"title":"样式统一化","date":"2020-05-25T23:24:21.000Z","path":"2020/05/25/css/知识/样式统一化/","text":"Normalize.css reset.css","tags":[],"categories":[{"name":"css","slug":"css","permalink":"https://xieyaxin.top/categories/css/"},{"name":"知识","slug":"css/知识","permalink":"https://xieyaxin.top/categories/css/%E7%9F%A5%E8%AF%86/"}]},{"title":"css权重简述","date":"2020-05-25T23:22:45.000Z","path":"2020/05/25/css/知识/css权重简述/","text":"简述CSS权重指的是样式的优先级，有两条或者多条元素作用于同一个元素，权重高的样式会起作用，而权重相同的话，后面的权重会覆盖前面的。 权重的等级可以把样式的应用方式分为几个等级，按照等级来计算权重 !important，加在样式属性值后，权重值为 10000 内联样式，如：style=&quot;&quot;，权重值为1000 ID选择器，如：#content，权重值为100 类，伪类和属性选择器，如： content、:hover 权重值为10 标签选择器和伪元素选择器，如：div、p、:before 权重值为1 通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0 有需要计算权重的时候只需要将以上规则套入然后计算就行了","tags":[],"categories":[{"name":"css","slug":"css","permalink":"https://xieyaxin.top/categories/css/"},{"name":"知识","slug":"css/知识","permalink":"https://xieyaxin.top/categories/css/%E7%9F%A5%E8%AF%86/"}]},{"title":"cocos Web构建模板","date":"2020-05-25T15:29:10.000Z","path":"2020/05/25/cocos/cocos Web构建模板/","text":"V1.9.0模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(1.9.0).zip) V2.2.2模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(2.2.2).zip) 其实两个都一样，有报错的话自己解决一下就好了","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"数组篇：chunk分片","date":"2020-05-24T14:50:18.000Z","path":"2020/05/24/loadsh/数组操作/数组篇：chunk分片/","text":"","tags":[],"categories":[{"name":"loadsh","slug":"loadsh","permalink":"https://xieyaxin.top/categories/loadsh/"},{"name":"数组操作","slug":"loadsh/数组操作","permalink":"https://xieyaxin.top/categories/loadsh/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"}]},{"title":"cocos两点之间的距离","date":"2020-05-21T10:52:24.000Z","path":"2020/05/21/cocos/cocos两点之间的距离/","text":"123let startPos = cc.v2(0, 0); //开始位置let endPos = cc.v2(0, 0); //结束位置let distance = startPos.sub(endPos).mag();","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"sourcemap概述","date":"2020-05-20T16:02:53.000Z","path":"2020/05/20/知识/sourcemap/sourcemap概述/","text":"这里直接摘抄阮一峰老师的博客文章用来理解，本身他讲的就通俗易懂 http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html jQuery 1.9发布。 这是2.0版之前的最后一个新版本，有很多新功能，其中一个就是支持Source Map。 访问 http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，打开压缩后的版本，滚动到底部，你可以看到最后一行是这样的： 这就是Source Map。它是一个独立的map文件，与源码在同一个目录下，你可以点击进去，看看它的样子。 这是一个很有用的功能，本文将详细讲解这个功能。 一、从源码转换讲起JavaScript脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。 常见的源码转换，主要是以下三种情况： （1）压缩，减小体积。比如jQuery 1.9的源码，压缩前是252KB，压缩后是32KB。 （2）多个文件合并，减少HTTP请求数。 （3）其他语言编译成JavaScript。最常见的例子就是CoffeeScript。 这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。 通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。 这就是Source map想要解决的问题。 二、什么是Source map简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 目前，暂时只有Chrome浏览器支持这个功能。在Developer Tools的Setting设置中，确认选中&quot;Enable source maps&quot;。 三、如何启用Source map正如前文所提到的，只要在转换后的代码尾部，加上一行就可以了。 1 &#x2F;&#x2F;@ sourceMappingURL&#x3D;&#x2F;path&#x2F;to&#x2F;file.js.map map文件可以放在网络上，也可以放在本地文件系统。 四、如何生成Source map 这里不太对，现在前端webpack，gulp都可以自己生成sourcmap,这一段了解一下就行了，毕竟是好早的了。 最常用的方法是使用Google的Closure编译器。 生成命令的格式如下： 12345 java -jar compiler.jar \\ --js script.js \\ --create_source_map .&#x2F;script-min.js.map \\ --source_map_format&#x3D;V3 \\ --js_output_file script-min.js 各个参数的意义如下： 1234- js： 转换前的代码文件 - create_source_map： 生成的source map文件 - source_map_format：source map的版本，目前一律采用V3。 - js_output_file： 转换后的代码文件。 五、Source map的格式打开Source map文件，它大概是这个样子： 12345678 &#123; version : 3, file: &quot;out.js&quot;, sourceRoot : &quot;&quot;, sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], mappings: &quot;AAgBC,SAAQ,CAAEA&quot; &#125; 整个文件就是一个JavaScript对象，可以被解释器读取。它主要有以下几个属性： 1234567891011- version：Source map的版本，目前为3。- file：转换后的文件名。- sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。- sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。- names：转换前的所有变量名和属性名。- mappings：记录位置信息的字符串，下文详细介绍。 六、mappings属性下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。 关键就是map文件的mappings属性。这是一个很长的字符串，它分成三层。 12345第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。第三层是位置转换，以VLQ编码表示，代表该位置对应的转换前的源码位置。 举例来说，假定mappings属性的内容如下： 1mappings:&quot;AAAAA,BBBBB;CCCCC&quot; 就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。 七、位置对应的原理每个位置使用五位，表示五个字段。 从左边算起， 123456789 - 第一位，表示这个位置在（转换后的代码的）的第几列。 - 第二位，表示这个位置属于sources属性中的哪一个文件。 - 第三位，表示这个位置属于转换前代码的第几行。 - 第四位，表示这个位置属于转换前代码的第几列。 - 第五位，表示这个位置属于names属性中的哪一个变量。 有几点需要说明。首先，所有的值都是以0作为基数的。其次，第五位不是必需的，如果该位置没有对应names属性中的变量，可以省略第五位。再次，每一位都采用VLQ编码表示；由于VLQ编码是变长的，所以每一位可以由多个字符构成。 如果某个位置是AAAAA，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。 八、VLQ编码最后，谈谈如何用VLQ编码表示数值。 这种编码最早用于MIDI文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。 VLQ编码是变长的。如果（整）数值在-15到+15之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用6个两进制位，正好可以借用Base 64编码的字符表。 在这6个位中，左边的第一位（最高位）表示是否”连续”（continuation）。如果是1，代表这６个位后面的6个位也属于同一个数；如果是0，表示该数值到这6个位结束。 12345 Continuation | Sign | | V V １０１０１１ 这6个位中的右边最后一位（最低位）的含义，取决于这6个位是否是某个数值的VLQ编码的第一个字符。如果是的，这个位代表”符号”（sign），0为正，1为负（Source map的符号固定为0）；如果不是，这个位没有特殊含义，被算作数值的一部分。 九、VLQ编码：实例下面看一个例子，如何对数值16进行VLQ编码。 1234567891011 第一步，将16改写成二进制形式10000。 第二步，在最右边补充符号位。因为16大于0，所以符号位为0，整个数变成100000。 第三步，从右边的最低位开始，将整个数每隔5位，进行分段，即变成1和00000两段。如果最高位所在的段不足5位，则前面补0，因此两段变成00001和00000。 第四步，将两段的顺序倒过来，即00000和00001。 第五步，在每一段的最前面添加一个&quot;连续位&quot;，除了最后一段为0，其他都为1，即变成100000和000001。 第六步，将每一段转成Base 64编码。 查表可知，100000为g，000001为B。因此，数值16的VLQ编码为gB。上面的过程，看上去好像很复杂，做起来其实很简单，具体的实现请看官方的base64-vlq.js文件，里面有详细的注释。 十、参考链接 - Introduction To JavaScript Source Maps - Source Map Revision 3 Proposal","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"sourcemap","slug":"知识/sourcemap","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/sourcemap/"}]},{"title":"cocos龙骨局部换装","date":"2020-05-16T17:43:07.000Z","path":"2020/05/16/cocos/cocos龙骨局部换装/","text":"在cocos中，动画是必不可少的，一个细腻的动画可能就是决定一款游戏的成败。对于一些没钱的开发者来说，龙骨动画是一个不错的选择，但是cocos对其的支持并不是十分的友好。这次我们需要解决的是换装的问题。 案例：v2.2.2编辑器，龙骨插槽替换.zip 需要实现的效果 上面是原始效果，可以看到有两个插槽,一个是fish,一个是number。这个时候cocos并不能替换，因为是空的，因此就需要随便添加两个资源。 这里我就添加fish插槽，那个number感觉太麻烦了，是一个滚动的数字。这样的话就能够使用cocos官方提供的方式进行换装替换 了。 制作龙骨模型替换资源 Armature表示 部件名称 killboss_bx表示 插槽名称 kypy_killboss_hjcts表示 插槽中的显示资源名称 接下来对两个资源进行导出，根据论坛中引擎开发人员的建议，将_tex.json后缀的改成了_atlas.json的。类似于 这样的话准备条件就做好了。不过仍有两种方式。 挂载节点替换总代码： 123456789101112131415161718192021222324252627cc.Class(&#123; extends: cc.Component, properties: &#123; b: &#123; type: dragonBones.ArmatureDisplay, default: null, &#125;, c: &#123; type: dragonBones.ArmatureDisplay, default: null, &#125; &#125;, start () &#123; &#x2F;&#x2F; 需要被替换的fish插槽 let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;); let factory &#x3D; dragonBones.CCFactory.getInstance(); factory.replaceSlotDisplay( this.c.getArmatureKey(), &quot;Armature&quot;, &#x2F;&#x2F; 部件名称 &quot;killboss_bx&quot;, &#x2F;&#x2F; 插槽名称 &quot;kypy_killboss_mgy&quot;, &#x2F;&#x2F; 显示资源名称 robotSlot ); this.b.playAnimation(&quot;animation&quot;, 500); &#125;,&#125;); 上面的b表示需要被替换资源的龙骨动画节点组件,c表示将要拿去替换的龙骨节点组件。 这里要保证c中的资源已经加载完毕，在我测试的时候，c节点必须处于激活状态，这样才保证了c节点中龙骨资源的加载。 loader动态加载（推荐）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cc.Class(&#123; extends: cc.Component, properties: &#123; b: &#123; type: dragonBones.ArmatureDisplay, default: null, &#125;, c: &#123; type: dragonBones.ArmatureDisplay, default: null, &#125; &#125;, loadBones(cb) &#123; let name &#x3D; &quot;NewProject&quot; const resources &#x3D; [ cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_ske.json&#96;), cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_atlas.json&#96;), cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_tex.png&#96;), ]; cc.loader.load(resources, (err, assets) &#x3D;&gt; &#123; let factory &#x3D; dragonBones.CCFactory.getInstance(); let data &#x3D; JSON.parse(cc.loader.getRes(resources[0])._dragonBonesJson); factory.parseDragonBonesData(data); let atlasData &#x3D; JSON.parse(cc.loader.getRes(resources[1])._atlasJson); factory.parseTextureAtlasData(atlasData, cc.loader.getRes(resources[2])); console.log(cc.loader.getRes(resources[1])._atlasJson); cb&amp;&amp;cb() &#125;); &#125;, start () &#123; this.loadBones(()&#x3D;&gt;&#123; let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;); let factory &#x3D; dragonBones.CCFactory.getInstance(); factory.replaceSlotDisplay( &quot;NewProject&quot;, &#x2F;&#x2F; 跟上面的一样就行了。 &quot;Armature&quot;, &quot;killboss_bx&quot;, &quot;kypy_killboss_mgy&quot;, robotSlot ); this.b.playAnimation(&quot;animation&quot;, 500); &#125;) &#x2F;&#x2F; this.b.playAnimation(&quot;animation&quot;, 500); &#125;,&#125;); 这里我用的是cc.loader.load方式，这样就能保证资源已经加载完毕了。同时也减少了节点的创建。推荐使用这种方式。 坑点 被换装的插槽里必须有资源才行，空的一个插槽并不能替换。 换装的资源必须加载。如果挂载在节点上必须保证这个节点是激活状态而证明资源是加载过的。 参考资料 https://forum.cocos.org/t/topic/89037 https://docs.cocos.com/creator/manual/zh/components/dragonbones.html?h=%E6%8F%92%E6%A7%BD","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"浏览器的同源策略","date":"2020-05-15T21:13:20.000Z","path":"2020/05/15/知识/前端/同源与跨域/浏览器的同源策略/","text":"同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 同源的例子 http://example.com/app1/index.html http://example.com/app2/index.html same origin because same scheme (http) and host (example.com) http://Example.com:80 http://example.com same origin because a server delivers HTTP content through port 80 by default 不同源的例子 http://example.com/app1 https://example.com/app2 different schemes http://example.com http://www.example.com http://myapp.example.com different hosts http://example.com http://example.com:8080 different ports 同源的定义如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例: URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http:// 默认端口是80) http://news.company.com/dir/other.html 失败 主机不同 源的**继承**在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。 例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 Window.open() ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。 注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。 data：URLs 获得一个新的，空的安全上下文。 IE 中的特例Internet Explorer 的同源策略有两个主要的差异点： 授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），则不受同源策略限制。 端口：IE 未将端口号纳入到同源策略的检查中，因此 https://company.com:81/index.html 和 https://company.com/index.html 属于同源并且不受任何限制。 这些差异点是不规范的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。 源的更改满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 document.domain 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。 例如：假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句： 1document.domain = \"company.com\"; 这条语句执行之后，页面将会成功地通过与 http://company.com/dir/page.html 的同源检测（假设http://company.com/dir/page.html 将其 document.domain 设置为“company.com”，以表明它希望允许这样做 - 更多有关信息，请参阅 document.domain ）。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。 端口号是由浏览器另行检查的。任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此 company.com:8080 不能仅通过设置 document.domain = &quot;company.com&quot; 来与company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。 注意：使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。 跨源网络访问同源策略控制不同源之间的交互，例如在使用XMLHttpRequest 或 ![img](/D:/app/Typora) 标签时则会受到同源策略的约束。这些交互通常分为三类： 跨域*写操作（Cross-origin writes）一般是被允许的。*例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。 跨域*资源嵌入（Cross-origin embedding）*一般是被允许（后面会举例说明）。 跨域*读操作（Cross-origin reads）一般是不被允许的，*但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availability of an embedded resource. 以下是可能嵌入跨源的资源的一些示例： &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 标签嵌入跨域脚本。语法错误信息只能被同源脚本中捕捉到。 `` 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 通过 &lt;img&gt; 展示的图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,… 通过&lt;video&gt;和&lt;audio&gt;播放的多媒体资源。 通过&lt;object&gt;、&lt;embed&gt;、&lt;applet&gt;嵌入的插件。 通过 @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 通过 &lt;iframe&gt; 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。 如何允许跨源访问可以使用 CORS 来允许跨源访问。CORS 是 HTTP 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。 如何阻止跨源访问阻止跨域写操作，只要检测请求中的一个不可推测的标记(CSRF token)即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨站读操作。 阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。 阻止跨站嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在HTML文档中指定 `` 标记，则浏览器将尝试将标签内部的 HTML 解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。 跨源脚本API访问JavaScript 的 API 中，如 iframe.contentWindow、 window.parent、window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制，如下两节所述。 为了能让不同源中文档进行交流，可以使用 window.postMessage。 规范: HTML Living Standard § Cross-origin objects 。 允许以下对 Window 属性的跨源访问： 方法 window.blur window.close window.focus window.postMessage 属性 window.closed 只读. window.frames 只读. window.length 只读. window.location 读/写. window.opener 只读. window.parent 只读. window.self 只读. window.top 只读. window.window 只读. 某些浏览器允许访问除上述外更多的属性。 Location允许以下对 Location 属性的跨源访问： 方法 location.replace 属性 URLUtils.href 某些浏览器允许访问除上述外更多的属性。 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 跨源数据存储访问访问存储在浏览器中的数据，如 localStorage 和 IndexedDB，是以源进行分割。每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。 Cookies 使用不同的源定义方式。一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 Public Suffix List 检测一个域是否是公共后缀（public suffix）。Internet Explorer 使用其内部的方法来检测域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其可访问性。当你读取 cookie 时，你无法知道它是在哪里被设置的。 即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。 参见 Same-Origin Policy at W3C http://web.dev/secure/same-origin-policy","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"知识/前端","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/"},{"name":"同源与跨域","slug":"知识/前端/同源与跨域","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"}]},{"title":"560. 和为K的子数组","date":"2020-05-15T14:49:06.000Z","path":"2020/05/15/leetcode/560. 和为K的子数组/","text":"题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums &#x3D; [1,1,1], k &#x3D; 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 分析输入的第一个形参是数组，第二个表示和。 数组的长度有限制。另外： 求和的不一定是两个，可能有三个四个五个 大于k的也不一定不行，因为下一个可能是负数给抵消了 题解暴力遍历 12345678910111213var subarraySum &#x3D; function(nums, k) &#123; let result &#x3D; 0; for(let i &#x3D; 0; i&lt;&#x3D; nums.length; i++ )&#123; let sum &#x3D; 0; for(let j &#x3D; i; j&lt;&#x3D; nums.length; j++ )&#123; sum +&#x3D; nums[j]; if(sum&#x3D;&#x3D;k)&#123; result++; &#125; &#125; &#125; return result&#125;; 其他题解123456789101112var subarraySum &#x3D; function(nums, k) &#123; const mp &#x3D; new Map(); mp.set(0, 1); let count &#x3D; 0, pre &#x3D; 0; for (const x of nums) &#123; pre +&#x3D; x; if (mp.has(pre - k)) count +&#x3D; mp.get(pre - k); if (mp.has(pre)) mp.set(pre, mp.get(pre) + 1); else mp.set(pre, 1); &#125; return count;&#125;;","tags":[],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xieyaxin.top/categories/leetcode/"}]},{"title":"10种跨域解决方案（终极大招）","date":"2020-05-14T14:13:42.000Z","path":"2020/05/14/疑难杂症/前端/10种跨域解决方案（终极大招）/","text":"原文链接 https://juejin.im/post/5e948bbbf265da47f2561705","tags":[],"categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"前端","slug":"疑难杂症/前端","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%89%8D%E7%AB%AF/"}]},{"title":"scss主题切换功能","date":"2020-05-14T14:01:07.000Z","path":"2020/05/14/前端/scss主题切换功能/","text":"结构类似下面这样： index.html 1234567891011121314151617&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body data-theme&#x3D;&quot;light&quot;&gt; &lt;div class&#x3D;&quot;app-home&quot;&gt; dsakdjsafs &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; index.scss 12345678@import &#39;.&#x2F;_themeify.scss&#39;;.app-home &#123; font-size: 18px; @include themeify &#123; color: themed(&#39;text-color-primary&#39;); &#125;&#125; _themeify.scss 1234567891011121314@import &#39;.&#x2F;_themes.scss&#39;;@mixin themeify &#123; @each $theme-name, $theme-map in $themes &#123; $theme-map: $theme-map !global; body[data-theme&#x3D;#&#123;$theme-name&#125;] &amp; &#123; @content; &#125; &#125;&#125;@function themed($key) &#123; @return map-get($theme-map, $key);&#125; _themes.scss 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$themes: ( default: ( &#x2F;* font-size *&#x2F; font-size-default: 14px, font-size-lg: 16px, font-size-sm: 12px, color-white: #FFF, &#x2F;* Color *&#x2F; color-success: #13CE66, color-error: #FF4949, color-warning: #FFC82C, color-info: #78A4FA, &#x2F;&#x2F; Text Color text-color-primary: #dc2b34, text-color-white: #ffffff, text-color-black: #000000, text-color-default: #4a4a4a, text-color-placeholder: #C9C9C9, text-color-disabled: #CCCCCC, &#x2F;&#x2F; Background Color bg-color-primary: #d91720, bg-color-primary-light: #b51d29, bg-color-white: #ffffff, bg-color-grey: #F7F7F7, bg-color-light: #ECF5FD, bg-color-verifycode: #cfcfcf, &#x2F;&#x2F; Border Color borer-color-primary: #e64644, borer-color-primary-light: #dc2b34, borer-color-white: #ffffff, borer-color-default: #CCCCCC, &#x2F;&#x2F; Link Color link-color-primary: #d91721, link-color-primary-light: #b51d29, link-color: #6190E8, link-color-light: #79A1EB, link-color-disabled: #BFBFBF, &#x2F;&#x2F; Icon Color icon-color-base: #CCC, ), light: ( &#x2F;* font-size *&#x2F; font-size-default: 14px, font-size-lg: 16px, font-size-sm: 12px, color-white: #FFF, &#x2F;* Color *&#x2F; color-success: #13CE66, color-error: #FF4949, color-warning: #FFC82C, color-info: #78A4FA, &#x2F;&#x2F; Text Color text-color-primary: #78A4FA, text-color-white: #ffffff, text-color-black: #000000, text-color-default: #4a4a4a, text-color-placeholder: #C9C9C9, text-color-disabled: #CCCCCC, &#x2F;&#x2F; Background Color bg-color-primary: #d91720, bg-color-primary-light: #b51d29, bg-color-white: #ffffff, bg-color-grey: #F7F7F7, bg-color-light: #ECF5FD, bg-color-verifycode: #cfcfcf, &#x2F;&#x2F; Border Color borer-color-primary: #e64644, borer-color-primary-light: #dc2b34, borer-color-white: #ffffff, borer-color-default: #CCCCCC, &#x2F;&#x2F; Link Color link-color-primary: #d91721, link-color-primary-light: #b51d29, link-color: #6190E8, link-color-light: #79A1EB, link-color-disabled: #BFBFBF, &#x2F;&#x2F; Icon Color icon-color-base: #CCC, ),); 上面只需要切换data-theme的名字就行了，一共内置了两套主题。 编译过后的css 1234567@charset &quot;UTF-8&quot;;.app-home &#123; font-size: 18px; &#125; body[data-theme&#x3D;default] .app-home &#123; color: #dc2b34; &#125; body[data-theme&#x3D;light] .app-home &#123; color: #78A4FA; &#125; 可以看出就是做了两套兼容而已。","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"随机概率分析","date":"2020-05-13T21:46:24.000Z","path":"2020/05/13/原创/随机概率分析/","text":"Math.random()Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值 数学表达式：[0,1)左闭右开区间 因此我们将倍率调整到10的话： Math.random()*10--&gt;[0,10) parseInt(Math.random()*10)分析: 区间 取整 [0,1) 0 [1,2) 1 [2,3) 2 [3,4) 3 [4,5) 4 [5,6) 5 [6,7) 6 [7,8) 7 [8,9) 8 [9,10) 9 总结可得：1-10每个数的概率差不多是1/10.大致时一样的。那么我们将倍率调整至100并封装起来试一试。 12345678910111213141516171819202122232425&#x2F;** * 返回概率之内的数字 * @param to 0-to为可随机的数字 * @param total 总数，to-total为不能随机的数字 * @returns &#123;number&#125; 0：随机到概率之外的数字，num:概率之内的数字 *&#x2F;function randomInt(to,total) &#123; if (arguments.length!&#x3D;2||typeof to !&#x3D; &#39;number&#39;||typeof total !&#x3D; &#39;number&#39;)&#123; return 0; &#125; &#x2F;&#x2F;to给total扩容 var total&#x3D;total||100; if (to&gt;total)&#123; total&#x3D;to; &#125; var num&#x3D;parseInt(Math.random() * total)+1; if (num&gt;to)&#123; return 0; &#125;else &#123; return num; &#125;&#125;&#x2F;&#x2F;1&#x2F;10概率:&#x2F;&#x2F;randomInt(1,10)&#x2F;&#x2F;返回值:0:未隨機到，&gt;0:隨機成功 注意：该方法主要用来代替parseInt(Math.random()*10)&lt;1此类的表达式 再添加一个范围内随机，用法：[30,30,40]表示从100中随机取值，1的概率时30%,2的概率是30%,3的概率是40%,获得的是传入的概率值索引+1。 12345678910111213141516171819202122function randomRangeInt(args) &#123; if (!args||args.length&#x3D;&#x3D;0)&#123; return 0; &#125; var sum&#x3D;0; for (var i &#x3D; 0; i &lt; args.length; i++) &#123; sum+&#x3D;args[i]; &#125; var total&#x3D;sum; var length&#x3D;args.length; var num&#x3D;parseInt(Math.random() * total)+1; var index&#x3D;0; var sum_2&#x3D;0; for (var i &#x3D; 0; i &lt; length; i++) &#123; sum_2+&#x3D;args[i]; if (num&lt;&#x3D;sum_2)&#123; index&#x3D;i+1; break; &#125; &#125; return index;&#125; 扩展文章 https://fed.taobao.org/blog/taofed/do71ct/some-thing-about-random/?spm=taofed.homepage.header.7.7eab5ac81EtpFe","tags":[],"categories":[{"name":"原创","slug":"原创","permalink":"https://xieyaxin.top/categories/%E5%8E%9F%E5%88%9B/"}]},{"title":"rem响应式原理","date":"2020-05-13T17:44:24.000Z","path":"2020/05/13/知识/前端/rem响应式原理/","text":"参考文章 https://blog.csdn.net/qq_36263601/article/details/78366710 https://segmentfault.com/a/1190000007526917 https://github.com/amfe/lib-flexible","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"知识/前端","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/"}]},{"title":"细说同域","date":"2020-05-13T17:44:24.000Z","path":"2020/05/13/知识/前端/同源与跨域/细说同域/","text":"一、域名级别 域名级别是网址分类的一个标准，包括顶级域名、二级域名等。一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号”.”来分隔，倒数第一个”.”的右边部分称为顶级域名（TLD，也称为一级域名，包含一个合法字符串和一个域名后缀），顶级域名的左边部分字符串到下个”.”为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。 二、域名组成 域名组成方式是由一下域名级别类型构成的 顶级域名 二级域名 三级域名 国家代码域名 顶级域名：分为两类： 一是国家顶级域名（nationaltop-leveldomainnames，简称nTLDs），目前200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，美国是us，日本是jp等；二是国际顶级域名（internationaltop-leveldomainnames，简称iTDs），例如表示工商企业的.com，表示网络提供商的.net，表示非盈利组织的.org等。目前大多数域名争议都发生在com的顶级域名下，因为多数公司上网的目的都是为了赢利。为加强域名管理，解决域名资源的紧张，Internet协会、Internet分址机构及世界知识产权组织（WIPO）等国际组织经过广泛协商，在原来三个国际通用顶级域名：（com）的基础上，新增加了7个国际通用顶级域名：firm（公司企业）、store（销售公司或企业）、Web（突出WWW活动的单位）、arts（突出文化、娱乐活动的单位）、rec(突出消遣、娱乐活动的单位）、info(提供信息服务的单位）、nom(个人），并在世界范围内选择新的注册机构来受理域名注册申请。 二级域名：是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如com，edu，gov，net等。 中国在国际互联网络信息中心（InterNIC）正式注册并运行的顶级域名是cn，这也是中国的一级域名。在顶级域名之下，中国的二级域名又分为类别域名和行政区域名两类。类别域名共6个，包括用于科研机构的ac；用于工商金融企业的com；用于教育机构的edu；用于政府部门的gov；用于互联网络信息中心和运行中心的net；用于非盈利组织的org。而行政区域名有34个，分别对应于中国各省、自治区和直辖市。 三级域名：用字母（A～Z，a～z，大小写等）、数字（0～9）和连接符（－）组成，各级域名之间用实点（.）连接，三级域名的长度不能超过20个字符。如无特殊原因，建议采用申请人的英文名（或者缩写）或者汉语拼音名（或者缩写）作为三级域名，以保持域名的清晰性和简洁性。 国家代码：由两个字母组成的顶级域名如.cn,.uk,.de和.jp称为国家代码顶级域名（ccTLDs),其中.cn是中国专用的顶级域名，其注册归CNNIC管理，以.cn结尾的二级域名我们简称为国内域名。注册国家代码顶级域名下的二级域名的规则和政策与不同的国家的政策有关。您在注册时应咨询域名注册机构，问清相关的注册条件及与注册相关的条款。某些域名注册商除了提供以.com,.net和.org结尾的域名的注册服务之外，还提供国家代码顶级域名的注册。ICANN并没有特别授权注册商提供国家代码顶级域名的注册服务。 三、同域-同父域-跨域区分 同域：即同源，所谓同源，指的是协议、域名、端口号都必须完全相同。这里同源既是同域。 同父域：即存在父域相同。例如，Http：www.baidu.com/ 与Http：ww.baidu.com/ 就是同父域。 跨域：所谓跨域，就是不同源（IP地址相同，但域名不同也是跨域）。那这里的同父域你就懂得了？ 原文链接： https://www.cnblogs.com/julygift/p/8535825.html","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"知识/前端","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/"},{"name":"同源与跨域","slug":"知识/前端/同源与跨域","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"}]},{"title":"低版本vue打包之后一片空白","date":"2020-05-13T16:11:18.000Z","path":"2020/05/13/疑难杂症/vue/低版本vue打包之后一片空白/","text":"https://blog.csdn.net/dq674362263/article/details/81876445","tags":[],"categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"vue","slug":"疑难杂症/vue","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/vue/"}]},{"title":"作用域是什么","date":"2020-05-12T22:24:16.000Z","path":"2020/05/12/随想/作用域是什么 /","text":"","tags":[],"categories":[{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"}]},{"title":"网页棋牌游戏的注意事项","date":"2020-05-12T12:00:03.000Z","path":"2020/05/12/随想/网页棋牌游戏的注意事项/","text":"后台&gt;前台注意，最简单的办法就是先把界面全部清除，在获取重连数据，根据数据进行界面的重新绘制。清除包括界面一切元素，定时器，动画效果.","tags":[],"categories":[{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"}]},{"title":"增量时间（deltaTime）","date":"2020-05-11T17:35:53.000Z","path":"2020/05/11/知识/cocos/增量时间（deltaTime）/","text":"作者：EickL链接：https://www.jianshu.com/p/a628d1e8a8c5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 描述增量时间是根据上一帧更新游戏以来经过的时间，用于动态的更新游戏场景渲染。 基于时间的动画在早期游戏开发中，一些游戏的场景移动速度依赖于CPU的运行速度，游戏场景将每帧在屏幕上移动一定数量的像素。如果CPU只能以每秒15帧（FPS）运行游戏，并且游戏场景被代码定义为每秒向左移动10个像素，则游戏场景将以每秒150个像素向左移动。但是，如果性能更好的处理器可以每秒60帧运行游戏呢？游戏场景将以600像素移动！怎么能解决这个问题呢？ 解决这个问题的关键是记录自上一帧以来经过的时间。这个时间通常叫做增量时间（deltaTime）。只要我们拿到了增量时间，我们就可以通过使用下面的公式计算出我们的游戏场景应该移动此帧的距离： 123const distance &#x3D; speed * deltaTime &#x2F;&#x2F; 表示一帧移动的距离为speed * deltaTime&#x2F;&#x2F; 当两个游戏的cpu不同的时候，处理快的deltaTime就小，处理慢的deltaTime就大，主要是为了能够让在不同的处理速度小移动的距离一样。 以上三个变量： distance：移动当前帧的像素数 speed：每秒像素的速度 deltaTime：上一帧以来经过的时间 示例： 123456789101112131415161718192021222324const APP.core &#x3D; &#123; frame() &#123; APP.core.setDelta() APP.core.update() APP.core.render() APP.core.animationFrame &#x3D; window.requestAnimationFrame(APP.core.frame) &#125;, setDelta() &#123; APP.core.now &#x3D; Date.now() APP.core.delta &#x3D; (APP.core.now - APP.core.lastTime ) &#x2F; 1000 &#x2F;&#x2F; 上一帧以来经过的秒数 APP.core.lastTime &#x3D; APP.core.now &#125;, update() &#123; &#x2F;&#x2F; 更新值 &#x2F;&#x2F; var distance &#x3D; 100 * APP.core.delta &#x2F;&#x2F; APP.thing.x +&#x3D; distance &#125;, render() &#123; &#x2F;&#x2F; 渲染更新 &#125;&#125;","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"cocos","slug":"知识/cocos","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/cocos/"}]},{"title":"贝塞尔曲线","date":"2020-05-11T14:52:18.000Z","path":"2020/05/11/知识/贝塞尔曲线/","text":"作者：骑小猪看流星链接：https://www.jianshu.com/p/0c9b4b681724来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 贝赛尔曲线的前世今生：贝塞尔曲线，这个命名规则一眼看上去大概是一个叫贝塞尔的数学家发明的。但，贝塞尔曲线依据的最原始的数学公式，是在1912年在数学界广为人知的伯恩斯坦多项式。 简单理解，伯恩斯坦多项式可以用来证明，在[ a, b ] 区间上所有的连续函数都可以用多项式来逼近，并且收敛性很强，也就是一致收敛。再简单点，就是一个连续函数，你可以将它写成若干个伯恩斯坦多项式相加的形式，并且，随着 n→∞，这个多项式将一致收敛到原函数，这个就是伯恩斯坦斯的逼近性质。 时光荏苒岁月如梭，镜头切换到了1959年。当时就职于雪铁龙的法国数学家 Paul de Casteljau 开始对伯恩斯坦多项式进行了图形化的尝试，并且提供了一种数值稳定的德卡斯特里奥（de Casteljau） 算法。（多数理论公式是建立在大量且系统的数学建模基础之上研究的规律性成果）根据这个算法，就可以实现 通过很少的控制点，去生成复杂的平滑曲线，也就是贝塞尔曲线。 但贝塞尔曲线的声名大噪，不得不提到1962年就职于雷诺的法国工程师皮埃尔·贝塞尔（Pierre Bézier），他使用这种方法来辅助汽车的车体工业设计（最早计算机的诞生则是为了帮助美国海军绘制弹道图），并且广泛宣传（典型的理论联系实际并获得成功的示例），因此大家称为贝塞尔曲线 。 贝赛尔曲线的数学理论：既然贝赛尔曲线的本质是通过数学计算公式去绘制平滑的曲线，那就可以通过数学工具进行实际求证以及解释说明。当然对其进行数学求证就没必要了，因为这些伟大的数学家们已经做过了，这里只是解释说明： 步骤一：在平面内选3个不同线的点并且依次用线段连接。如下所示.. 步骤二：在AB和BC线段上找出点D和点E，使得 AD/AB = BE/BC 步骤三：连接DE，在DE上寻找点F，F点需要满足：DF/DE = AD/AB = BE/BC 步骤四：最最重要的！根据DE线段和计算公式找出所有的F点，记住是所有的F点，然后将其这些点连接起来。那，连接规则是什么？以上图为例，第一个连接点是A-F，第二连接点是A-F1（这个F1必须满足DF1/DE = AD/AB = BE/BC）以此类推，直到最后连接上C点，下面上一个动图加深理解：","tags":[],"categories":[{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"}]},{"title":"一镜到底","date":"2020-05-09T11:40:26.000Z","path":"2020/05/09/前端/实战/一镜到底/","text":"","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"实战","slug":"前端/实战","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E6%88%98/"}]},{"title":"网址","date":"2020-05-07T13:56:30.000Z","path":"2020/05/07/收集/网址/","text":"前端jQuery中文文档 CSS参考手册 Vue生态链官网，vuex(状态管理)，vuerouter(路由管理) 个人旗下网站Wiki， SCSS官网 Less官网 stylus官网 模板引擎pug, ejs 图表echarts ,D3, highcharts, chartjs ，zrender 扩展文章 https://www.zhihu.com/question/28687373","tags":[],"categories":[{"name":"收集","slug":"收集","permalink":"https://xieyaxin.top/categories/%E6%94%B6%E9%9B%86/"}]},{"title":"Widget","date":"2020-05-06T17:16:15.000Z","path":"2020/05/06/cocos/Widget/","text":"https://docs.cocos.com/creator/api/zh/classes/Widget.html#updatealignment updateAlignment立刻执行 widget 对齐操作。这个接口一般不需要手工调用。 只有当你需要在当前帧结束前获得 widget 对齐后的最新结果时才需要手动调用这个方法。 示例1234widget.top = 10; // change top margincc.log(widget.node.y); // not yet changedwidget.updateAlignment();cc.log(widget.node.y); // changed 可能会遇见的问题 https://blog.csdn.net/u013654125/article/details/83379765","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"苹果录像有关hevc格式视频的网页播放","date":"2020-05-01T11:36:15.000Z","path":"2020/05/01/前端/业务相关/苹果录像有关hevc格式视频的网页播放/","text":"相关链接格式可以使用window上的potplayer播放，右键看属性 http://get.ftqq.com/9132.get https://blog.csdn.net/keji_123/article/details/77717849?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1 https://zhuanlan.zhihu.com/p/50655841 https://tieba.baidu.com/p/5882990363?red_tag=1551058192 改成兼容性最佳可以直接播放","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"业务相关","slug":"前端/业务相关","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/"}]},{"title":"代码笔记本推荐","date":"2020-04-29T23:24:21.000Z","path":"2020/04/29/工具/代码笔记本推荐/","text":"Cacher其实GitHub上是有提供代码片段管理功能的, 名字叫gistCacher是它的一个桌面版Interface, 分为免费版, 个人专业版和协作版 官网地址: https://www.cacher.io/ LeptonGitHub地址: https://github.com/hackjutsu/Lepton Snippet Store官网地址: https://zerox-dg.github.io/SnippetStoreWeb/GitHub地址: https://github.com/ZeroX-DG/SnippetStore VNote官网地址: https://tamlok.github.io/vnote/en_us/#!index.mdGitHub地址: https://github.com/tamlok/vnote https://boostnote.io/","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"vue响应式原理","date":"2020-04-29T09:31:00.000Z","path":"2020/04/29/vue/vue/vue响应式原理/","text":"观察器 主要是对值变化的观察，针对该值对象的元素能够监听到其设置值与获取值才行。 1234567891011121314151617181920212223242526272829303132333435363738394041class Observer &#123; constructor(data) &#123; &#x2F;&#x2F; 如果传入的值不是对象或者不存在，就直接退出 if (!data || typeof data !&#x3D; &#39;object&#39;) &#123; return; &#125; &#x2F;&#x2F; 绑定单一的值 this.data &#x3D; data; &#x2F;&#x2F; 遍历所有可遍历属性 this.walk(); &#125; walk() &#123; for (const key in this.data) &#123; &#x2F;&#x2F; 对每一个元素进行可监测处理 this.defineReactive(this.data, key, this.data[key]); &#125; &#125; defineReactive(obj, key, val) &#123; &#x2F;&#x2F; 如果传入的又是一个对象，那么需要对其子元素继续进行监测处理 new Observer(val); &#x2F;&#x2F; 定义可监测代码的主要函数 Object.defineProperty(obj, key, &#123; get() &#123; &#x2F;&#x2F; 针对值获取的拦截处理，如console.log(obj.a) console.log(&#39;1&#39;); return val; &#125;, set(newVaule) &#123; &#x2F;&#x2F; 针对赋值的拦截处理，如obj.a &#x3D; 100 if (val &#x3D;&#x3D;&#x3D; newVaule) &#123; return; &#125; console.log(&#39;2&#39;); val &#x3D; newVaule; &#x2F;&#x2F; 对新改变的值继续进行可监测处理 new Observer(newVaule); &#125; &#125;) &#125;&#125; 使用方法： 1234567891011121314let data &#x3D; &#123; name: &quot; cjg&quot;, obj: &#123; name: &quot;zht&quot; &#125;&#125;let ob &#x3D; new Observer(data);ob.defineReactive(data,&#39;aa&#39;,5)data.aa&#x3D;4data.aa&#x2F;&#x2F;---&gt;&#x2F;&#x2F;2 &#x2F;&#x2F; 先是赋值&#x2F;&#x2F;1 &#x2F;&#x2F; 然后值获取 依赖收集12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F; 观察器*** defineReactive(obj, key, val) &#123; const dep &#x3D; new Dep(); &#x2F;&#x2F; 每一个值定义一个依赖管理 new Observer(val); Object.defineProperty(obj, key, &#123; get() &#123; console.log(&#39;1&#39;); if (Dep.target) &#123; &#x2F;&#x2F; 如果管理器绑定了一个监听器，那么就将可监测值推入管理队列中 dep.addSub(Dep.target); &#x2F;&#x2F; 推入操作 &#125; return val; &#125;, set(newVaule) &#123; if (val &#x3D;&#x3D;&#x3D; newVaule) &#123; return; &#125; val &#x3D; newVaule; new Observer(newVaule); dep.notify(); &#x2F;&#x2F; 依赖刷新 &#125; &#125;) &#125;***&#x2F;&#x2F; 依赖管理器class Dep &#123; constructor() &#123; this.subs &#x3D; []; &#125; addSub(sub) &#123; if (this.subs.indexOf(sub) &lt; 0) &#123; this.subs.push(sub); &#125; &#125; notify() &#123; this.subs.forEach((sub) &#x3D;&gt; &#123; sub.update(); &#125;) &#125;&#125;&#x2F;&#x2F; 用户绑定WatcherDep.target &#x3D; null; 监听器123456789101112131415161718192021222324252627282930313233343536373839class Watcher &#123; &#x2F;&#x2F; vm: 响应式对象 &#x2F;&#x2F; keys: 响应式对象的属性 &#x2F;&#x2F; updateCb: 数值更新时的回调 constructor(vm, keys, updateCb) &#123; this.vm &#x3D; vm; this.keys &#x3D; keys; this.updateCb &#x3D; updateCb; this.value &#x3D; null; this.get(); &#125; &#x2F;&#x2F; 监听器绑定 get() &#123; &#x2F;&#x2F; 依赖管理器设置该监听器 Dep.target &#x3D; this; &#x2F;&#x2F; 对属性的拆分，例如obj.a.a const keys &#x3D; this.keys.split(&#39;.&#39;); &#x2F;&#x2F; 获取响应式对象 let value &#x3D; this.vm; &#x2F;&#x2F; 对属性进行值的获取，直到最终值 keys.forEach(_key &#x3D;&gt; &#123; &#x2F;&#x2F; 这里由于value[_key]获取了值，会执行上面监听器中defineProperty的get属性函数,这样get函数中的依赖收集变会启动并收集该属性. value &#x3D; value[_key]; &#125;) &#x2F;&#x2F; 旧值的临时存储 this.value &#x3D; value; &#x2F;&#x2F; 因为上边依赖已经收集完毕,所有可以去掉了,方便下一个响应式对象的设置 Dep.target &#x3D; null; return this.value; &#125; update() &#123; &#x2F;&#x2F; 依赖更新,值在被更新的时候执行的函数 const oldValue &#x3D; this.value; const newValue &#x3D; this.get(); &#x2F;&#x2F;获取最新值 if (oldValue !&#x3D; newValue) &#123; this.updateCb(oldValue, newValue); &#125; &#125;&#125;","tags":[],"categories":[{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"}]},{"title":"commander使用方法","date":"2020-04-27T09:44:53.000Z","path":"2020/04/27/npm/commander使用方法/","text":"npm commander 初步使用安装 1npm i commander --save-dev Hello World main.js 1234567891011121314151617#!&#x2F;usr&#x2F;bin&#x2F;env nodeconst &#123; Command &#125; &#x3D; require(&#39;commander&#39;);const program &#x3D; new Command();program .version(&#39;0.1.0&#39;) .command(&#39;rmdir &lt;dir&gt; [otherDirs...]&#39;) .action(function (dir, otherDirs) &#123; console.log(&#39;rmdir %s&#39;, dir); if (otherDirs) &#123; otherDirs.forEach(function (oDir) &#123; console.log(&#39;rmdir %s&#39;, oDir); &#125;); &#125; &#125;);program.parse(process.argv); 可执行文件 在package.json中添加以下字段，确保dist/main.js是一个可执行文件 1234567&#123; *** &quot;bin&quot;: &#123; &quot;gamecli&quot;: &quot;dist&#x2F;main.js&quot; &#125;, ***&#125; 在项目的根路径下执行：npm link,会自动添加可执行文件,等待完成之后，执行gamecli -V就能看到效果了。","tags":[],"categories":[{"name":"npm","slug":"npm","permalink":"https://xieyaxin.top/categories/npm/"}]},{"title":"docker启蒙","date":"2020-04-26T21:41:29.000Z","path":"2020/04/26/docker/docker启蒙/","text":"Hello worldDocker允许你在容器内运行应用程序，使用docker run命令在容器中运行一个应用程序。如下：将会输出一个Hello world。 12$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;$ Hello world docker`: Docker的二进制执行文件 run：与前面的docker组合来运行一个容器 ubuntu:15.10 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker就会从镜像仓库DockerHub下载公共镜像。 /bin/echo &quot;Hello world&quot;：在启动的容器中执行的命令 以上的代码大概意思是：Docker以ubuntu15.10镜像创建一个新容器，然后再容器里执行/bin/echo &quot;Hello world&quot;,输出结果 运行交互式容器有时我们需要自己进入容器的命令行来执行一些操作，这种情况显然是可以的。 1docker -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash 这样的话，就会进入容器ubuntu:15.10内的命令行。 -t:再新容器中指定一个伪终端或终端 -i:允许你在容器内的标77bd8交互 当出现类似于root@0123ce188bd8:/#,表示我们已经进入一个``ubuntu15.10系统的容器了，我们可以运行下ls`查看当前目录的文件。 退出在可交互式容器中输入exit,或者Ctrl+D来退出容器。 以进程方式启动容器使用以下命令创建一个进程式容器： 12$ docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello world;sleep 1;done&quot;一长串的字符 上面一长串的字符叫做容器ID，对于容器来说，这是唯一的。我们可以通过容器ID来查看容器发生了什么。当然，我们需要确认是否有容器在运行：docker ps 如果，我们可以看到有一个容器。 字段 描述 CONTAINER ID 容器ID IMAGE 使用的镜像 COMMAND 启动容器时运行的命令 STATUS 容器状态(7种)create(已创建) restarting(重启中) running(运行中)removing(迁移种) paused(暂停) exited(停止) dead(死亡) PORT 容器的端口细腻些和使用的链接类型（tcp\\udp） NAME 启动分配的容器名称 为了查看宿主主机内的输出，我们可以运行docker logs ***，后面表示ID或者容器名称 停止容器123docker ps # 查看容器的信息docker stop *** # 后面接ID或者容器名称docker ps # 看到容器已经不在了","tags":[],"categories":[{"name":"docker","slug":"docker","permalink":"https://xieyaxin.top/categories/docker/"}]},{"title":"vue-cli3跨域代理配置","date":"2020-04-25T14:08:22.000Z","path":"2020/04/25/vue/vue/vue-cli3跨域代理配置/","text":"配置只能作用于本地，开发模式下，axios请不要设置默认服务器网址，这个在vue.config.js中设置。 vue.config.js: 123456789101112131415161718module.exports &#x3D; &#123; *** devServer: &#123; port: port, &#x2F;&#x2F; 本地服务的端口 open: true, &#x2F;&#x2F; 启动之后是否自动打开浏览器 proxy: &#123; &#39;&#x2F;member&#39;: &#123; &#x2F;&#x2F;配置&#96;&#x2F;member&#96;开头的网址 target: &#39;http:&#x2F;&#x2F;0000000:9002&#39;, &#x2F;&#x2F;请替换成你自己的服务器地址 ws: false, &#x2F;&#x2F; 是否代理websockets changeOrigin: true, &#x2F;&#x2F; 默认是false：请求头中host仍然是浏览器发送过来的host pathRewrite: &#123; &#x2F;&#x2F; &#39;^&#x2F;member&#39;: &#39;&#39; &#x2F;&#x2F; 重写路径，这个的意思是去掉了&#x2F;member &#125; &#125; &#125; &#125; ***&#125;","tags":[],"categories":[{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"}]},{"title":"vue+iframe通信于判断是否被引用","date":"2020-04-25T11:58:02.000Z","path":"2020/04/25/vue/vue/vue+ifram通信于判断是否被引用/","text":"父页面1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;style&gt; #framePage&#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; &#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;script&gt; window.onload &#x3D; function() &#123; var frame &#x3D; document.getElementById(&#39;framePage&#39;); &#x2F;&#x2F; 发送消息 frame.contentWindow.postMessage(&#123;hide:true&#125;,&#39;*&#39;); &#125; &lt;&#x2F;script&gt; &lt;iframe id&#x3D;&quot;framePage&quot; src&#x3D;&quot;http:&#x2F;&#x2F;localhost:9528&#x2F;#&#x2F;dashboard&quot; frameborder&#x3D;&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 子页面我用的vue，因此用vue做示例，我的写在了main.js里： 123456789window.addEventListener(&#39;message&#39;, function(event) &#123; if (event.data.hide) &#123; store.state.isHideAll &#x3D; true &#125;&#125;, false)&#x2F;&#x2F;判断是不是被iframe引用了if (window.self !&#x3D;&#x3D; window.top) &#123; store.state.isHideAll &#x3D; true&#125; 这样就被store管理了，在vue里也能够实时更新","tags":[],"categories":[{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"}]},{"title":"node后端解决跨域","date":"2020-04-25T10:53:16.000Z","path":"2020/04/25/跨域/node后端解决跨域/","text":"注意这个Access-Control-Allow-Headers,当然也可以设置为* 1234567891011121314151617181920212223const express &#x3D; require(&#39;express&#39;);const app&#x3D; express();&#x2F;&#x2F;设置允许跨域访问该服务.app.all(&#39;*&#39;, function (req, res, next) &#123; res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);&#x2F;&#x2F; Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type,token&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;); res.header(&#39;Content-Type&#39;, &#39;application&#x2F;json;charset&#x3D;utf-8&#39;); next();&#125;);&#x2F;&#x2F;这里虽说省略也可以，但是改成404就不行，因为会自动返回200app.options(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123; res.sendStatus(200);&#125;);app.post(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123; res.send(&#123;aa:123&#125;);&#125;);app.listen(8083, ()&#x3D;&gt;&#123; console.log(&#39;Server is running at http:&#x2F;&#x2F;localhost:8083&#39;)&#125;) 后端针对跨域的两个条件： options请求返回200 （复杂请求会有预检请求） 响应携带允许跨域的请求头 123Access-Control-Allow-OriginAccess-Control-Allow-HeadersAccess-Control-Allow-Methods","tags":[],"categories":[{"name":"跨域","slug":"跨域","permalink":"https://xieyaxin.top/categories/%E8%B7%A8%E5%9F%9F/"}]},{"title":"git-rebase详解","date":"2020-04-24T17:09:42.000Z","path":"2020/04/24/git/git-rebase详解/","text":"https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase Rebase 代替合并虽然合并（merge）操作可以用来简单和方便地整合改动，但是它却不是唯一的方法。“Rebase” 就是另一种替代手段。 注释虽然 rebase 相对于我们已知的整合操作来说有着比较显著的优点，但是这也是在很大程度上取决于个人的喜好。一些团队喜欢使用 rebase，而另一些可能倾向于使用合并。 Rebase 相对于合并来说是比较复杂的。我建议你可以跳过这一章，除非你和你的团队确定会用到 rebase 操作。当你积累了 Git 的一些基本使用流程的实践经验后，你也可以在以后的时间再回来学习本章的内容。 深入了解合并操作在你进入rebase 这个主题前，我们有必要来再次探讨一下更多关于合并操作的细节。当 Git 执行一个合并时，它实际上会查找三个提交： (1)共同的原始提交如果你在项目中查看两个分支的历史，它们总是会出自于一次共同的提交，那么在当时的时间点上，这两个分支还是拥有相同的内容。之后它们就开始有了差别。 (2) + (3) 两个分支的最终点合并操作的目的就是把两个分支的最新状态结合起来。因此他们各自的最新版本是有特殊含义的。 结合这三个提交后得到的结果就是我们整合的目标。 快进或合并提交一种最简单的情况是，在其中的一个分支上没有任何一个新的改动提交发生。那么在它之前的最后一次提交就仍然还是那个共同的原始提交。 在这种情况下，执行整合操作就非常简单了。 Git 仅仅需要添加所有那些在另外一个分支上的新提交就可以了。在 Git 中，这种最简单的整合操作我们称之为 “快进（fast-forward）”合并。之后两个分支就拥有了完全相同的历史。 但是在大多数情况下，两个分支都会有自己不同的发展轨迹。 为了完成整合，Git 会需要创建一个新的提交来含括它们之间的差异，这就是整合提交（merge commit）。 手工提交与合并提交通常情况下，提交都是由手工精心创建的。这样也就能更好地保证一次提交只涉及一个关联改动，并且能更好地注释这个提交。 一个合并提交就不同了，它不是由开发人员手动创建的，而是由 Git 自动生成的。它也不涉及一个关联改动，其目的只是连接两个分支，就像节点一样。如果之后想要了解某个合并操作，你只需要查看这两个分支的历史记录和它们相应的提交树（version tree）。 Rebase 整合有些人并不喜欢使用这种自动合并提交。相反，他们希望项目拥有一个单一的历史发展轨迹。比如一条直线。在历史纪录上没有迹象表明在某些时间它被分成过多个分支。 现在就让我们一步一步地了解一下 rebase 操作吧！仍然来使用前面的例子：我们想合并分支 B 到 分支 A 中，但是这次使用 rebase 操作。 使用下面这个非常的简单的命令： 1$ git rebase branch-B 首先，Git 会 “撤销” 所有在分支 A 上的那些在与分支 B 的共同提交之后发生的提交。当然，Git 不会真的放弃这些提交，其实你可以把这些撤销的提交想像成 “被暂时地存储” 到另外的一个地方去了。 接下来它会整合那些在分支 B（这个我们想要整合的分支）上的还未整合的提交到分支 A 中。在这个时间点，这两个分支看起来会是一模一样的。 最后，那些在分支 A 的新的提交（也就是第一步中自动撤销掉的那些提交）会被重新应用到这个分支上，但是在不同的位置上，在那些从分支 B 被整合过来的提交之后，它们就被 re-based 了。整个项目开发轨迹看起来就像发生在一条直线上。相对于一个合并提交，rebase 包括了所有的组合变化，最原始的提交结构会被保留下来。 Rebase 存在的陷阱当然，使用 rebase 操作不会是永远一帆风顺的。很有可能会搬起石头砸自己的脚，因此你不能忽视一个重要的事实：rebase 会改写历史记录。 你有可能已经注意到了，在被 rebase 操作之后的版本中，提交 “C3*” 存在一个新添加的星号。这是因为，尽管这个提交的内容和 “C3” 完全一样，但是它实际上是一个不同的提交。这样做的原因是，它现在有一个新的源提交 C4（在最初创建 C3 时的源提交是 C1）。 一个提交仅仅包括很少的属性，比如作者，日期，变动和谁是它的父提交。如果改变其中任何一个信息，就必须创建一个全新的提交。当然，新的提交也会拥有一个新的 hash ID 。 如果还仅仅只是操作那些尚未发布的提交，重写历史记录本身也没有什么很大的问题。但是如果你重写了已经发布到公共服务器上的提交历史，这样做就非常危险了。其他的开发人员可能这时已经在最原始的提交 C3 上开始工作，并使它成为了一些新提交中不可或缺的部分，而现在你却把 C3 的改动设置到了另一个时间点（就是那个新的 C3*）。除此之外，通过rebase 操作，这个原始的 C3 还被删除掉了，这将是非常可怕的…… 因此你应该只使用 rebase 来清理你的本地工作，千万不要尝试着对那些已经被发布的提交进行这个操作。","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"ts使用paths配置路径别名","date":"2020-04-24T10:45:41.000Z","path":"2020/04/24/ts/ts使用paths配置路径别名/","text":"123456789101112131415161718&#123; &quot;compilerOptions&quot;: &#123; *** &#x2F;&#x2F; 配置基础路径 &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &#x2F;&#x2F; &#39;@&#x2F;*&#39; 表示中的@表示路径别名，*代表匹配所有声明的所有路径 &#x2F;&#x2F; &#39;.&#x2F;app&#x2F;*&#39; 表示在baseUrl的相对目录下的app的所有文件都在paths的范围内 &quot;@&#x2F;*&quot;: [&quot;.&#x2F;app&#x2F;*&quot;] &#125; *** &#125;, &quot;exclude&quot;: [ &quot;app&#x2F;public&quot;, &quot;app&#x2F;views&quot;, &quot;node_modules*&quot; ]&#125; webstrom的一些配置： 不一定要一样，只是我这样是可以用的。 那个Recompile on changes不推荐钩选，不然会把你的所有ts文件的同级目录下编译出一个js文件","tags":[],"categories":[{"name":"ts","slug":"ts","permalink":"https://xieyaxin.top/categories/ts/"}]},{"title":"frp内网穿透","date":"2020-04-23T13:32:36.000Z","path":"2020/04/23/工具/frp内网穿透/","text":"frp国人开发的免费开源工具 准备 公网服务器 IP 140.140.192.192 域名 www.good.com 解析至上面的服务器 本地运行的服务 效果利用frp，可以实现任何人都可以通过配置的端口如 www.good.com:7001 访问我本机的hbuilder网页应用 方法服务器和内网本机分别下载对应系统平台的frp，这里ubuntu服务器需要下载linux_arm_64， mac本机是frp_0.32.1_windows_amd64.zip 先配服务端 linux_arm_64文件包在服务器上下载解压，编辑 frps.ini， 然后启动 ./frps -c ./frps.ini，放后台启动命令 nohup ./frps -c ./frps.ini &amp;，配置修改如下 1234[common]bind_port = 7000# 客户端定义的端口vhost_http_port = 7001 配置客户端 frp_0.32.1_windows_amd64.zip文件包解压，编辑 frpc.ini,然后启动 ./frpc -c ./frpsc.ini,可以自己放在后台执行，配置如下： 123456789[common]server_addr = 140.140.192.192 #公网服务器ipserver_port = 7001 #与服务端bind_port一致 #公网访问内部web服务器以http方式[web]type = http #访问协议local_port = 4200 #内网web服务的端口号custom_domains = www.good.com #所绑定的公网服务器域名，一级、二级域名都可以 配置服务端面板修改服务端的 frps.ini， 添加 dashboard 信息，重启启动后可以通过140.140.192.192:7500打开控制面板 123456789[common]bind_port = 7000# 客户端定义的端口vhost_http_port = 7001dashboard_port = 7500# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin 注意 Invalid Host header 如果本机的web项目用了webpack server(目前vue cli, react cli, angular 本地开发用的都是这个) , 这个是webpack server的安全策略，如果是angular项目，需要在启动配置中加上 --disable-host-check 类似 ng serve --open --host $IP --port $PORT --disable-host-check。 如果是uniapp项目，进行如下配置： 参考文档 https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81 https://www.jianshu.com/p/d579c2156311 https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/ https://www.it72.com/12580-1.htm","tags":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"3D前置知识","date":"2020-04-23T09:33:29.000Z","path":"2020/04/23/3D/3D前置知识/","text":"1234561.场景(Scene)：是物体、光源等元素的容器，可以配合 chrome 插件使用，抛出 window.scene即可实时调整 obj 的信息和材质信息。2.相机（Camera）：场景中的相机，代替人眼去观察，场景中只能添加一个，一般常用的是透视相机（PerspectiveCamera）3.物体对象（Mesh）：包括二维物体（点、线、面）、三维物体，模型等等 4.光源（Light）：场景中的光照，如果不添加光照场景将会是一片漆黑，包括全局光、平行光、点光源等 5.渲染器（Renderer）:场景的渲染方式，如webGL\\canvas2D\\Css3D。 6.控制器(Control): 可通过键盘、鼠标控制相机的移动 相机Three.js中我们常用到的又两种类型的相机：正交相机，透视相机。一般情况下为了模拟人眼我们都是使用透视相机。 正交镜头的特点是：物品的渲染尺寸与距离镜头的远近无关。也就是说在场景中移动一个物体，其大小不会变化。正交镜头适合2D游戏。 透视镜头则是模拟人眼的视觉特点，距离远的物体显得更小。透视镜头通常更适合3D渲染。 PerspectiveCamera透视相机 参数 描述 fov 视野角度，从镜头可以看到的场景的部分。通常3D游戏的FOV取值在60-90度之间较好的默认值为60 aspect 渲染区域的纵横比。较好的默认值为window.innerWidth/window.innerHeight near 最近离镜头的距离 far 远离镜头的距离 透视相机示意图 创建摄像机以后还要对其进行移动、然后对准物体积聚的场景中心位置，分别是设置其 position和调用 lookAt 方法，参数均是一个 xyz向量(new THREE.Vector3(x,y,z)) 12camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)） 灯光在Three.js中光源是必须的，如果一个场景你不设置灯光那么世界将会是一片漆黑。Three.js内置了多种光源以满足特定场景的需要。大家可以根据自己的项目需要来选择何种灯光 光源分类 光源 说明 AmbientLight 环境光，其颜色均匀的应用到场景及其所有对象上,这种光源为场景添加全局的环境光。 这种光没有特定的方向，不会产生阴影。通常不会把AmbientLight作为唯一的光源， 而是和SpotLight、DirectionalLight等光源结合使用，从而达到柔化阴影、添加全局色调的效果。 指定颜色时要相对保守，例如#0c0c0c。设置太亮的颜色会导致整个画面过度饱和，什么都看不清： PointLight 3D空间中的一个点光源，向所有方向发出光线 SpotLight 产生圆锥形光柱的聚光灯，台灯、天花板射灯通常都属于这类光源,这种光源的使用场景最多 ，特别是在你需要阴影效果的时候。 DirectionalLight 也就无限光，光线是平行的。典型的例子是日光,用于模拟遥远的，类似太阳那样的光源。 该光源与SpotLight的主要区别是，它不会随着距离而变暗，所有被照耀的地方获得相同的光照强度。 HemisphereLight 特殊光源，用于创建户外自然的光线效果， 此光源模拟物体表面反光效果、微弱发光的天空,模拟穹顶（半球）的微弱发光效果， 让户外场景更加逼真。使用DirectionalLight + AmbientLight可以在某种程度上来模拟户外光线， 但是不够真实，因为无法体现大气层的散射效果、地面或物体的反射效果 AreaLight 面光源，指定一个发光的区域 LensFlare 不是光源，用于给光源添加镜头光晕效果 关于光源的详细 API 大家可以参考 threejs 官网，很详细，demo 也很完整 传送门 Mesh(网格)在计算机的世界中，一条弧线是由有限个点构成的有限条段链接得到的。当线段数量越多，长度就越短，当达到你无法察觉这是线段时，一条平滑的弧线就出现了。计算机三位模型也是类似的。只不过是线段变成了平面，普遍用三角形组成的网格来描述。我们把这种模型称之为Mesh模型。在ThreeJs的世界中，材质（Mterial）+几何体（Geomtry） 及时一个mesh。设置其name属性可以通过scene.getObjectByName(name)获取改物体对象。Geomtry就好像是故交，材质则类似于皮肤，对于材质和几何体的分类见下表格： 材质分类 材质 说明 MeshBasicMaterial 基本的材质，显示为简单的颜色或者显示为线框。不考虑光线的影响 MeshDepthMaterial 使用简单的颜色，但是颜色深度和距离相机的远近有关 MeshNormalMaterial 基于面Geometry的法线（normals）数组来给面着色 MeshFacematerial 容器，允许为Geometry的每一个面指定一个材质 MeshLambertMaterial 考虑光线的影响，哑光材质 MeshPhongMaterial 考虑光线的影响，光泽材质 ShaderMaterial 允许使用自己的着色器来控制顶点如何被放置、像素如何被着色 LineBasicMaterial 用于THREE.Line对象，创建彩色线条 LineDashMaterial 用于THREE.Line对象，创建虚线条 RawShaderMaterial 仅和THREE.BufferedGeometry联用，优化静态Geometry（顶点、面不变）的渲染 SpriteCanvasMaterial 在针对单独的点进行渲染时用到 SpriteMaterial 在针对单独的点进行渲染时用到 PointCloudMaterial 在针对单独的点进行渲染时用到","tags":[{"name":"3D","slug":"3D","permalink":"https://xieyaxin.top/tags/3D/"}],"categories":[{"name":"3D","slug":"3D","permalink":"https://xieyaxin.top/categories/3D/"}]},{"title":"leetcode算法题","date":"2020-04-22T14:01:15.000Z","path":"2020/04/22/leetcode/leetcode题/","text":"题目给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- &#x2F; \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 注：输入的不是数组，而是类似这种图形结构的： 12345&#123; &quot;val&quot;: 1, &quot;left&quot;: &#123;&quot;val&quot;: 2, &quot;left&quot;: null, &quot;right&quot;: &#123;&quot;val&quot;: 5, &quot;left&quot;: null, &quot;right&quot;: null&#125;&#125;, &quot;right&quot;: &#123;&quot;val&quot;: 3, &quot;left&quot;: null, &quot;right&quot;: &#123;&quot;val&quot;: 4, &quot;left&quot;: null, &quot;right&quot;: null&#125;&#125;&#125; 算法解析DFS(深度优先搜索算法) 1234567891011121314151617181920212223&#x2F;** * 定义一个节点树结构 * function TreeNode(val) &#123; * this.val &#x3D; val; * this.left &#x3D; this.right &#x3D; null; * &#125; *&#x2F;var rightSideView &#x3D; function(root) &#123; &#x2F;&#x2F; 传入的是空的话返回空数组 if(!root) return []; let result &#x3D; []; let run &#x3D; (tree,depth)&#x3D;&gt;&#123; if(!tree) return []; if (depth &#x3D;&#x3D; result.length)&#123; result.push(tree.val) &#125; depth +&#x3D; 1 run(tree.right,depth) run(tree.left,depth) &#125; run(root,0) return result&#125;; 对应知识点","tags":[],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xieyaxin.top/categories/leetcode/"}]},{"title":"node创建文件","date":"2020-04-22T11:03:17.000Z","path":"2020/04/22/node/node创建文件/","text":"NodeJS 10+ fs.mkdir已经增加递归选项 123fs.mkdir(&#39;&#x2F;tmp&#x2F;test&#x2F;www.inull.cn&#39;, &#123; recursive: true &#125;, (err) &#x3D;&gt; &#123; if (err) throw err;&#125;); NodeJS 9以前版本同步方案 12345678910111213141516171819var fs = require('path')var path = require('path')/** * 同步递归创建路径 * * @param &#123;string&#125; dir 处理的路径 * @param &#123;function&#125; cb 回调函数 */var $$mkdir = function(dir, cb) &#123; var pathinfo = path.parse(dir) if (!fs.existsSync(pathinfo.dir)) &#123; $$mkdir(pathinfo.dir,function() &#123; fs.mkdirSync(pathinfo.dir) &#125;) &#125; cb &amp;&amp; cb()&#125;$$mkdir(path.join(__dirname, 'demo/test/123/')) 异步方案 暂缓","tags":[],"categories":[{"name":"node","slug":"node","permalink":"https://xieyaxin.top/categories/node/"}]},{"title":"html5plus分享模板","date":"2020-04-21T15:27:38.000Z","path":"2020/04/21/uniapp/html5plus分享模板/","text":"微信公众号的分享链接在vue，hash模式下不要带/#/，会有问题","tags":[],"categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://xieyaxin.top/categories/uniapp/"}]},{"title":"git本地多账号配置","date":"2020-04-20T10:59:02.000Z","path":"2020/04/20/git/git本地多账号配置/","text":"前提条件 git环境 生成第一个账号的密钥先确保你已经有多个git账号（如：一个github的账号、一个码云的账号、…）。 在Git Bash Here的控制台里输入： git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; 这里的邮箱是你申请git账号时的邮箱，不报错就是正确的，继续往下走 输入 ssh-keygen -t rsa -C &quot;你的邮箱&quot; 回车，再连续3次回车见下图： 此时看下图中有一行提示：Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub 到该路径（C/Users/xxx/.ssh）可以看见两个文件：id_rsa、id_rsa.pub 。 把密钥添加进git账号中： 用编辑器打开id_rsa.pub，推荐使用Notepad++，不要使用记事本打开，因为记事本的默认编码不是utf-8，拷贝里面的全部内容，登录你其中一个git 账号，例如:我登录github平台，后添加公钥里把它添加进去，公钥名称可以随便写。提交保存，输入你的github登录密码并提示添加成功。 测试刚才添加的github密钥是否成功： 在Git Bash Here中输入 ssh git@github.com 回车 会出现一个提示，输入 yes 回车，可以看见一个successfully的提示信息，说明添加成功，可以使用了。 生成第二个账号的密钥重复上面的步骤，那用户名和邮箱改成另一个账号的 注：在输入ssh-keygen -t rsa -C &quot;你的邮箱&quot;的第一个选择存储路径的时候请自行改成自己的自定义名字，例如输入：smalldemons，这个时候一般是在C/Users/xxx/.ssh目录下就会又增加两个文件：smalldemons、smalldemons.pub,如果没看到的话，一般是在命令行打开的当前目录下，把这两个文件复制过去就行了 添加多账号配置文件config（C/Users/xxx/.ssh）： 里面的代码 如下： Host 配置的别名 HostName 填写改git账号的官网地址 IdentityFile：是对应的密钥文件 如此就可以在多个账号间切换使用了 注意这样的话只能使用git@github.com:xxxx/xxxx.git的方式拉取或推送代码，另一种我试的是失效的，得再看一下。 切换npmrun账号: 1234git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; git@npmrun.github.com:npmrun&#x2F;npmrun.github.io.git&#x2F;&#x2F; 注意前面的 git@npmrun.github.com,我加了npmrun,对应的是config里面的Host 切换1549469775账号: 1234git config --global user.name &quot;你的名称&quot; git config --global user.email &quot;你的邮箱&quot; git@1549469775.github.com:npmrun&#x2F;1549469775.github.io.git&#x2F;&#x2F; 注意前面的 git@1549469775.github.com,我加了1549469775,对应的是config里面的Host","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"eggJS路由","date":"2020-04-19T17:47:32.000Z","path":"2020/04/19/eggjs/eggJS路由/","text":"路由（Router）Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 app/router.js 文件用于统一所有路由规则。 通过统一的配置，我们可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。 如何定义 Router app/router.js 里面定义 URL 路由规则 12345&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller &#125; &#x3D; app; router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.info);&#125;; app/controller 目录下面实现 Controller 123456789&#x2F;&#x2F; app&#x2F;controller&#x2F;user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; &#x3D; this; ctx.body &#x3D; &#123; name: &#96;hello $&#123;ctx.params.id&#125;&#96;, &#125;; &#125;&#125; 这样就完成了一个最简单的 Router 定义，当用户执行 GET /user/123，user.js 这个里面的 info 方法就会执行。 Router 详细定义说明下面是路由的完整定义，参数可以根据场景的不同，自由选择： 1234router.verb(&#39;path-match&#39;, app.controller.action);router.verb(&#39;router-name&#39;, &#39;path-match&#39;, app.controller.action);router.verb(&#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action);router.verb(&#39;router-name&#39;, &#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action); 路由完整定义主要包括5个主要部分: verb - 用户触发动作，支持 get，post 等所有 HTTP 方法，后面会通过示例详细说明。 router.head - HEAD router.options - OPTIONS router.get - GET router.put - PUT router.post - POST router.patch - PATCH router.delete - DELETE router.del - 由于 delete 是一个保留字，所以提供了一个 delete 方法的别名。 router.redirect - 可以对 URL 进行重定向处理，比如我们最经常使用的可以把用户访问的根目录路由到某个主页。 router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 pathFor 和 urlFor 来生成 URL。(可选) router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 pathFor 和 urlFor 来生成 URL。(可选) path-match - 路由 URL 路径。 middleware1 - 在 Router 里面可以配置多个 Middleware。(可选) controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法： app.controller.user.fetch - 直接指定一个具体的 controller &#39;user.fetch&#39; - 可以简写为字符串形式 注意事项 在 Router 定义中， 可以支持多个 Middleware 串联执行 Controller 必须定义在 app/controller 目录中。 一个文件里面也可以包含多个 Controller 定义，在定义路由的时候，可以通过 ${fileName}.${functionName} 的方式指定对应的 Controller。 Controller 支持子目录，在定义路由的时候，可以通过 ${directoryName}.${fileName}.${functionName} 的方式制定对应的 Controller。 下面是一些路由定义的方式： 123456789&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller &#125; &#x3D; app; router.get(&#39;&#x2F;home&#39;, controller.home); router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.page); router.post(&#39;&#x2F;admin&#39;, isAdmin, controller.admin); router.post(&#39;&#x2F;user&#39;, isLoginUser, hasAdminPermission, controller.user.create); router.post(&#39;&#x2F;api&#x2F;v1&#x2F;comments&#39;, controller.v1.comments.create); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;comments.js&#125;; RESTful 风格的 URL 定义如果想通过 RESTful 的方式来定义路由， 我们提供了 app.router.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller) 快速在一个路径上生成 CRUD 路由结构。 123456&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller &#125; &#x3D; app; router.resources(&#39;posts&#39;, &#39;&#x2F;api&#x2F;posts&#39;, controller.posts); router.resources(&#39;users&#39;, &#39;&#x2F;api&#x2F;v1&#x2F;users&#39;, controller.v1.users); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;users.js&#125;; 上面代码就在 /posts 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 app/controller/posts.js 接下来， 你只需要在 posts.js 里面实现对应的函数就可以了。 Method Path Route Name Controller.Action GET /posts posts app.controllers.posts.index GET /posts/new new_post app.controllers.posts.new GET /posts/:id post app.controllers.posts.show GET /posts/:id/edit edit_post app.controllers.posts.edit POST /posts posts app.controllers.posts.create PUT /posts/:id post app.controllers.posts.update DELETE /posts/:id post app.controllers.posts.destroy 1234567891011121314&#x2F;&#x2F; app&#x2F;controller&#x2F;posts.jsexports.index &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.new &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.create &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.show &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.edit &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.update &#x3D; async () &#x3D;&gt; &#123;&#125;;exports.destroy &#x3D; async () &#x3D;&gt; &#123;&#125;; 如果我们不需要其中的某几个方法，可以不用在 posts.js 里面实现，这样对应 URL 路径也不会注册到 Router。 router 实战下面通过更多实际的例子，来说明 router 的用法。 参数获取Query String 方式1234567891011&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;search.jsexports.index &#x3D; async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;&#125;;&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;search?name&#x3D;egg 参数命名方式1234567891011&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;&#x2F;user&#x2F;:id&#x2F;:name&#39;, app.controller.user.info);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;user.jsexports.info &#x3D; async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#96;user: $&#123;ctx.params.id&#125;, $&#123;ctx.params.name&#125;&#96;;&#125;;&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user&#x2F;123&#x2F;xiaoming 复杂参数的获取路由里面也支持定义正则，可以更加灵活的获取参数： 12345678910111213&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#x2F;^\\&#x2F;package\\&#x2F;([\\w-.]+\\&#x2F;[\\w-.]+)$&#x2F;, app.controller.package.detail);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;package.jsexports.detail &#x3D; async ctx &#x3D;&gt; &#123; &#x2F;&#x2F; 如果请求 URL 被正则匹配， 可以按照捕获分组的顺序，从 ctx.params 中获取。 &#x2F;&#x2F; 按照下面的用户请求，&#96;ctx.params[0]&#96; 的 内容就是 &#96;egg&#x2F;1.0.0&#96; ctx.body &#x3D; &#96;package:$&#123;ctx.params[0]&#125;&#96;;&#125;;&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;package&#x2F;egg&#x2F;1.0.0 表单内容的获取123456789101112&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.post(&#39;&#x2F;form&#39;, app.controller.form.post);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;form.jsexports.post &#x3D; async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#96;body: $&#123;JSON.stringify(ctx.request.body)&#125;&#96;;&#125;;&#x2F;&#x2F; 模拟发起 post 请求。&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;form --data &#39;&#123;&quot;name&quot;:&quot;controller&quot;&#125;&#39; --header &#39;Content-Type:application&#x2F;json&#39; 附： 这里直接发起 POST 请求会报错：’secret is missing’。错误信息来自 koa-csrf/index.js#L69 。 原因：框架内部针对表单 POST 请求均会验证 CSRF 的值，因此我们在表单提交时，请带上 CSRF key 进行提交，可参考安全威胁csrf的防范 注意：上面的校验是因为框架中内置了安全插件 egg-security，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可。 「除非清楚的确认后果，否则不建议擅自关闭安全插件提供的功能。」 这里在写例子的话可临时在 config/config.default.js 中设置 123exports.security &#x3D; &#123; csrf: false&#125;; 表单校验1234567891011121314151617181920212223&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.post(&#39;&#x2F;user&#39;, app.controller.user);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;user.jsconst createRule &#x3D; &#123; username: &#123; type: &#39;email&#39;, &#125;, password: &#123; type: &#39;password&#39;, compare: &#39;re-password&#39;, &#125;,&#125;;exports.create &#x3D; async ctx &#x3D;&gt; &#123; &#x2F;&#x2F; 如果校验报错，会抛出异常 ctx.validate(createRule); ctx.body &#x3D; ctx.request.body;&#125;;&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user --data &#39;username&#x3D;abc@abc.com&amp;password&#x3D;111111&amp;re-password&#x3D;111111&#39; 重定向内部重定向123456789101112&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;index&#39;, &#39;&#x2F;home&#x2F;index&#39;, app.controller.home.index); app.router.redirect(&#39;&#x2F;&#39;, &#39;&#x2F;home&#x2F;index&#39;, 302);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;home.jsexports.index &#x3D; async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#39;hello controller&#39;;&#125;;&#x2F;&#x2F; curl -L http:&#x2F;&#x2F;localhost:7001 外部重定向12345678910111213141516171819&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);&#125;;&#x2F;&#x2F; app&#x2F;controller&#x2F;search.jsexports.index &#x3D; async ctx &#x3D;&gt; &#123; const type &#x3D; ctx.query.type; const q &#x3D; ctx.query.q || &#39;nodejs&#39;; if (type &#x3D;&#x3D;&#x3D; &#39;bing&#39;) &#123; ctx.redirect(&#96;http:&#x2F;&#x2F;cn.bing.com&#x2F;search?q&#x3D;$&#123;q&#125;&#96;); &#125; else &#123; ctx.redirect(&#96;https:&#x2F;&#x2F;www.google.co.kr&#x2F;search?q&#x3D;$&#123;q&#125;&#96;); &#125;&#125;;&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?type&#x3D;bing&amp;q&#x3D;node.js&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?q&#x3D;node.js 中间件的使用如果我们想把用户某一类请求的参数都大写，可以通过中间件来实现。 这里我们只是简单说明下如何使用中间件，更多请查看 中间件。 12345678910111213141516171819&#x2F;&#x2F; app&#x2F;controller&#x2F;search.jsexports.index &#x3D; async ctx &#x3D;&gt; &#123; ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;&#125;;&#x2F;&#x2F; app&#x2F;middleware&#x2F;uppercase.jsmodule.exports &#x3D; () &#x3D;&gt; &#123; return async function uppercase(ctx, next) &#123; ctx.query.name &#x3D; ctx.query.name &amp;&amp; ctx.query.name.toUpperCase(); await next(); &#125;;&#125;;&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;s&#39;, &#39;&#x2F;search&#39;, app.middleware.uppercase(), app.controller.search)&#125;;&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?name&#x3D;egg 太多路由映射？如上所述，我们并不建议把路由规则逻辑散落在多个地方，会给排查问题带来困扰。 若确实有需求，可以如下拆分： 1234567891011121314151617&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; require(&#39;.&#x2F;router&#x2F;news&#39;)(app); require(&#39;.&#x2F;router&#x2F;admin&#39;)(app);&#125;;&#x2F;&#x2F; app&#x2F;router&#x2F;news.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;&#x2F;news&#x2F;list&#39;, app.controller.news.list); app.router.get(&#39;&#x2F;news&#x2F;detail&#39;, app.controller.news.detail);&#125;;&#x2F;&#x2F; app&#x2F;router&#x2F;admin.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; app.router.get(&#39;&#x2F;admin&#x2F;user&#39;, app.controller.admin.user); app.router.get(&#39;&#x2F;admin&#x2F;log&#39;, app.controller.admin.log);&#125;; 也可直接使用 egg-router-plus。","tags":[],"categories":[{"name":"eggjs","slug":"eggjs","permalink":"https://xieyaxin.top/categories/eggjs/"}]},{"title":"hexo在github上的自动化部署","date":"2020-04-17T00:03:50.000Z","path":"2020/04/17/hexo/hexo在github上的自动化部署/","text":"这几天被GithubActions和git-lfs坑的不轻啊，在使用Actions进行自动化部署的时候，我用的百度出来的那个Actions部署库，由于不支持lfs的功能，一直就失败。经过多次尝试，我终于找到了一个能够用的库了。谢天谢地，不然真得抑郁死。 起因我是添加了对仓库的git-lfs的支持，使得能够存储大文件，而且.git文件也会小很多。 git lfs track &quot;*.zip&quot;,执行这个命令之后提交的zip文件才会被记录。 原有Actions12345678910111213141516171819202122232425262728name: GitHub Actions Build and Deploy Hexoon: push: branches: - sourcejobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions&#x2F;checkout@master with: ref: source lfs: true - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built. run: | npm install npx gulp clean npx gulp npx hexo clean npx hexo generate - name: Build and Deploy uses: JamesIves&#x2F;github-pages-deploy-action@master env: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BASE_BRANCH: source BRANCH: master FOLDER: public 上面的JamesIves/github-pages-deploy-action@master根本不支持lfs ，结果我傻傻的搞了差不多一天。 改变之后的Action12345678910111213141516171819202122232425262728name: GitHub Actions Build and Deploy Hexoon: push: branches: - sourcejobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions&#x2F;checkout@master with: submodules: true lfs: true - name: Install and BuildA 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built. run: | npm install npx gulp clean npx gulp npx hexo clean npx hexo generate - name: Deploy uses: alex-page&#x2F;blazing-fast-gh-pages-deploy@v1.1.0 with: repo-token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; site-directory: .&#x2F;public commit-message: fuck deploy-branch: master Fuck,齐活！！！","tags":[],"categories":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/categories/hexo/"}]},{"title":"常用效果框架","date":"2020-04-16T16:44:52.000Z","path":"2020/04/16/前端/常用效果框架/","text":"通用框架 轮播框架 Swiper(老牌又强大) 图表 EChart 效果 复制文本 全屏滚动插件 FullPage.js 移动端 列表滑动 mescroll 高性能虚拟滑动 vue-virtual-scroller","tags":[],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"如何给git仓库瘦身,删除大文件","date":"2020-04-16T13:24:04.000Z","path":"2020/04/16/git/如何给git仓库瘦身,删除大文件/","text":"http://blog.mallol.cn/2015/8d45392.html 开始git用久后,或者.gitignore设置不好,没有忽略掉大文件(比如:zip,sql,deb,tar.gz…等二进制文件)。会把git库撑的很大,有几个G。这些大文件有些是没必要放进来的,需要删除掉.下面有解决办法: 进入项目根目录下面(确保是最新文件)。这个git库有6.4G. 12[ jonny@wheezy ~ ]$ cd project 从所有提交(commit)中删除所有的zip文件(*.zip.其他的请自行修正). 1234[ jonny@wheezy ~ ]$ git filter-branch --force --index-filter \\&#39;git rm --cached --ignore-unmatch *.zip&#39; \\--prune-empty --tag-name-filter cat -- --all 注意，会删除磁盘上的文件，请注意备份 Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (266/266) Ref ‘refs/heads/master’ was rewritten 清除快取和回收空间。 12345[ jonny@wheezy ~ ]$ rm -rf .git&#x2F;refs&#x2F;original&#x2F; $ git reflog expire --expire&#x3D;now --all$ git gc --prune&#x3D;now$ git gc --aggressive --prune&#x3D;now 强制覆盖并上传到 remote repository。 12[ jonny@wheezy ~ ]$ git push origin master --force 打完收工！现在就可以看到瘦身的效果了。 123[ jonny@wheezy ~ ]$ du .git -lsh 126M . du -d 1 -h 问题 fatal :bad revision &#39;rm&#39;: 这个命令是使用双引号，而不是单引号。","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"gitfls大文件","date":"2020-04-16T00:05:18.000Z","path":"2020/04/16/git/gitfls大文件/","text":"作者：amosbake链接：https://www.jianshu.com/p/493b81544f80来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Git LFS 是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持 使用目的在游戏开发过程中,设计资源占用了很大一部分空间. 像png,psd等文件是二进制(blob)的,体积也很庞大. 但git的diff/patch等是基于文件行的.对于二进制文件来说. git需要存储每次commit的改动. 每次当二进制文件修改,发生变化的时候. 都会产生额外的提交量.导致clone和pull的数据量大增.在线仓库的体积也会迅速增长. LFS(Large File Storage) 就是为了解决这一问题而产生的工具. 它将你所标记的大文件保存至另外的仓库,而在主仓库仅保留其轻量级指针. 那么在你检出版本时,根据指针的变化情况下更新对应的大文件.而不是在本地保存所有版本的大文件 安装 注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5 Linux curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash sudo apt-get install git-lfs git lfs install Mac 安装HomeBrew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; brew install git-lfs git lfs install Windows 下载安装 windows installer 运行 windows installer 在命令行执行 git lfs install 使用 执行 git lfs install 开启lfs功能 使用 git lfs track 命令进行大文件追踪 例如git lfs track &quot;*.png&quot; 追踪所有后缀为png的文件 使用 git lfs track 查看现有的文件追踪模式 提交代码需要将gitattributes文件提交至仓库. 它保存了文件的追踪记录 提交后运行git lfs ls-files 可以显示当前跟踪的文件列表 将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示: clone 时 使用’git clone’ 或 git lfs clone均可","tags":[],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"}]},{"title":"eggjs错误搜集","date":"2020-04-15T15:44:34.000Z","path":"2020/04/15/eggjs/eggjs错误搜集/","text":"Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by serv https://blog.csdn.net/weixin_36222137/article/details/81293332","tags":[],"categories":[{"name":"eggjs","slug":"eggjs","permalink":"https://xieyaxin.top/categories/eggjs/"}]},{"title":"v2rayn的使用方式","date":"2020-04-15T14:52:29.000Z","path":"2020/04/15/v2ray/v2rayn的使用方式/","text":"v2rayN v2ray-windows-64 安装解压上面两个文件，得到 接下来把v2ray-window-64的所有文件全都复制到v2rayN的目录下就行了 移动后： 然后百度使用教程就行了","tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://xieyaxin.top/tags/v2ray/"}],"categories":[{"name":"v2ray","slug":"v2ray","permalink":"https://xieyaxin.top/categories/v2ray/"}]},{"title":"mysql安装","date":"2020-04-15T11:18:40.000Z","path":"2020/04/15/mysql/mysql安装/","text":"下载安装文件:MySQL https://blog.csdn.net/CWH0908/article/details/82959511 我的服务名称为MySQL80 管理员启动：net start MySQL80 停止：net start MySQL80","tags":[],"categories":[{"name":"mysql","slug":"mysql","permalink":"https://xieyaxin.top/categories/mysql/"}]},{"title":"eggjs目录结构","date":"2020-04-15T09:38:44.000Z","path":"2020/04/15/eggjs/eggjs目录结构/","text":"目录结构在快速入门中，大家对框架应该有了初步的印象，接下来我们简单了解下目录约定规范。 12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app| ├── router.js│ ├── controller│ | └── home.js│ ├── service (可选)│ | └── user.js│ ├── middleware (可选)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (可选)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (可选)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config| ├── plugin.js| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test ├── middleware | └── response_time.test.js └── controller └── home.test.js 如上，由框架约定的目录： app/router.js 用于配置 URL 路由规则，具体参见 Router。 app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。 app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。 app/middleware/** 用于编写中间件，可选，具体参见 Middleware。 app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。 app/extend/** 用于框架的扩展，可选，具体参见框架扩展。 config/config.{env}.js 用于编写配置文件，具体参见配置。 config/plugin.js 用于配置需要加载的插件，具体参见插件。 test/** 用于单元测试，具体参见单元测试。 app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。 由内置插件约定的目录： app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。 app/schedule/** 用于定时任务，可选，具体参见定时任务。 若需自定义自己的目录规范，参见 Loader API app/view/** 用于放置模板文件，可选，由模板插件约定，具体参见模板渲染。 app/model/** 用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。","tags":[],"categories":[{"name":"eggjs","slug":"eggjs","permalink":"https://xieyaxin.top/categories/eggjs/"}]},{"title":"egg.js官方手动搭建","date":"2020-04-14T17:04:09.000Z","path":"2020/04/14/eggjs/egg.js官方手动搭建/","text":"初始化项目先按以下步骤一步步初始化 12345$ mkdir egg-example$ cd egg-example$ npm init$ npm i egg --save$ npm i egg-bin --save-dev 添加 npm scripts 到 package.json： 123456&#123; &quot;name&quot;: &quot;egg-example&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;egg-bin dev&quot; &#125;&#125; 编写 Controller如果你熟悉 Web 开发或 MVC，肯定猜到我们第一步需要编写的是 Controller 和 Router。 12345678910&#x2F;&#x2F; app&#x2F;controller&#x2F;home.jsconst Controller &#x3D; require(&#39;egg&#39;).Controller;class HomeController extends Controller &#123; async index() &#123; this.ctx.body &#x3D; &#39;Hello world&#39;; &#125;&#125;module.exports &#x3D; HomeController; 配置路由映射： 12345&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller &#125; &#x3D; app; router.get(&#39;&#x2F;&#39;, controller.home.index);&#125;; 加一个配置文件： 12&#x2F;&#x2F; config&#x2F;config.default.jsexports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;; 此时目录结构如下： 12345678egg-example├── app│ ├── controller│ │ └── home.js│ └── router.js├── config│ └── config.default.js└── package.json 完整的目录结构规范参见目录结构。 好，现在可以启动应用来体验下 12$ npm run dev$ open http:&#x2F;&#x2F;localhost:7001 注意： Controller 有 class 和 exports 两种编写方式，本文示范的是前者，你可能需要参考 Controller 文档。 Config 也有 module.exports 和 exports 的写法，具体参考 Node.js modules 文档。 静态资源Egg 内置了 static 插件，线上环境建议部署到 CDN，无需该插件。 static 插件默认映射 /public/* -&gt; app/public/* 目录 此处，我们把静态资源都放到 app/public 目录即可： 123456app&#x2F;public├── css│ └── news.css└── js ├── lib.js └── news.js 模板渲染绝大多数情况，我们都需要读取数据后渲染模板，然后呈现给用户。故我们需要引入对应的模板引擎。 框架并不强制你使用某种模板引擎，只是约定了 View 插件开发规范，开发者可以引入不同的插件来实现差异化定制。 更多用法参见 View。 在本例中，我们使用 Nunjucks 来渲染，先安装对应的插件 egg-view-nunjucks ： 1$ npm i egg-view-nunjucks --save 开启插件： 12345&#x2F;&#x2F; config&#x2F;plugin.jsexports.nunjucks &#x3D; &#123; enable: true, package: &#39;egg-view-nunjucks&#39;&#125;; 123456789&#x2F;&#x2F; config&#x2F;config.default.jsexports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;;&#x2F;&#x2F; 添加 view 配置exports.view &#x3D; &#123; defaultViewEngine: &#39;nunjucks&#39;, mapping: &#123; &#39;.tpl&#39;: &#39;nunjucks&#39;, &#125;,&#125;; 注意：是 config 目录，不是 app/config! 为列表页编写模板文件，一般放置在 app/view 目录下 12345678910111213141516&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hacker News&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;public&#x2F;css&#x2F;news.css&quot; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;ul class&#x3D;&quot;news-view view&quot;&gt; &#123;% for item in list %&#125; &lt;li class&#x3D;&quot;item&quot;&gt; &lt;a href&#x3D;&quot;&#123;&#123; item.url &#125;&#125;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;a&gt; &lt;&#x2F;li&gt; &#123;% endfor %&#125; &lt;&#x2F;ul&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 添加 Controller 和 Router 1234567891011121314151617181920212223&#x2F;&#x2F; app&#x2F;controller&#x2F;news.jsconst Controller &#x3D; require(&#39;egg&#39;).Controller;class NewsController extends Controller &#123; async list() &#123; const dataList &#x3D; &#123; list: [ &#123; id: 1, title: &#39;this is news 1&#39;, url: &#39;&#x2F;news&#x2F;1&#39; &#125;, &#123; id: 2, title: &#39;this is news 2&#39;, url: &#39;&#x2F;news&#x2F;2&#39; &#125; ] &#125;; await this.ctx.render(&#39;news&#x2F;list.tpl&#39;, dataList); &#125;&#125;module.exports &#x3D; NewsController;&#x2F;&#x2F; app&#x2F;router.jsmodule.exports &#x3D; app &#x3D;&gt; &#123; const &#123; router, controller &#125; &#x3D; app; router.get(&#39;&#x2F;&#39;, controller.home.index); router.get(&#39;&#x2F;news&#39;, controller.news.list);&#125;; 启动浏览器，访问 http://localhost:7001/news 即可看到渲染后的页面。 提示：开发期默认开启了 development 插件，修改后端代码后，会自动重启 Worker 进程。 编写 service在实际应用中，Controller 一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层 Service。 我们来添加一个 Service 抓取 Hacker News 的数据 ，如下： 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; app&#x2F;service&#x2F;news.jsconst Service &#x3D; require(&#39;egg&#39;).Service;class NewsService extends Service &#123; async list(page &#x3D; 1) &#123; &#x2F;&#x2F; read config const &#123; serverUrl, pageSize &#125; &#x3D; this.config.news; &#x2F;&#x2F; use build-in http client to GET hacker-news api const &#123; data: idList &#125; &#x3D; await this.ctx.curl(&#96;$&#123;serverUrl&#125;&#x2F;topstories.json&#96;, &#123; data: &#123; orderBy: &#39;&quot;$key&quot;&#39;, startAt: &#96;&quot;$&#123;pageSize * (page - 1)&#125;&quot;&#96;, endAt: &#96;&quot;$&#123;pageSize * page - 1&#125;&quot;&#96;, &#125;, dataType: &#39;json&#39;, &#125;); &#x2F;&#x2F; parallel GET detail const newsList &#x3D; await Promise.all( Object.keys(idList).map(key &#x3D;&gt; &#123; const url &#x3D; &#96;$&#123;serverUrl&#125;&#x2F;item&#x2F;$&#123;idList[key]&#125;.json&#96;; return this.ctx.curl(url, &#123; dataType: &#39;json&#39; &#125;); &#125;) ); return newsList.map(res &#x3D;&gt; res.data); &#125;&#125;module.exports &#x3D; NewsService; 框架提供了内置的 HttpClient 来方便开发者使用 HTTP 请求。 然后稍微修改下之前的 Controller： 12345678910111213&#x2F;&#x2F; app&#x2F;controller&#x2F;news.jsconst Controller &#x3D; require(&#39;egg&#39;).Controller;class NewsController extends Controller &#123; async list() &#123; const ctx &#x3D; this.ctx; const page &#x3D; ctx.query.page || 1; const newsList &#x3D; await ctx.service.news.list(page); await ctx.render(&#39;news&#x2F;list.tpl&#39;, &#123; list: newsList &#125;); &#125;&#125;module.exports &#x3D; NewsController; 还需增加 app/service/news.js 中读取到的配置： 123456&#x2F;&#x2F; config&#x2F;config.default.js&#x2F;&#x2F; 添加 news 的配置项exports.news &#x3D; &#123; pageSize: 5, serverUrl: &#39;https:&#x2F;&#x2F;hacker-news.firebaseio.com&#x2F;v0&#39;,&#125;; 编写扩展遇到一个小问题，我们的资讯时间的数据是 UnixTime 格式的，我们希望显示为便于阅读的格式。 框架提供了一种快速扩展的方式，只需在 app/extend 目录下提供扩展脚本即可，具体参见扩展。 在这里，我们可以使用 View 插件支持的 Helper 来实现： 1$ npm i moment --save 123&#x2F;&#x2F; app&#x2F;extend&#x2F;helper.jsconst moment &#x3D; require(&#39;moment&#39;);exports.relativeTime &#x3D; time &#x3D;&gt; moment(new Date(time * 1000)).fromNow(); 在模板里面使用： 12&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;&#123;&#123; helper.relativeTime(item.time) &#125;&#125; 编写 Middleware假设有个需求：我们的新闻站点，禁止百度爬虫访问。 聪明的同学们一定很快能想到可以通过 Middleware 判断 User-Agent，如下： 1234567891011121314151617181920212223242526&#x2F;&#x2F; app&#x2F;middleware&#x2F;robot.js&#x2F;&#x2F; options &#x3D;&#x3D;&#x3D; app.config.robotmodule.exports &#x3D; (options, app) &#x3D;&gt; &#123; return async function robotMiddleware(ctx, next) &#123; const source &#x3D; ctx.get(&#39;user-agent&#39;) || &#39;&#39;; const match &#x3D; options.ua.some(ua &#x3D;&gt; ua.test(source)); if (match) &#123; ctx.status &#x3D; 403; ctx.message &#x3D; &#39;Go away, robot.&#39;; &#125; else &#123; await next(); &#125; &#125;&#125;;&#x2F;&#x2F; config&#x2F;config.default.js&#x2F;&#x2F; add middleware robotexports.middleware &#x3D; [ &#39;robot&#39;];&#x2F;&#x2F; robot&#39;s configurationsexports.robot &#x3D; &#123; ua: [ &#x2F;Baiduspider&#x2F;i, ]&#125;; 现在可以使用 curl http://localhost:7001/news -A &quot;Baiduspider&quot; 看看效果。 更多参见中间件文档。 配置文件写业务的时候，不可避免的需要有配置文件，框架提供了强大的配置合并管理功能： 支持按环境变量加载不同的配置文件，如 config.local.js， config.prod.js 等等。 应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载。 具体合并逻辑可参见配置文件。 1234567891011121314151617181920212223242526&#x2F;&#x2F; config&#x2F;config.default.jsexports.robot &#x3D; &#123; ua: [ &#x2F;curl&#x2F;i, &#x2F;Baiduspider&#x2F;i, ],&#125;;&#x2F;&#x2F; config&#x2F;config.local.js&#x2F;&#x2F; only read at development mode, will override defaultexports.robot &#x3D; &#123; ua: [ &#x2F;Baiduspider&#x2F;i, ],&#125;;&#x2F;&#x2F; app&#x2F;service&#x2F;some.jsconst Service &#x3D; require(&#39;egg&#39;).Service;class SomeService extends Service &#123; async list() &#123; const rule &#x3D; this.config.robot.ua; &#125;&#125;module.exports &#x3D; SomeService; 单元测试单元测试非常重要，框架也提供了 egg-bin 来帮开发者无痛的编写测试。 测试文件应该放在项目根目录下的 test 目录下，并以 test.js 为后缀名，即 {app_root}/test/**/*.test.js。 1234567891011&#x2F;&#x2F; test&#x2F;app&#x2F;middleware&#x2F;robot.test.jsconst &#123; app, mock, assert &#125; &#x3D; require(&#39;egg-mock&#x2F;bootstrap&#39;);describe(&#39;test&#x2F;app&#x2F;middleware&#x2F;robot.test.js&#39;, () &#x3D;&gt; &#123; it(&#39;should block robot&#39;, () &#x3D;&gt; &#123; return app.httpRequest() .get(&#39;&#x2F;&#39;) .set(&#39;User-Agent&#39;, &quot;Baiduspider&quot;) .expect(403); &#125;);&#125;); 然后配置依赖和 npm scripts： 123456&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;egg-bin test&quot;, &quot;cov&quot;: &quot;egg-bin cov&quot; &#125;&#125; 1$ npm i egg-mock --save-dev 执行测试: 1$ npm test 就这么简单，更多请参见 单元测试。 后记短短几章内容，只能讲 Egg 的冰山一角，我们建议开发者继续阅读其他章节： 关于骨架类型，参见骨架说明 提供了强大的扩展机制，参见插件。 一个大规模的团队需要遵循一定的约束和约定，在 Egg 里我们建议封装适合自己团队的上层框架，参见 框架开发。 这是一个渐进式的框架，代码的共建，复用和下沉，竟然可以这么的无痛，建议阅读 渐进式开发。 写单元测试其实很简单的事，Egg 也提供了非常多的配套辅助，我们强烈建议大家测试驱动开发，具体参见 单元测试。","tags":[],"categories":[{"name":"eggjs","slug":"eggjs","permalink":"https://xieyaxin.top/categories/eggjs/"}]},{"title":"cocos动态龙骨","date":"2020-04-14T11:22:52.000Z","path":"2020/04/14/cocos/cocos动态龙骨/","text":"在cocos中有关动态的，都离不开resources这个目录，同时，这个目录使用的是loader模块加载。在游戏的开发过程中，对于一些节点有着十分多的动画资源的时候，比如换装之类的，这样的话全部挂载在一个节点上的话会造成游戏加载时间过长，玩家的耐心会消磨完。因此就有了动态的需求，主要的目的就是使得用户能够尽快的进去。 资源位置在cocos中，动态资源都是放在resources中的， 示例目录如下： 然后我们采用loadResDir的方式加载eatting下的三个龙骨资源，因为这三个都是必须的，必须同时加载。 12345678910111213141516171819202122232425262728293031323334353637383940loadDragonBones( path: string, cb?: (bone: IDragonAssets) &#x3D;&gt; void): Promise&lt;IDragonAssets&gt; &#123; let that &#x3D; this; let allAssets: IDragonAssets &#x3D; &#123; dragonAsset: null, dragonAtlasAsset: null &#125; return new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F;动态加载龙骨 if (this.cacheAssets[path]) &#123; allAssets &#x3D; this.cacheAssets[path] cb &amp;&amp; cb(allAssets); resolve(allAssets); return; &#125; let ac &#x3D; cc.loader.loadResDir(path, function (err, assets) &#123; if (err || assets.length &lt;&#x3D; 0) &#123; err &amp;&amp; console.error(err) assets.length &lt;&#x3D; 0 &amp;&amp; console.error(&quot;该目录下没有资源:&quot; + path) &#x2F;&#x2F; reject(); return; &#125; assets.forEach(asset &#x3D;&gt; &#123; if (asset instanceof dragonBones.DragonBonesAsset) &#123; allAssets.dragonAsset &#x3D; asset; &#125; if (asset instanceof dragonBones.DragonBonesAtlasAsset) &#123; allAssets.dragonAtlasAsset &#x3D; asset; &#125; &#125;); cb &amp;&amp; cb(allAssets); resolve(allAssets); that.cacheAssets[path] &#x3D; allAssets &#125;); &#125;)&#125; 导出DragonBonesAsset和DragonBonesAtlasAsset后，动态赋值到节点的龙骨组件上就行了。 1234567891011121314151617181920loadingNodeDragon( node: cc.Node, bones: IDragonAssets, armatureName?: string) &#123; let animationDisplay &#x3D; node.getComponent(dragonBones.ArmatureDisplay); if (!animationDisplay) &#123; animationDisplay &#x3D; node.addComponent(dragonBones.ArmatureDisplay); &#125; if (bones.dragonAsset instanceof dragonBones.DragonBonesAsset) &#123; animationDisplay.dragonAsset &#x3D; bones.dragonAsset; &#125; if (bones.dragonAtlasAsset instanceof dragonBones.DragonBonesAtlasAsset) &#123; animationDisplay.dragonAtlasAsset &#x3D; bones.dragonAtlasAsset; &#125; if (armatureName) &#123; animationDisplay.armatureName &#x3D; armatureName; &#125; return animationDisplay&#125;; 接下来只要正常播放就行了。","tags":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"}],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"cocos适配心得","date":"2020-04-14T11:12:36.000Z","path":"2020/04/14/cocos/cocos适配心得/","text":"在cocos的适配方案中，默认提供的就是fit height和fit width. fit height表示根据高度来适配，高度一定是与设备高度一直，宽度可以随意变化，这个时候，在宽度很宽的情况下可能会有两边截断的情况。 fit width同理 当两个一起钩选的时候，会保证界面一定完整的显示界面，但是不可避免的，会产生黑边。 在做cocos的适配的时候，我们不能直接钩选两个，而是只控制一边，另一部分可结合Widget组件来实现 简要 场景的适配策略只需要钩选适配高度就行了。再结合Widget就能够实现不留黑边的全屏 但这还是不够的，因为你的子元素也得加上这个Widget才行，保证不是绝对布局，而是相对于上下左右四个边界的距离，灵活调整top,right,bottom,left的值，就能实现全屏与布局的流动化。 缺点你要实现某部分的流动布局，必须将其所有的父元素也先widget化.或者直接绑定根元素 屏幕太小的话元素会重叠。","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"cocos的几种动画方式","date":"2020-04-14T10:48:52.000Z","path":"2020/04/14/cocos/动画/cocos的几种动画方式/","text":"","tags":[],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"},{"name":"动画","slug":"cocos/动画","permalink":"https://xieyaxin.top/categories/cocos/%E5%8A%A8%E7%94%BB/"}]},{"title":"github-actions详解","date":"2020-04-14T09:53:55.000Z","path":"2020/04/14/github/github-actions详解/","text":"https://www.v2ex.com/t/609744 http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html","tags":[],"categories":[{"name":"github","slug":"github","permalink":"https://xieyaxin.top/categories/github/"}]},{"title":"webpack的几种导入导出方式","date":"2020-04-13T14:11:23.000Z","path":"2020/04/13/webpack/webpack的几种导入导出方式/","text":"","tags":[{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/tags/webpack/"}],"categories":[{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/categories/webpack/"}]},{"title":"正则表达式","date":"2020-04-11T11:57:51.000Z","path":"2020/04/11/正则表达式/正则表达式/","text":"正则表达式 表达式全集 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（,+,?，{*n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“*n”之外的任何单个字符。要匹配包括“\\n*”在内的任何字符，请使用像“(.|\\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$//^[a-z\\d]+(.[a-z\\d]+)*@(\\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$/ IP 地址 /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\\S)//.*$ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/","tags":[{"name":"RegExp","slug":"RegExp","permalink":"https://xieyaxin.top/tags/RegExp/"}],"categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://xieyaxin.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"cocos creator常用api","date":"2020-04-07T13:41:11.000Z","path":"2020/04/07/cocos/cocos-creator常用api/","text":"https://blog.csdn.net/sotmwhat/article/details/93884076 场景加载123cc.director.loadScene('场景名称');//场景跳转cc.director.preloadScene('场景名称');//预加载场景cc.director.getScene();//获取当前场景 获取节点1234567891011121314151617181920212223242526272829303132var node = cc.find(\"Canvas/bg\");//通过访问路径来获取节点var a = this.node.getChildByName('name');//通过名字获取子节点node.getComponent(cc.Label).string = 'abc';//获取节点上的组件值var a = cc.find(\"Canvas/bg\").getComponent(cc.Sprite);//通过访问路径来获取节点，及获取该节点的指定组件this.node .getChildByName('节点名称').getComponent(cc.Label)//通过节点名获取子节点，获取该节点指定组件var a = this.node;//获取当前脚本所在的节点var a = this.node.parent;//获取父节点var a = this.node.getChildByTag(1001);//通过标签获取子节点var a = cc.find(\"bg/score\",this.node);//通过指定节点下的路径获取节点var a = this.node.children;//获取所有子节点var a = this.node.childrenCount;//获取子节点数量var a = cc.director.getScene();//获取场景主节点var a = cc.instantiate(node);//克隆节点this.node.parent = cc.find('Canvas');//绑定父节点this.node.addChild(nodeName,zIndex,tag);//添加子节点,可设置层级和标签this.node.removeChild(nodeName);//通过名字移除子节点this.node.removeChildByTag (nodeTag);//通过标签移除子节点this.node.destroy();//销毁节点this.node.isValid;//判定节点是否可用this.node.removeChild(newNode);//移除节点中指定的子节点this.node.removeChildByTag(1001);//通过标签移除节点中指定的子节点this.node.removeAllChildren();//移除所有子节点this.node.destroyAllChildren();//销毁所有子节点this.node.cleanup();//停止所有正在播放的动作和计时器var sprites = this.node.getComponentsInChildren(cc.Label);//递归查找自身及所有子节点中指定类型的组件 获取节点位置，设置节点1234567891011121314151617181920212223242526var a = node.getPositionX();或 getPositionY() //获取节点的X轴或Y轴坐标var a = node.getScaleX(); 或getScaleY() //获取节点的X轴或Y轴缩放比例node.x = 100;//设置节点x轴坐标node.y = 100;//设置节点y轴坐标node.setPosition(x,y); //设置节点坐标node.rotation = 90; //设置节点旋转角度node.scaleX = 2; //设置节点x轴缩放倍数node.scaleY = 2; //设置节点y轴缩放倍数node.setScale(2); //设置节点整体缩放倍数node.width = 100; //设置节点宽度大小node.height = 100; //设置节点高度大小node.setContentSize(100, 100); //设置节点宽高尺寸大小node.anchorX = 1; //设置节点x轴锚点坐标node.anchorY = 0; //设置节点y轴锚点坐标node.setAnchorPoint(1, 0); //设置节点锚点坐标node.opacity = 128; //设置节点透明度大小（0-255）node.setOpacity(20); //设置节点透明度（0~255）node.color = new cc.color(100,100,100,255); //设置节点颜色（R,G,B,透明度）if (cc.isValid(this.label.node) ) //判定节点是否存在node.destroy(); //销毁节点this.cannons = [];this.cannons = node.getChildren(); //获取所有子节点this.cannons = node.getChildrenCount(); //获取子节点数量node.active = false; //关闭节点(隐藏节点)cc.game.addPersistRootNode(myNode); //常驻节点（全局变量）cc.game.removePersistRootNode(myNode); //取消常驻节点 动作操作12345678910111213141516171819202122232425cc.show()&#x2F;&#x2F;立即显示cc.hide ()&#x2F;&#x2F;立即隐藏cc.toggleVisibility()&#x2F;&#x2F;显隐切换cc.fadeIn(1)&#x2F;&#x2F;渐显效果cc.fadeOut(1)&#x2F;&#x2F;渐隐效果cc.delayTime(1)&#x2F;&#x2F;等待1秒node.runAction(cc.moveTo(1,0,0)); &#x2F;&#x2F;移动到当前节点（时间（s），X轴坐标，Y 轴坐标）node.runAction(cc.scaleTo(1,0.7,0.8));&#x2F;&#x2F;缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）node.runAction(cc.rotateTo(1,160,160));&#x2F;&#x2F;旋转到指定角度（时间（s），X轴角度，Y 轴角度）node.runAction(cc.skewTo(1,5,-5));&#x2F;&#x2F;变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）node.runAction(cc.fadeTo(2,0));&#x2F;&#x2F;变化当前节点的透明度（时间（s），透明度）node.runAction(cc.tintTo(2,255,255,0));&#x2F;&#x2F;变化当前节点颜色（时间，R,G,B）node.stopAllActions();&#x2F;&#x2F;停止所有动作&#x2F;&#x2F;自定义动作var action &#x3D; cc.moveTo(2, 100, 100);&#x2F;&#x2F; 创建一个移动动作node.runAction(action);&#x2F;&#x2F; 执行动作node.stopAction(action);&#x2F;&#x2F; 停止一个动作cc.sequence(action1,action2); &#x2F;&#x2F;按顺序连续执行，先action1，后action2cc.spawn(action1，action2); &#x2F;&#x2F;同时执行，action1和action2一起执行cc.repeatForever(cc.sequence(action1,action2)); &#x2F;&#x2F;一直重复括号里的动作 计时器1234567891011121314151617181920212223242526&#x2F;&#x2F;只用1次的计时器,2秒后执行 this.scheduleOnce(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,2); &#x2F;&#x2F;(function()&#123;&#125;,时间（s）)&#x2F;&#x2F;每隔5秒执行1次 this.schedule(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,5);&#x2F;&#x2F;计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次） this.schedule(function()&#123; &#x2F;&#x2F;一条或多条执行语句 &#125;,0.1,10,1); &#x2F;&#x2F;(function()&#123;&#125;,间隔时间，次数，多久后开始)this.unscheduleAllCallbacks(this);&#x2F;&#x2F;停止某组件的所有计时器&#x2F;&#x2F;自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）var cb&#x3D; function()&#123; &#x2F;&#x2F;do something&#125;;this.schedule(cb,1);&#x2F;&#x2F;启动定时器this.unschedule(cb);&#x2F;&#x2F;取消定时器 事件监听12345678910(开始：&#39;touchstart&#39;，移动：&#39;touchmove&#39;，结束：&#39;touchend&#39;，取消：&#39;touchcancel&#39;)node.on(&#39;touchstart&#39;,function(event)&#123; this.doSomething();&#125;,this); var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的IDvar a &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的坐标Xvar b &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的坐标Ycc.eventManager.addListener(&#123; event: cc.EventListener.KEYBOARD&#x2F;TOUCH_ONE_BY_ONE,myfunction&#125;,self.node); 分辨率12345678&#x2F;&#x2F;获得设备分辨率var b &#x3D; cc.director.getWinSizeInPixels()var bx &#x3D; b.widthvar by &#x3D; b.heightcc.view.getCanvasSize().width;&#x2F;&#x2F;获得设备分辨率的宽度cc.view.getCanvasSize().height;&#x2F;&#x2F;获得设备分辨率的高度cc.director.setDisplayStats(true);&#x2F;&#x2F;显示帧数信息 音频控制1234567cc.audioEngine.playMusic(this.BGAudio,true);&#x2F;&#x2F;播放音乐（true代表循环）cc.audioEngine.stopMusic()&#x2F;&#x2F;停止播放背景音乐cc.audioEngine.playEffect(this.ClickAudio,false);&#x2F;&#x2F;播放音效（false代表只播放一次）cc.audioEngine.stopEffect(音效变量名);&#x2F;&#x2F;停止指定音效（需要先把音效赋值给变量）cc.audioEngine.AllEffects();&#x2F;&#x2F;停止所有音效cc.audioEngine.setMusicVolume(参数); &#x2F;&#x2F;设置背景音乐的音量（该参数范围是0到1）cc.audioEngine.setEffectsVolume(参数); &#x2F;&#x2F;设置音效的音量（该参数范围是0到1） 存档操作12345678910cc.sys.localStorage.setItem(&#39;存储标识名&#39;,变量名);&#x2F;&#x2F;存储存档数据var a &#x3D; cc.sys.localStorage.getItem(&#39;存储标识名&#39;);&#x2F;&#x2F;读取存档数据cc.sys.localStorage.removeItem(&#39;存储标识名&#39;);&#x2F;&#x2F;擦除存档数据userData &#x3D; &#123; name: &#39;Tracer&#39;, level: 1, gold: 100&#125;;cc.sys.localStorage.setItem(&#39;userData&#39;, JSON.stringify(userData));&#x2F;&#x2F;存取复杂对象数据var userData &#x3D; JSON.parse(cc.sys.localStorage.getItem(&#39;userData&#39;));&#x2F;&#x2F;读取复杂对象数据 判断平台12345678910cc.sys.isNative &#x2F;&#x2F;是否是本地cc.sys.isBrowser &#x2F;&#x2F;是否是网页cc.sys.isMobile &#x2F;&#x2F;是否是移动系统cc.sys.platform &#x2F;&#x2F;正在运行的平台cc.sys.language &#x2F;&#x2F;当前运行系统的语言cc.sys.os &#x2F;&#x2F;当前正在运行的系统cc.sys.OS_IOS &#x2F;&#x2F;是否是IOS系统cc.sys.OS_ANDROID &#x2F;&#x2F;是否是android系统cc.sys.OS_WINDOWS &#x2F;&#x2F;是否是windows系统cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;); &#x2F;&#x2F;打开网页 监听和发射事件1234567891011121314151617181920212223242526272829303132333435this.node.pauseSystemEvents(true);&#x2F;&#x2F;暂停节点系统事件this.node.resumeSystemEvents(true);&#x2F;&#x2F;恢复节点系统事件this.node.targetOff(this);&#x2F;&#x2F;移除所有注册事件触摸监听：开始&#39;touchstart&#39;,移动&#39;touchmove&#39;,结束&#39;touchend&#39;,取消&#39;touchcancel&#39;var pos &#x3D; event.getLocation();&#x2F;&#x2F;获取触摸点的坐标(包含X和Y)var x &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的X坐标var y &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的Y坐标var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID鼠标监听：鼠标按下&#39;mousedown&#39;,移入节点&#39;mouseenter&#39;,节点中移动&#39;mousemove&#39;,移出节点&#39;mouseleave,&#39;松开鼠标&#39;mouseup&#39;var a &#x3D; event.getScrollY();&#x2F;&#x2F;获取滚轮滚动的 Y 轴距离，只有滚动时才有效var a &#x3D; event.getLocation();&#x2F;&#x2F;获取鼠标位置对象，对象包含 x 和 y 属性输入框监听：获得焦点&#39;editing-did-began&#39;,文字变化&#39;text-changed&#39;,失去焦点&#39;editing-did-ended&#39;,按下回车&#39;editing-return&#39;属性变化监听：位置&#39;position-changed&#39;,宽高 &#39;size-changed&#39;,旋转&#39;rotation-changed&#39;,缩放&#39;scale-changed&#39;ScrollView控件监听：滚动中&#39;scrolling&#39;,停止滚动&#39;scroll-ended&#39;用户自定义事件:this.node.on(&#39;事件名&#39;,function,this);&#x2F;&#x2F;注册监听this.node.emit(&#39;事件名&#39;);&#x2F;&#x2F;发送监听广播this.node.off(&#39;事件名&#39;,function,this);&#x2F;&#x2F;关闭监听&#x2F;&#x2F;注册带参数监听this.node.on(&#39;事件名&#39;,function(event)&#123;“具体方法函数内容”&#125;,this);&#x2F;&#x2F;发送带参数的监听this.node.emit(&#39;事件名&#39;,&#123;id:1001&#125;);cc.eventManager.addListener(listener, node);&#x2F;&#x2F;添加事件cc.eventManager.removeListener((listener);&#x2F;&#x2F;移除事件 其他操作123456789cc.director.pause();&#x2F;&#x2F;暂停cc.director.resume();&#x2F;&#x2F;继续cc.director.end();&#x2F;&#x2F;退出整个应用cc.log(变量) 或 console.log(something);&#x2F;&#x2F;输出想要的信息let self &#x3D; this;&#x2F;&#x2F;锁定当前使用的this指向node.getLocalZOrder();&#x2F;&#x2F;层级获取node.setLocalZOrder(1);&#x2F;&#x2F;层级改变cc.find(&#39;canvas&#x2F;map&#39; + num)&#x2F;&#x2F;读取带变量的路径cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);&#x2F;&#x2F;打开网页","tags":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"}],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"spriteAltas精灵图集使用方式","date":"2020-04-07T11:43:23.000Z","path":"2020/04/07/cocos/spriteAltas精灵图集使用方式/","text":"之前，对于扑克牌的加载一直是散装加载，用loadRes动态的添加到游戏中，这样的缺陷是在动画的时候会闪一下，在网慢的情况下也许扑克牌不会加载出来而动画就执行了。因此，改用图集加载方式，将整幅扑克牌一起加载出来，用那种加载哪张就行了。 新加一个属性: 我们用图集打包出来的是这样的文件： 在cocos上将plist拖进属性中。 编写代码动态修改精灵图： 1234567891011setAtlasImg(node,spAtlas,spriteName)&#123; let sprite = node.getComponent(cc.Sprite); if (!sprite) &#123; sprite = node.addComponent(cc.Sprite); &#125; let mySprite = spAtlas.getSpriteFrame(spriteName) sprite.spriteFrame = mySprite; return mySprite;&#125;// 节点，图集组件，图集中文件名字setAtlasImg(this.node, this.spAtlas, \"11\");","tags":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"}],"categories":[{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"}]},{"title":"有关用node开发websocket多人聊天程序的后台","date":"2020-04-06T20:58:29.000Z","path":"2020/04/06/node/有关用node开发websocket多人聊天程序的后台/","text":"知识储备（开发过程中积累） ws库的使用方法 node的语言熟悉度 数据库增删改查的基础语法 明确的流程分析与功能","tags":[{"name":"node","slug":"node","permalink":"https://xieyaxin.top/tags/node/"}],"categories":[{"name":"node","slug":"node","permalink":"https://xieyaxin.top/categories/node/"}]},{"title":"node生成文件模板","date":"2020-04-06T16:57:45.000Z","path":"2020/04/06/node/node生成文件模板/","text":"主要用作生成文件模板，方便之后的一系列开发，能够快速的制作类似结构的复杂页面。 plop npm 安装依赖1npm i plop -D 源码下载: Hexo文章页面模板下载","tags":[],"categories":[{"name":"node","slug":"node","permalink":"https://xieyaxin.top/categories/node/"}]},{"title":"支付宝免签支付","date":"2020-04-06T12:50:17.000Z","path":"2020/04/06/前端/业务相关/支付宝免签支付/","text":"源码下载：点击下载 在最近的公司业务中，需要用到灰色地带的支付，因此不能使用正规的支付宝流程，经过一段事件的调查与研究，发现了有关支付宝的免签支付，不过也存在着几种方式，有些方式并不适用，都存在着一些无法避免的限制。","tags":[{"name":"支付","slug":"支付","permalink":"https://xieyaxin.top/tags/%E6%94%AF%E4%BB%98/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"业务相关","slug":"前端/业务相关","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/"}]},{"title":"hexo添加看板娘","date":"2020-04-05T11:18:13.000Z","path":"2020/04/05/hexo/hexo添加看板娘/","text":"源码下载：点击下载 源码地址：live2d-widget 这是首先感谢原作者的插件，我根据Github上的项目克隆下载自定义的看板娘，在他的基础上添加了拖动效果，同时根据自己的博客自定义了不同的对话。 用法 Usage 首先下载上面的源码，这个hexo-bolg表示是我的博客根目录，然后再source\\js目录下解压，得到以下的文件。 如果是next主题，请根据目录打开以下文件: 将代码添加到如图所示的位置： 大功告成，将页面启动起来就能看见效果了。不过最好自己去改一下源码的waifu-tips.json的匹配条件，根据自己的博客做出对应的对话效果。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/tags/hexo/"}],"categories":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/categories/hexo/"}]},{"title":"css实现全站变灰","date":"2020-04-04T22:48:22.000Z","path":"2020/04/04/前端/css实现全站变灰/","text":"123456789html&#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransfrom.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(1);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://xieyaxin.top/tags/css/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"webpack零散知识点","date":"2020-04-04T22:36:53.000Z","path":"2020/04/04/webpack/webpack零散知识点/","text":"参数解析 mode 主要区分为：development和production 选项 描述 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 记住，只设置 NODE_ENV，则不会自动设置 mode。 entry 可以是数组或者对象 数组 数组中表示的所有文件都将打包成一个文件，对应的是对象中键的main。也就是说 如果值是[&#39;src/index.js&#39;]的话，跟{main:&#39;src/index.js&#39;}效果是一样的。 对象 如果存在多个键值的话表示的就是多个入口，webpack将会从多个入口进入开始打包。例如： 1234567...\"entry\":&#123; \"main\":[\"src/index.js\"], \"react\":\"react\", \"vue\":[\"vue\",\"vue-router\",\"vuex\"]&#125;... 如上的话就会打包出三个文件出来，分别是main,react,vue名字可以再输出的时候自定义。 output 对象。作为此配置的最低要求，我们需要提供两个参数：1. filename表示将要输出的文件名字。2. path将要输出的路径 单入口文件 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。 多入口文件 多入口不能单独的指定一个具体的文件名，而是需要提供一个占位符，由webpack提供各个文件的一些参数，但是具体的名字仍旧可以自己定义。 1234567891011&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js publicPath (这个参数尚未用过)","tags":[{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/tags/webpack/"}],"categories":[{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/categories/webpack/"}]},{"title":"前端知识漫游","date":"2020-04-04T22:36:53.000Z","path":"2020/04/04/前端/前端知识漫游/","text":"前端大部分的知识流程梳理（2019）","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"各种标签说明","date":"2020-04-04T22:36:53.000Z","path":"2020/04/04/前端/基础知识/各种标签说明/","text":"New : HTML5 中的新标签。 标签 描述 效果 浏览器支持情况 &lt;!--...--&gt; 定义注释 &lt;!DOCTYPE&gt; 定义文档类型 &lt;a&gt; 定义锚点 锚点 &lt;abbr&gt; 定义缩写 PRC &lt;acronym&gt; 定义只取首字母的缩写 WWW &lt;address&gt; 定义文档作者或拥有者的联系信息。 Donald USA &lt;area&gt; 定义图像映射内部的区域。 area说明 &lt;article&gt; 定义文章。 &lt;aside&gt; 定义页面内容之外的内容。 &lt;audio&gt; 定义声音内容 基本都可以用 &lt;b&gt; 定义粗体字 粗体字 基本都可以用","tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础知识","slug":"前端/基础知识","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"hexo+typora 博客中插入图片","date":"2020-04-04T18:01:52.000Z","path":"2020/04/04/hexo/hexo-typora-博客中插入图片/","text":"在使用了hexo搭建了博客后，最大的问题便是如何使用一款markdown工具来编辑博客了，我采取的就是Typora，这工具免费简单易用没广告，而且把图片保存到本地还是很方便的，因此大家只要稍微了解点markdown语法就可以上手使用了。 关于图片和图片路径的设置，有以下教程。 所有博客文件均保存在 hexo/_posts/文件夹下 hexo &gt; source目录下建一个文件夹叫images，用来保存博客中的图片。 打开Typora的 文件 &gt; 偏好设置，进行如下设置。 这样的话所有的博客中的图片都将会保存到 /source/images/该博客md文件名/图片名称 但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。 在typora菜单栏点击 格式-&gt;图像-&gt;设置图片根目录，将hexo/source作为其根目录即可。一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！ 之后再该md文件头部会出现:typora-root-url: ..\\..\\source这样的代码，我们将这行代码复制进模板文件中 以下这三个都可以添加 只要在第一个---下添加typora-root-url: ..\\..\\source就行了，这样Typora就能识别而不用每次都自己手动设置了。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/tags/hexo/"},{"name":"typora","slug":"typora","permalink":"https://xieyaxin.top/tags/typora/"}],"categories":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/categories/hexo/"}]},{"title":"Hexo常用命令","date":"2020-04-03T11:30:46.000Z","path":"2020/04/03/hexo/Hexo常用命令/","text":"常用命令hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作hexo new pagehexo new post 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout]hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的hexo generate --deployhexo deploy –generate hexo deploy -g hexo server -g 新建Hexo项目123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 飒飒","tags":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/tags/hexo/"}],"categories":[{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/categories/hexo/"}]},{"title":"npm库个人常用整合","date":"2020-04-01T11:16:24.000Z","path":"2020/04/01/npm/npm库个人常用整合/","text":"数学计算库 math.js 生成文件模板 plop （用于快速生成模板文件，可提供变量定制化输出） 打包工具 webpack (大名鼎鼎的模块打包工具) 发布订阅库PubSubJS，@types/pubsub-js，events Webpack常用库 html-webpack-plugin 打包html，提供脚本样式注入等功能","tags":[],"categories":[{"name":"npm","slug":"npm","permalink":"https://xieyaxin.top/categories/npm/"}]},{"title":"lerna使用方法","date":"2020-03-31T19:19:39.000Z","path":"2020/03/31/lerna/lerna使用方法/","text":"lerna主要用于分模块管理js的依赖库，对于库项目开发者非常有友好，它可以将一个大的库项目分离成一个个独立的项目，但又不是完全独立的，而是全部由lerna进行管理。它的类似目录结构如下： 1234567my-lerna-repo/ package.json packages/ package-1/ package.json package-2/ package.json 环境安装1234&#x2F;&#x2F; 全局安装npm i -g lerna&#x2F;&#x2F; 局部安装npm i -D lerna 初始化12345cd 你的项目根目录&#x2F;&#x2F;全局安装的话执行下面这个lerna init&#x2F;&#x2F;局部安装的话执行下面这个npx lerna init","tags":[],"categories":[{"name":"lerna","slug":"lerna","permalink":"https://xieyaxin.top/categories/lerna/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://xieyaxin.top/categories/git/"},{"name":"随想","slug":"随想","permalink":"https://xieyaxin.top/categories/%E9%9A%8F%E6%83%B3/"},{"name":"技术积累","slug":"技术积累","permalink":"https://xieyaxin.top/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"},{"name":"MDN","slug":"技术积累/MDN","permalink":"https://xieyaxin.top/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/MDN/"},{"name":"小说","slug":"小说","permalink":"https://xieyaxin.top/categories/%E5%B0%8F%E8%AF%B4/"},{"name":"npm","slug":"npm","permalink":"https://xieyaxin.top/categories/npm/"},{"name":"试用","slug":"npm/试用","permalink":"https://xieyaxin.top/categories/npm/%E8%AF%95%E7%94%A8/"},{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"收集","slug":"收集","permalink":"https://xieyaxin.top/categories/%E6%94%B6%E9%9B%86/"},{"name":"知识","slug":"知识","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/"},{"name":"nginx","slug":"知识/nginx","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/nginx/"},{"name":"ts","slug":"ts","permalink":"https://xieyaxin.top/categories/ts/"},{"name":"javascript","slug":"前端/javascript","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/javascript/"},{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/categories/cocos/"},{"name":"前端","slug":"知识/前端","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://xieyaxin.top/categories/css/"},{"name":"知识","slug":"css/知识","permalink":"https://xieyaxin.top/categories/css/%E7%9F%A5%E8%AF%86/"},{"name":"loadsh","slug":"loadsh","permalink":"https://xieyaxin.top/categories/loadsh/"},{"name":"数组操作","slug":"loadsh/数组操作","permalink":"https://xieyaxin.top/categories/loadsh/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"name":"sourcemap","slug":"知识/sourcemap","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/sourcemap/"},{"name":"同源与跨域","slug":"知识/前端/同源与跨域","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xieyaxin.top/categories/leetcode/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"前端","slug":"疑难杂症/前端","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%89%8D%E7%AB%AF/"},{"name":"原创","slug":"原创","permalink":"https://xieyaxin.top/categories/%E5%8E%9F%E5%88%9B/"},{"name":"vue","slug":"疑难杂症/vue","permalink":"https://xieyaxin.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/vue/"},{"name":"cocos","slug":"知识/cocos","permalink":"https://xieyaxin.top/categories/%E7%9F%A5%E8%AF%86/cocos/"},{"name":"实战","slug":"前端/实战","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E6%88%98/"},{"name":"业务相关","slug":"前端/业务相关","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/"},{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"vue","slug":"vue","permalink":"https://xieyaxin.top/categories/vue/"},{"name":"vue","slug":"vue/vue","permalink":"https://xieyaxin.top/categories/vue/vue/"},{"name":"docker","slug":"docker","permalink":"https://xieyaxin.top/categories/docker/"},{"name":"跨域","slug":"跨域","permalink":"https://xieyaxin.top/categories/%E8%B7%A8%E5%9F%9F/"},{"name":"3D","slug":"3D","permalink":"https://xieyaxin.top/categories/3D/"},{"name":"node","slug":"node","permalink":"https://xieyaxin.top/categories/node/"},{"name":"uniapp","slug":"uniapp","permalink":"https://xieyaxin.top/categories/uniapp/"},{"name":"eggjs","slug":"eggjs","permalink":"https://xieyaxin.top/categories/eggjs/"},{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/categories/hexo/"},{"name":"v2ray","slug":"v2ray","permalink":"https://xieyaxin.top/categories/v2ray/"},{"name":"mysql","slug":"mysql","permalink":"https://xieyaxin.top/categories/mysql/"},{"name":"动画","slug":"cocos/动画","permalink":"https://xieyaxin.top/categories/cocos/%E5%8A%A8%E7%94%BB/"},{"name":"github","slug":"github","permalink":"https://xieyaxin.top/categories/github/"},{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/categories/webpack/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://xieyaxin.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"基础知识","slug":"前端/基础知识","permalink":"https://xieyaxin.top/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"lerna","slug":"lerna","permalink":"https://xieyaxin.top/categories/lerna/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xieyaxin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"https://xieyaxin.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"3D","slug":"3D","permalink":"https://xieyaxin.top/tags/3D/"},{"name":"v2ray","slug":"v2ray","permalink":"https://xieyaxin.top/tags/v2ray/"},{"name":"cocos","slug":"cocos","permalink":"https://xieyaxin.top/tags/cocos/"},{"name":"webpack","slug":"webpack","permalink":"https://xieyaxin.top/tags/webpack/"},{"name":"RegExp","slug":"RegExp","permalink":"https://xieyaxin.top/tags/RegExp/"},{"name":"node","slug":"node","permalink":"https://xieyaxin.top/tags/node/"},{"name":"支付","slug":"支付","permalink":"https://xieyaxin.top/tags/%E6%94%AF%E4%BB%98/"},{"name":"hexo","slug":"hexo","permalink":"https://xieyaxin.top/tags/hexo/"},{"name":"css","slug":"css","permalink":"https://xieyaxin.top/tags/css/"},{"name":"typora","slug":"typora","permalink":"https://xieyaxin.top/tags/typora/"}]}