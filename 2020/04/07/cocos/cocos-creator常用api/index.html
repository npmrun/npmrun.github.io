<!DOCTYPE html>
<html>
  <head>
    <title>黑白梦境</title>
    <!-- 响应式的关键，不设置的话页面会自动缩小 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <link rel="shortcut icon" href="/avatar.jpg">
    
<link rel="stylesheet" href="/css/lib/scroll.css">

    
<link rel="stylesheet" href="/css/lib/normalize.css">

    
<link rel="stylesheet" href="/css/lib/media.css">

    
<link rel="stylesheet" href="/css/lib/markdown.css">

    
<link rel="stylesheet" href="/css/global.css">

    
  <meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="时光之城" type="application/atom+xml">
</head>
  <body>
</body></html>
<div id="line" style="position:fixed;top:0;left:0;right:0;height:2px;width:0;background-color:black;"></div>
<div class="wrapper" id="page">
  <header class="header-wrapper session-wrapper wow animate__slideInDown" data-wow-duration="1s">
  <a href="/" class="title" title="黑白梦境">黑白梦境</a>
  <!-- <div class="sub">记得吗？过去的你深陷泥沼！</div> -->
  <ol class="menu">  
  
    <li class="menu-item" title="首页"><a href="/">首页</a></li>
  
    <li class="menu-item" title="关于"><a href="/about">关于</a></li>
  
    <li class="menu-item" title="归档"><a href="/archives">归档</a></li>
  
    <li class="menu-item" title="友情链接"><a href="/link">友情链接</a></li>
   
  <li class="menu-item" title="搜索" onclick="search_dialog.style.display=search_dialog.style.display!=='none'?'none':'block';"><a href="javascript:void 0;">搜索</a></li>
  </ol>
</header>
  
<link rel="stylesheet" href="/css/post.css">

<div class="middle">
  <div class="article-list session-wrapper" style="min-height: auto;margin-top:40px;padding-left: 25px;">
    <h2 class="article-list__title">cocos creator常用api</h2>
    <div class="article-list__meta">
      <p class="article-list__author">作者西风吹盛夏</p>
      <p class="article-list__time">更新:2020-09-20</p>
    </div>
  </div>
  <article id="write" class="markdown-body article  session-wrapper wow animate__fadeIn " data-wow-duration="1s">
    <blockquote>
<p>主题：cocos creator常用api<br>概述：收集cocos creator常用的函数，防止老年痴呆，记得东西太多会使自己混乱，写下来才是王道。</p>
</blockquote>
<!--正文-->
<!--more-->

<blockquote>
<p><a href="https://blog.csdn.net/sotmwhat/article/details/93884076" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/sotmwhat/article/details/93884076</a></p>
</blockquote>
<h3 id="给自己的忠告"><a href="#给自己的忠告" class="headerlink" title="给自己的忠告"></a>给自己的忠告</h3><ol>
<li>异步读取的必须要判断节点或者组件是否isValid可用</li>
<li>龙骨动画节点中途中断并重新执行，异步的情况下并不会触发结束，导致后面的代码无法执行，处理时开一个定时器当作判断，而不是用动画结束判断</li>
<li>文件名就算在不同文件夹最好也不要一样</li>
<li>文件名里面注意可能手贱多打的空格，cocos不会帮你清掉</li>
<li>处理每一个需求的时候先考虑高可用性，而不是性能，毕竟手机越来越好，放弃低端机</li>
<li>ts文件只导出一个对象的时候，游戏可能报错，这时候在这个文件中随便改点东西保存就好了</li>
<li>依赖的路径一定要写对，最好全部用绝对路径，按住ctrl能打开的那种</li>
</ol>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><pre><code class="javascript">cc.director.loadScene(<span class="string">'场景名称'</span>);<span class="comment">//场景跳转</span>
cc.director.preloadScene(<span class="string">'场景名称'</span>);<span class="comment">//预加载场景</span>
cc.director.getScene();<span class="comment">//获取当前场景</span></code></pre>
<!--more-->



<h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><pre><code class="javascript"><span class="keyword">var</span> node = cc.find(<span class="string">"Canvas/bg"</span>);<span class="comment">//通过访问路径来获取节点</span>

<span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByName(<span class="string">'name'</span>);<span class="comment">//通过名字获取子节点</span>
node.getComponent(cc.Label).string = <span class="string">'abc'</span>;<span class="comment">//获取节点上的组件值</span>

<span class="keyword">var</span> a = cc.find(<span class="string">"Canvas/bg"</span>).getComponent(cc.Sprite);<span class="comment">//通过访问路径来获取节点，及获取该节点的指定组件</span>

<span class="keyword">this</span>.node .getChildByName(<span class="string">'节点名称'</span>).getComponent(cc.Label)<span class="comment">//通过节点名获取子节点，获取该节点指定组件</span>

<span class="keyword">var</span> a = <span class="keyword">this</span>.node;<span class="comment">//获取当前脚本所在的节点</span>
<span class="keyword">var</span> a = <span class="keyword">this</span>.node.parent;<span class="comment">//获取父节点</span>
<span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签获取子节点</span>
<span class="keyword">var</span> a = cc.find(<span class="string">"bg/score"</span>,<span class="keyword">this</span>.node);<span class="comment">//通过指定节点下的路径获取节点</span>

<span class="keyword">var</span> a = <span class="keyword">this</span>.node.children;<span class="comment">//获取所有子节点</span>
<span class="keyword">var</span> a = <span class="keyword">this</span>.node.childrenCount;<span class="comment">//获取子节点数量</span>
<span class="keyword">var</span> a = cc.director.getScene();<span class="comment">//获取场景主节点</span>

<span class="keyword">var</span> a = cc.instantiate(node);<span class="comment">//克隆节点</span>
<span class="keyword">this</span>.node.parent = cc.find(<span class="string">'Canvas'</span>);<span class="comment">//绑定父节点</span>
<span class="keyword">this</span>.node.addChild(nodeName,zIndex,tag);<span class="comment">//添加子节点,可设置层级和标签</span>
<span class="keyword">this</span>.node.removeChild(nodeName);<span class="comment">//通过名字移除子节点</span>
<span class="keyword">this</span>.node.removeChildByTag (nodeTag);<span class="comment">//通过标签移除子节点</span>
<span class="keyword">this</span>.node.destroy();<span class="comment">//销毁节点</span>
<span class="keyword">this</span>.node.isValid;<span class="comment">//判定节点是否可用</span>

<span class="keyword">this</span>.node.removeChild(newNode);<span class="comment">//移除节点中指定的子节点</span>
<span class="keyword">this</span>.node.removeChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签移除节点中指定的子节点</span>
<span class="keyword">this</span>.node.removeAllChildren();<span class="comment">//移除所有子节点</span>
<span class="keyword">this</span>.node.destroyAllChildren();<span class="comment">//销毁所有子节点</span>
<span class="keyword">this</span>.node.cleanup();<span class="comment">//停止所有正在播放的动作和计时器</span>
<span class="keyword">var</span> sprites = <span class="keyword">this</span>.node.getComponentsInChildren(cc.Label);<span class="comment">//递归查找自身及所有子节点中指定类型的组件</span></code></pre>
<h2 id="获取节点位置，设置节点"><a href="#获取节点位置，设置节点" class="headerlink" title="获取节点位置，设置节点"></a>获取节点位置，设置节点</h2><pre><code class="javascript"><span class="keyword">var</span> a = node.getPositionX();或 getPositionY() <span class="comment">//获取节点的X轴或Y轴坐标</span>
<span class="keyword">var</span> a = node.getScaleX(); 或getScaleY() <span class="comment">//获取节点的X轴或Y轴缩放比例</span>
node.x = <span class="number">100</span>;<span class="comment">//设置节点x轴坐标</span>
node.y = <span class="number">100</span>;<span class="comment">//设置节点y轴坐标</span>
node.setPosition(x,y); <span class="comment">//设置节点坐标</span>
node.rotation = <span class="number">90</span>; <span class="comment">//设置节点旋转角度</span>
node.scaleX = <span class="number">2</span>; <span class="comment">//设置节点x轴缩放倍数</span>
node.scaleY = <span class="number">2</span>; <span class="comment">//设置节点y轴缩放倍数</span>
node.setScale(<span class="number">2</span>); <span class="comment">//设置节点整体缩放倍数</span>
node.width = <span class="number">100</span>; <span class="comment">//设置节点宽度大小</span>
node.height = <span class="number">100</span>;  <span class="comment">//设置节点高度大小</span>
node.setContentSize(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置节点宽高尺寸大小</span>
node.anchorX = <span class="number">1</span>; <span class="comment">//设置节点x轴锚点坐标</span>
node.anchorY = <span class="number">0</span>; <span class="comment">//设置节点y轴锚点坐标</span>
node.setAnchorPoint(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//设置节点锚点坐标</span>
node.opacity = <span class="number">128</span>; <span class="comment">//设置节点透明度大小（0-255）</span>
node.setOpacity(<span class="number">20</span>); <span class="comment">//设置节点透明度（0~255）</span>
node.color = <span class="keyword">new</span> cc.color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>); <span class="comment">//设置节点颜色（R,G,B,透明度）</span>
<span class="keyword">if</span> (cc.isValid(<span class="keyword">this</span>.label.node) ) <span class="comment">//判定节点是否存在</span>
node.destroy(); <span class="comment">//销毁节点</span>
<span class="keyword">this</span>.cannons = [];
<span class="keyword">this</span>.cannons = node.getChildren(); <span class="comment">//获取所有子节点</span>
<span class="keyword">this</span>.cannons = node.getChildrenCount(); <span class="comment">//获取子节点数量</span>
node.active = <span class="literal">false</span>; <span class="comment">//关闭节点(隐藏节点)</span>
cc.game.addPersistRootNode(myNode); <span class="comment">//常驻节点（全局变量）</span>
cc.game.removePersistRootNode(myNode); <span class="comment">//取消常驻节点</span></code></pre>
<h2 id="动作操作"><a href="#动作操作" class="headerlink" title="动作操作"></a>动作操作</h2><pre><code>cc.show()//立即显示
cc.hide ()//立即隐藏
cc.toggleVisibility()//显隐切换
cc.fadeIn(1)//渐显效果
cc.fadeOut(1)//渐隐效果
cc.delayTime(1)//等待1秒
node.runAction(cc.moveTo(1,0,0)); //移动到当前节点（时间（s），X轴坐标，Y 轴坐标）
node.runAction(cc.scaleTo(1,0.7,0.8));//缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）
node.runAction(cc.rotateTo(1,160,160));//旋转到指定角度（时间（s），X轴角度，Y 轴角度）
node.runAction(cc.skewTo(1,5,-5));//变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）

node.runAction(cc.fadeTo(2,0));//变化当前节点的透明度（时间（s），透明度）

node.runAction(cc.tintTo(2,255,255,0));//变化当前节点颜色（时间，R,G,B）
node.stopAllActions();//停止所有动作
//自定义动作
var action = cc.moveTo(2, 100, 100);// 创建一个移动动作
node.runAction(action);// 执行动作
node.stopAction(action);// 停止一个动作

cc.sequence(action1,action2); //按顺序连续执行，先action1，后action2

cc.spawn(action1，action2); //同时执行，action1和action2一起执行

cc.repeatForever(cc.sequence(action1,action2)); //一直重复括号里的动作
</code></pre><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><pre><code>//只用1次的计时器,2秒后执行
        this.scheduleOnce(function(){
            //一条或多条执行语句  

        },2); //(function(){},时间（s）)

//每隔5秒执行1次
        this.schedule(function(){
            //一条或多条执行语句  

        },5);

//计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次）
        this.schedule(function(){
            //一条或多条执行语句

        },0.1,10,1); //(function(){},间隔时间，次数，多久后开始)

this.unscheduleAllCallbacks(this);//停止某组件的所有计时器

//自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）
var cb= function(){
    //do something
};
this.schedule(cb,1);//启动定时器
this.unschedule(cb);//取消定时器</code></pre><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><pre><code>(开始：&apos;touchstart&apos;，移动：&apos;touchmove&apos;，结束：&apos;touchend&apos;，取消：&apos;touchcancel&apos;)
node.on(&apos;touchstart&apos;,function(event){
    this.doSomething();
},this);  
var a = event.getID();//获取触点的ID
var a = event.getLocationX();//获取触摸点的坐标X
var b = event.getLocationY();//获取触摸点的坐标Y

cc.eventManager.addListener({
            event: cc.EventListener.KEYBOARD/TOUCH_ONE_BY_ONE,myfunction},self.node);

</code></pre><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><pre><code>//获得设备分辨率
var b = cc.director.getWinSizeInPixels()
var bx = b.width
var by = b.height

cc.view.getCanvasSize().width;//获得设备分辨率的宽度
cc.view.getCanvasSize().height;//获得设备分辨率的高度
cc.director.setDisplayStats(true);//显示帧数信息</code></pre><h2 id="音频控制"><a href="#音频控制" class="headerlink" title="音频控制"></a>音频控制</h2><pre><code>cc.audioEngine.playMusic(this.BGAudio,true);//播放音乐（true代表循环）
cc.audioEngine.stopMusic()//停止播放背景音乐
cc.audioEngine.playEffect(this.ClickAudio,false);//播放音效（false代表只播放一次）
cc.audioEngine.stopEffect(音效变量名);//停止指定音效（需要先把音效赋值给变量）
cc.audioEngine.AllEffects();//停止所有音效
cc.audioEngine.setMusicVolume(参数);  //设置背景音乐的音量（该参数范围是0到1）
cc.audioEngine.setEffectsVolume(参数);  //设置音效的音量（该参数范围是0到1）</code></pre><h2 id="存档操作"><a href="#存档操作" class="headerlink" title="存档操作"></a>存档操作</h2><pre><code>cc.sys.localStorage.setItem(&apos;存储标识名&apos;,变量名);//存储存档数据
var a = cc.sys.localStorage.getItem(&apos;存储标识名&apos;);//读取存档数据
cc.sys.localStorage.removeItem(&apos;存储标识名&apos;);//擦除存档数据
userData = {
    name: &apos;Tracer&apos;,
    level: 1,
    gold: 100
};
cc.sys.localStorage.setItem(&apos;userData&apos;, JSON.stringify(userData));//存取复杂对象数据
var userData = JSON.parse(cc.sys.localStorage.getItem(&apos;userData&apos;));//读取复杂对象数据</code></pre><h2 id="判断平台"><a href="#判断平台" class="headerlink" title="判断平台"></a>判断平台</h2><pre><code>cc.sys.isNative  //是否是本地
cc.sys.isBrowser  //是否是网页
cc.sys.isMobile  //是否是移动系统
cc.sys.platform  //正在运行的平台
cc.sys.language  //当前运行系统的语言
cc.sys.os  //当前正在运行的系统
cc.sys.OS_IOS  //是否是IOS系统
cc.sys.OS_ANDROID  //是否是android系统
cc.sys.OS_WINDOWS  //是否是windows系统
cc.sys.openURL(&apos;Http://www.baidu.com&apos;);  //打开网页</code></pre><h2 id="监听和发射事件"><a href="#监听和发射事件" class="headerlink" title="监听和发射事件"></a>监听和发射事件</h2><pre><code>this.node.pauseSystemEvents(true);//暂停节点系统事件
this.node.resumeSystemEvents(true);//恢复节点系统事件
this.node.targetOff(this);//移除所有注册事件

触摸监听：开始&apos;touchstart&apos;,移动&apos;touchmove&apos;,结束&apos;touchend&apos;,取消&apos;touchcancel&apos;
var pos = event.getLocation();//获取触摸点的坐标(包含X和Y)
var x = event.getLocationX();//获取触摸点的X坐标
var y = event.getLocationY();//获取触摸点的Y坐标
var a = event.getID();//获取触点的ID

鼠标监听：鼠标按下&apos;mousedown&apos;,移入节点&apos;mouseenter&apos;,节点中移动&apos;mousemove&apos;,移出节点&apos;mouseleave,&apos;松开鼠标&apos;mouseup&apos;
var a = event.getScrollY();//获取滚轮滚动的 Y 轴距离，只有滚动时才有效
var a = event.getLocation();//获取鼠标位置对象，对象包含 x 和 y 属性

输入框监听：获得焦点&apos;editing-did-began&apos;,文字变化&apos;text-changed&apos;,失去焦点&apos;editing-did-ended&apos;,按下回车&apos;editing-return&apos;

属性变化监听：位置&apos;position-changed&apos;,宽高 &apos;size-changed&apos;,旋转&apos;rotation-changed&apos;,缩放&apos;scale-changed&apos;

ScrollView控件监听：滚动中&apos;scrolling&apos;,停止滚动&apos;scroll-ended&apos;

用户自定义事件:
this.node.on(&apos;事件名&apos;,function,this);//注册监听
this.node.emit(&apos;事件名&apos;);//发送监听广播
this.node.off(&apos;事件名&apos;,function,this);//关闭监听

//注册带参数监听
this.node.on(&apos;事件名&apos;,function(event){

“具体方法函数内容”

},this);
//发送带参数的监听
this.node.emit(&apos;事件名&apos;,{id:1001});
cc.eventManager.addListener(listener, node);//添加事件
cc.eventManager.removeListener((listener);//移除事件
</code></pre><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><pre><code>cc.director.pause();//暂停
cc.director.resume();//继续
cc.director.end();//退出整个应用
cc.log(变量)  或 console.log(something);//输出想要的信息
let self = this;//锁定当前使用的this指向
node.getLocalZOrder();//层级获取
node.setLocalZOrder(1);//层级改变
cc.find(&apos;canvas/map&apos; + num)//读取带变量的路径
cc.sys.openURL(&apos;Http://www.baidu.com&apos;);//打开网页</code></pre><h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><pre><code>if (cc.screen.fullScreen()) {
     cc.screen.exitFullScreen();
}else cc.screen.requestFullScreen();</code></pre>
  </article>
</div>

  <div id="vcomments" class="session-wrapper" style="animation-duration: 2s;animation-delay: 0ms;width: 100%;margin-top:30px;"></div>
  
  <div class="license">
    <div class="txt">Powered by <a class="exturl" href="http://">Hexo</a></div>
    <div class="txt">Themes by <a class="exturl" href="http://">Sexy</a></div>
    <div class="txt">Welcome to White And Black Dream</div>
  </div>
</div>
<div id="toTop" hidden style="z-index:999;cursor:pointer;color:white;position:fixed;right:50px;bottom:50px;width:30px;height:30px;line-height:30px;text-align:center;background-color:black;border-radius:5%;">0</div>

  <script>
    var script = document.createElement('script');
    script.async = true;
    script.src="//unpkg.com/valine/dist/Valine.min.js"
    script.onload = function(){
      new Valine({
        el: '#vcomments',
        appId: 'WtelXWOsz6zEJvXGl3LToHOK-MdYXbMMI',
        appKey: 'B9X5fQyROCs2pFu7yt0NeLIP'
      })
      var el = document.getElementById('vcomments');
      if (el) {
        el.classList.add("animate__fadeIn");
        el.setAttribute("data-wow-duration","1s");
        el.classList.add("wow");
      }
    }
    document.body.appendChild(script)
  </script>

<script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js"></script>
 
<script src="/js/index.js"></script>

  


<div id="search_dialog" class="search_dialog" style="display:none;">
  <div class="mask" onclick="search_dialog.style.display='none'"></div>
  <div class="content">
    <input placeholder="搜索" class="input__search" id="local-search-input" type="text">
    <div class="input__content noscroll" id="input__content">
    <ul class="article-list"></ul>
    </div>
  </div>
</div>