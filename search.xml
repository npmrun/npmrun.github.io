<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>html中offsetTopclientTopscrollTopoffsetTop各属性介绍</title>
    <url>/2020/08/23/%E5%89%8D%E7%AB%AF/html%E4%B8%ADoffsetTopclientTopscrollTopoffsetTop%E5%90%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>主题：html中offsetTop,clientTop,scrollTop,offsetTop各属性介绍<br>概述：html中offsetTop,clientTop,scrollTop,offsetTop各属性介绍</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<p>HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth<br>scrollHeight: 获取对象的滚动高度。<br>scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离<br>scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离<br>scrollWidth:获取对象的滚动宽度<br>offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度<br>offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置<br>offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置<br>event.clientX 相对文档的水平座标<br>event.clientY 相对文档的垂直座标<br>event.offsetX 相对容器的水平坐标<br>event.offsetY 相对容器的垂直坐标<br>document.documentElement.scrollTop 垂直方向滚动的值<br>event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量</p>
<p>这里是javascript中建造迁移转变代码的常用属性<br>页可见区域宽： document.body.clientWidth;<br>网页可见区域高： document.body.clientHeight;<br>网页可见区域宽： document.body.offsetWidth  （包含边线的宽）;<br>网页可见区域高： document.body.offsetHeight （包含边线的宽）;<br>网页正文全文宽： document.body.scrollWidth;<br>网页正文全文高： document.body.scrollHeight;<br>网页被卷去的高： document.body.scrollTop;<br>网页被卷去的左： document.body.scrollLeft;<br>网页正文项目组上： window.screenTop;<br>网页正文项目组左： window.screenLeft;<br>屏幕辨别率的高： window.screen.height;<br>屏幕辨别率的宽： window.screen.width;</p>
<p>屏幕可用工作区高度： window.screen.availHeight;</p>
<p><img src="/static/%E5%89%8D%E7%AB%AF/html%E4%B8%ADoffsetTopclientTopscrollTopoffsetTop%E5%90%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D/images/20160810144543410.jpg" alt="img"></p>
<h2 id="1、offsetXXX"><a href="#1、offsetXXX" class="headerlink" title="1、offsetXXX"></a>1、offsetXXX</h2><p>假设 obj 为某个 HTML 控件。<br>obj.offsetTop 指 obj 间隔上方或上层控件的地位，整型，单位像素。<br>obj.offsetLeft 指 obj 间隔左方或上层控件的地位，整型，单位像素。<br>obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。<br>obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。</p>
<p>我们对前面提到的“上方或上层”与“左方或上层”控件作个申明。<br>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tool"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>“提交”按钮的 offsetTop 指“提交”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。<br>“重置”按钮的 offsetTop 指“重置”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。<br>“提交”按钮的 offsetLeft 指“提交”按钮距“tool”层左边框的间隔，因为距其左边比来的是 “tool” 层的左边框。<br>“重置”按钮的 offsetLeft 指“重置”按钮距“提交”按钮右边框的间隔，因为距其左边比来的是“提交”按钮的右边框。<br>以上属性在 FireFox 中也有效。<br>另 外：我们这里所说的是指 HTML 控件的属性值，并不是 document.body，document.body 的值在不合浏览器中有不合申明（实际上大多半景象是因为对 document.body 申明不合造成的，并不是因为对 offset 申明不合造成的）。</p>
<h2 id="2-offsetTop-与-style-top-的差别"><a href="#2-offsetTop-与-style-top-的差别" class="headerlink" title="2.offsetTop 与 style.top 的差别"></a>2.offsetTop 与 style.top 的差别</h2><p>我们知道 offsetTop 可以获得 HTML 元素间隔上方或外层元素的地位，style.top 也是可以的，二者的差别是：</p>
<ol>
<li>offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。</li>
<li>offsetTop 只读，而 style.top 可读写。</li>
<li>若是没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。</li>
</ol>
<p>offsetLeft 与 style.left、offsetWidth 与 style.width、offsetHeight 与 style.height 也是同样事理。</p>
<h2 id="3-clientHeight、offsetHeight和scrollHeight"><a href="#3-clientHeight、offsetHeight和scrollHeight" class="headerlink" title="3.clientHeight、offsetHeight和scrollHeight"></a>3.clientHeight、offsetHeight和scrollHeight</h2><p>我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。<br>这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。</p>
<p>clientHeight<br>对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。<br>offsetHeight<br>IE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。<br>NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。<br>scrollHeight<br>IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。<br>NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。</p>
<p>简单地说<br>clientHeight 就是透过浏览器看内容的这个区域高度。<br>NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。<br>IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。<br>同理<br>clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。<br>然则<br>FF 在不合的 DOCTYPE 中对 clientHeight 的申明不合， xhtml 1 trasitional 中则不是如上申明的。其它浏览器则不存在此题目。</p>
<h2 id="4-scrollTop、scrollLeft、scrollWidth、scrollHeight"><a href="#4-scrollTop、scrollLeft、scrollWidth、scrollHeight" class="headerlink" title="4.scrollTop、scrollLeft、scrollWidth、scrollHeight"></a>4.scrollTop、scrollLeft、scrollWidth、scrollHeight</h2><p>scrollTop 是“卷”起来的高度值，示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:100px;height:100px;background-color:＃FF0000;overflow:hidden;"</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:50px;height:300px;background-color:＃0000FF;"</span> <span class="attr">id</span>=<span class="string">"t"</span>&gt;</span>若是为 p 设置了 scrollTop，这些内容可能不会完全显示。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById（<span class="string">"p"</span>）;</span></span><br><span class="line">	p.scrollTop = 10;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为为外层元素 p 设置了 scrollTop，所以内层元素会向上卷。<br>scrollLeft 也是类似事理。<br>我们已经知道 offsetHeight 是自身元素的宽度。<br>而 scrollHeight 是内部元素的绝对宽度，包含内部元素的隐蔽的项目组。<br>上述中 p 的 scrollHeight 为 300，而 p 的 offsetHeight 为 100。<br>scrollWidth 也是类似事理。<br>IE 和 FireFox 周全支撑，而 Netscape 和 Opera 不支撑 scrollTop、scrollLeft（document.body 除外）。</p>
<h2 id="5-offsetTop、offsetLeft、offsetWidth、offsetHeight"><a href="#5-offsetTop、offsetLeft、offsetWidth、offsetHeight" class="headerlink" title="5.offsetTop、offsetLeft、offsetWidth、offsetHeight"></a>5.offsetTop、offsetLeft、offsetWidth、offsetHeight</h2><p>一向以来对offsetLeft，offsetTop，scrollLeft，scrollTop这几个办法很含混，花了一天的时候好好的进修了一下．得出了以下的成果：<br>1.offsetTop   :<br>当前对象到其上级层顶部的间隔.<br>不克不及对其进行赋值.设置对象到页面顶部的间隔请用style.top属性.<br>2.offsetLeft :<br>当前对象到其上级层左边的间隔.<br>不克不及对其进行赋值.设置对象到页面左部的间隔请用style.left属性.<br>3.offsetWidth :<br>当前对象的宽度.<br>与style.width属性的差别在于:如对象的宽度设定值为百分比宽度，则无论页面变大还是变小，style.width都返回此百分比，而offsetWidth则返回在不合页面中对象的宽度值而不是百分比值<br>4.offsetHeight :<br>与style.height属性的差别在于:如对象的宽度设定值为百分比高度，则无论页面变大还是变小，style.height都返回此百分比，而offsetHeight则返回在不合页面中对象的高度值而不是百分比值<br>5.offsetParent  :<br>当前对象的上级层对象.</p>
<p>若是对象是包含在一个DIV中时，此DIV不会被当做是此对象的上级层，（即对象的上级层会跳过DIV对象）上级层是Table时则不会有题目.<br>哄骗这个属性，可以获得当前对象在不合大小的页面中的绝对地位．</p>
<p>获得绝对地位脚本代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetPosition</span>（<span class="title">obj</span>）</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> top   = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>（obj != <span class="built_in">document</span>.body）</span><br><span class="line"> &#123;</span><br><span class="line">        left = obj.offsetLeft;</span><br><span class="line">        top   = obj.offsetTop;</span><br><span class="line">        obj = obj.offsetParent;</span><br><span class="line"> &#125;</span><br><span class="line"> alert（<span class="string">"Left Is : "</span> + left + <span class="string">"\r\n"</span> + <span class="string">"Top   Is : "</span> + top）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.scrollLeft :<br>对象的最左边到对象在当前窗口显示的局限内的左边的间隔．<br>便是在呈现了横向迁移转变条的景象下，迁移转变条拉动的间隔．<br>7.scrollTop<br>对象的最顶部到对象在当前窗口显示的局限内的顶边的间隔．<br>便是在呈现了纵向迁移转变条的景象下，迁移转变条拉动的间隔．</p>
<p>页面滚动的时候，元素的offsetXXX不变，要获取页面滚动距离用$(document).scrollTop()</p>
<p>转自：<a href="http://blog.csdn.net/fswan/article/details/17238933" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/fswan/article/details/17238933</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>讲一讲iconfont的三种实现方式以及自定义制作</title>
    <url>/2020/08/20/font/%E8%AE%B2%E4%B8%80%E8%AE%B2iconfont%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>主题：讲一讲iconfont的三种实现方式以及自定义制作<br>概述：iconfont的图标都挺好看的，但是最近我要自己搞一套UI库的话，不可避免的需要制作一些图标，因此就研究了一下具体的实现方式，统共的话有两种。</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<ol>
<li><code>unicode</code>：制作自定义字体文件并引入，当在网页上编写特殊的unicode编码的时候可以呈现对应的文字。</li>
<li><code>font-class</code>: 前一种的变种，不用再费力去看unicode编码，而是直接制作成一个css文件，采用将字符编码以伪类的方式定义在content中，能达到更上面类似的效果。</li>
<li><code>symbol</code>：这属于Svg了，svg可以设置symbol,然后通过use:xlink引用symbol的id从而实现svg的类似雪碧图效果。这样的方式支持彩色图标。</li>
</ol>
]]></content>
      <categories>
        <category>font</category>
      </categories>
  </entry>
  <entry>
    <title>获取元素各种宽高及页面宽高总结</title>
    <url>/2020/08/19/%E5%89%8D%E7%AB%AF/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%AE%BD%E9%AB%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>主题：获取元素各种宽高及页面宽高总结<br>概述：获取元素各种宽高及页面宽高总结</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<p>当网页并没有设置overflow:hidden而被卷曲时，卷曲的就是html，可以用document.documentElement.scrollTop获取被卷曲的高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line">    var a &#x3D; $(&quot;#div&quot;).width(),&#x2F;&#x2F;width()返回元素的宽高，不包括padding&#x2F;border&#x2F;margin</span><br><span class="line">        b &#x3D; $(&quot;#div&quot;).innerWidth(),&#x2F;&#x2F;innerWidth()返回元素的宽高 + padding</span><br><span class="line">        c &#x3D; $(&quot;#div&quot;).outerWidth(),&#x2F;&#x2F;outerWidth()返回元素的宽高 + padding + border</span><br><span class="line">        d &#x3D; $(&quot;#div&quot;).outerWidth(true);&#x2F;&#x2F;outerWidth(true)返回元素宽高 + padding + border + margin</span><br><span class="line">    console.log(a,b,c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取浏览器显示区域（可视区域）的高度 ：</strong><br><code>$(window).height();</code> </p>
<p><strong>获取浏览器显示区域（可视区域）的宽度 ：</strong><br><code>$(window).width();</code></p>
<p><strong>获取页面的文档高度</strong><br><code>$(document).height();</code></p>
<p><strong>获取页面的文档宽度</strong><br><code>$(document).width();</code></p>
<p><strong>浏览器当前窗口文档body的高度</strong><br><code>$(document.body).height();</code> </p>
<p><strong>浏览器当前窗口文档body的宽度</strong><br><code>$(document.body).width();</code> </p>
<p><strong>获取滚动条到顶部的垂直高度(即网页被卷上去的高度)</strong><br><code>$(document).scrollTop();</code></p>
<p><strong>获取滚动条到左边的垂直宽度</strong><br><code>$(document).scrollLeft();</code>   </p>
<p><strong>获取或设置元素的宽度</strong><br><code>$(obj).width();</code></p>
<p><strong>获取或设置元素的高度</strong> </p>
<p><code>$(obj).height();</code></p>
<p><strong>某个元素的上边界到body最顶部的距离</strong><br><code>obj.offset().top;</code>（在元素的包含元素不含滚动条的情况下） </p>
<p><strong>某个元素的左边界到body最左边的距离</strong><br><code>obj.offset().left;</code>（在元素的包含元素不含滚动条的情况下）  </p>
<p><strong>返回当前元素的上边界到它的包含元素的上边界的偏移量</strong><br><code>obj.offset().top</code>（在元素的包含元素含滚动条的情况下）  </p>
<p><strong>返回当前元素的左边界到它的包含元素的左边界的偏移量</strong><br><code>obj.offset().left</code>（在元素的包含元素含滚动条的情况下）  </p>
<blockquote>
<p><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external nofollow noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p>
<p><a href="https://blog.csdn.net/gs6511/article/details/53900761" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/gs6511/article/details/53900761</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1106529" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1106529</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>scrollWidth,clientWidth,offsetWidth的区别</title>
    <url>/2020/08/19/%E5%89%8D%E7%AB%AF/scrollWidth,clientWidth,offsetWidth%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>主题：scrollWidth,clientWidth,offsetWidth的区别<br>概述：scrollWidth,clientWidth,offsetWidth的区别</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<ul>
<li><code>scrollWidth</code>：对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大。</li>
<li><code>clientWidth</code>：对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变。</li>
<li><code>offsetWidth</code>：对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变。</li>
</ul>
<p>示例展示：</p>
<p>该demo就在页面中放一个textarea元素，采用默认宽高显示。</p>
<p>情况1：</p>
<p>元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。</p>
<p>scrollWidth=clientWidth，两者皆为内容可视区的宽度。</p>
<p>offsetWidth为元素的实际宽度。</p>
<p><img src="/static/%E5%89%8D%E7%AB%AF/scrollWidth,clientWidth,offsetWidth%E7%9A%84%E5%8C%BA%E5%88%AB/images/dd81f5ea107d46c3a87894408db35355.png" alt="img"></p>
<p>情况2：</p>
<p>元素的内容超过可视区，滚动条出现和可用的情况下。</p>
<p>scrollWidth&gt;clientWidth。</p>
<p>scrollWidth为实际内容的宽度。</p>
<p>clientWidth是内容可视区的宽度。</p>
<p>offsetWidth是元素的实际宽度。</p>
<p><img src="/static/%E5%89%8D%E7%AB%AF/scrollWidth,clientWidth,offsetWidth%E7%9A%84%E5%8C%BA%E5%88%AB/images/32163def3f0742049681f4a7b258e28f.png" alt="img"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>ui组件库之图标的思考</title>
    <url>/2020/08/19/ui/ui%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B9%8B%E5%9B%BE%E6%A0%87%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<blockquote>
<p>主题：ui组件库之图标的思考<br>概述：在制作<code>xyx-ui</code>的时候，个人认为这是比较重要的一环，借此机会，将深入了解一下。</p>
</blockquote>
<!--正文-->
<a id="more"></a>]]></content>
      <categories>
        <category>ui</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始搭建一个rollup库</title>
    <url>/2020/08/17/rollup/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AArollup%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>主题：从零开始搭建一个rollup库<br>概述：从零开始搭建一个rollup库</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>全局安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global rollup</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2>]]></content>
      <categories>
        <category>rollup</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3.0使用@font-face自定义字体</title>
    <url>/2020/08/15/font/CSS3.0%E4%BD%BF%E7%94%A8@font-face%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<blockquote>
<p>主题：CSS3.0使用@font-face自定义字体<br>概述：CSS3.0使用@font-face自定义字体</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;css3.0 @font-face&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;index.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;myblog&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: &#39;汉仪雪君体简&#39;;</span><br><span class="line">    src:url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.ttf&#39;) format(&#39;truetype&#39;)，</span><br><span class="line">	    url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.eot&#39;) format(&#39;embedded-opentype&#39;)，</span><br><span class="line">	    url(&#39;.&#x2F;fonts&#x2F;汉仪雪君体简.woff&#39;) format(&#39;truetype&#39;);</span><br><span class="line">    font-weight: normal;</span><br><span class="line">    font-style: normal;</span><br><span class="line">&#125;</span><br><span class="line">h1&#123;</span><br><span class="line">    font-family:&quot;汉仪雪君体简&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如以上代码所示，@font-face的语法规则如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &lt;YourWebFontName&gt;;</span><br><span class="line">  src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;</span><br><span class="line">  [font-weight: &lt;weight&gt;];</span><br><span class="line">  [font-style: &lt;style&gt;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li><p><code>YourWebFontName</code>:此值为你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的<code>font-family</code>。如<code>font-family</code>: ‘汉仪雪君体简’;</p>
</li>
<li><p><code>source</code>:此值指的是你自定义的字体的存放路径；</p>
</li>
<li><p><code>format</code>：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：</p>
<p><code>truetype,opentype,truetype-aat,embedded-opentype,avg</code>等。不同浏览器对字体格式的支持不同，一般来说至少需要<code>.woff,.eot</code>两种格式字体，甚至还需要<code>.svg</code>等字体达到更多种浏览版本的支持。</p>
</li>
<li><p><code>weight</code>和<code>style:weight</code>定义字体是否为粗体，style主要定义字体样式，如斜体。</p>
</li>
<li><p>下载字体：<a href="https://www.google.com/fonts" target="_blank" rel="external nofollow noopener noreferrer">https://www.google.com/fonts</a><br> 获取@font-face所需字体格式：<a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="external nofollow noopener noreferrer">https://www.fontsquirrel.com/tools/webfont-generator</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>font</category>
      </categories>
  </entry>
  <entry>
    <title>vue中进行多层组件监听</title>
    <url>/2020/08/14/vue/vue/vue%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%A4%9A%E5%B1%82%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<blockquote>
<p>主题：vue中使用v-bind=”$attrs”和v-on=”$listeners”进行多层组件监听<br>概述：</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<blockquote>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/ce8ca875c337" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/ce8ca875c337</a></p>
<p><a href="https://www.cnblogs.com/jin-zhe/p/13099416.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/jin-zhe/p/13099416.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>有关storybookreadme的在vue解析docs标签的问题</title>
    <url>/2020/08/13/storybook/%E6%9C%89%E5%85%B3storybookreadme%E7%9A%84%E5%9C%A8vue%E8%A7%A3%E6%9E%90docss%E6%A0%87%E7%AD%BE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>主题：<br>概述：</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>我是根据<code>storybook-readme</code>的文档进行配置的，类似于下面这样 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">    use: &quot;vue-docgen-loader&quot;,</span><br><span class="line">    enforce: &quot;post&quot;,</span><br><span class="line">  &#125;);</span><br><span class="line">  config.module.rules.push(&#123;</span><br><span class="line">    resourceQuery: &#x2F;blockType&#x3D;docs&#x2F;,</span><br><span class="line">    use: [&#39;storybook-readme&#x2F;vue&#x2F;docs-loader&#39;,&#39;html-loader&#39;, &#39;markdown-loader&#39;],</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>然后就出问题了：</p>
<p><img src="/static/storybook/%E6%9C%89%E5%85%B3storybookreadme%E7%9A%84%E5%9C%A8vue%E8%A7%A3%E6%9E%90docss%E6%A0%87%E7%AD%BE%E7%9A%84%E9%97%AE%E9%A2%98/images/image-20200813224956262.png" alt="image-20200813224956262"></p>
<p>经过长时间的尝试，发现这两个错误，在<code>Component.options.__docs</code>后面竟然没有引号，直接接了一串<code>docs</code>的内容，因此我找到那个<code>docs-loader</code>进行修改，修改之后类似于下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; function (source, map) &#123;</span><br><span class="line">  this.callback(null, &#39;module.exports &#x3D; function(Component) &#123;Component.options.__docs &#x3D; &quot;&#39; + source + &#39;&quot;&#125;&#39;, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后又除了下面这个问题：</p>
<p><img src="/static/storybook/%E6%9C%89%E5%85%B3storybookreadme%E7%9A%84%E5%9C%A8vue%E8%A7%A3%E6%9E%90docss%E6%A0%87%E7%AD%BE%E7%9A%84%E9%97%AE%E9%A2%98/images/image-20200813225100254.png" alt="image-20200813225100254"></p>
<p>百度得知好像是双引号不能回车，因此我们把加的双引号换车反引号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; function (source, map) &#123;</span><br><span class="line">  console.log(source)</span><br><span class="line">  this.callback(null, &#39;module.exports &#x3D; function(Component) &#123;Component.options.__docs &#x3D; &#96;&#39; + source + &#39;&#96;&#125;&#39;, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过打印<code>source</code>你会发现又多了一小撮东西，这是因为这个<code>source</code>本质上是一个js文件，需要导入才行，不过我也不知道怎么把字符串当js导入，因此我就直接把<code>html-loader</code>去掉了，这样就行了。能够使用<code>docs</code>标签了。</p>
]]></content>
      <categories>
        <category>storybook</category>
      </categories>
  </entry>
  <entry>
    <title>有关构建一个简单的vuex模式，而不引入整个vuex</title>
    <url>/2020/08/06/vue/vue/%E6%9C%89%E5%85%B3%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84vuex%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%BC%95%E5%85%A5%E6%95%B4%E4%B8%AAvuex/</url>
    <content><![CDATA[<blockquote>
<p>主题：Vue-observable<br>概述：让一个对象可响应。Vue 内部会用它来处理 <code>data</code> 函数返回的对象。返回的对象可以直接用于<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="external nofollow noopener noreferrer">渲染函数</a>和<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="external nofollow noopener noreferrer">计算属性</a>内，并且会在发生变更时触发相应的            更新。也可以作为最小化的跨组件状态存储器</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<p>简单使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$store&#x3D; Vue.observable(&#123; </span><br><span class="line">	state: &#123;</span><br><span class="line">		isLoc: false,</span><br><span class="line">		addr: &quot;未定位&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">	setLoction(&#123;loc,isLoc&#125;)&#123;</span><br><span class="line">		this.state.isLoc &#x3D; isLoc;</span><br><span class="line">		this.state.addr &#x3D; loc</span><br><span class="line">		if(isLoc)&#123;</span><br><span class="line">			localStorage.setItem(&quot;cccity&quot;,loc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 之后，直接使用就行：</span><br><span class="line">	&#x2F;&#x2F;计算方法</span><br><span class="line">	computed:&#123;</span><br><span class="line">		addr()&#123;</span><br><span class="line">			return this.$store.state.addr</span><br><span class="line">		&#125;,</span><br><span class="line">		haveCity()&#123;</span><br><span class="line">			return this.$store.state.isLoc</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	执行方法：</span><br><span class="line">	this.$store.setLoction(&#123;loc:simple[1],isLoc:true&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>TweenMax动画教程</title>
    <url>/2020/07/19/animation/TweenMax%E5%8A%A8%E7%94%BB%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>主题：<a href="https://www.tweenmax.com.cn/api/tweenmax/" target="_blank" rel="external nofollow noopener noreferrer">TweenMax</a>动画教程<br>概述：主要进行对<a href="https://www.tweenmax.com.cn/api/tweenmax/" target="_blank" rel="external nofollow noopener noreferrer">TweenMax</a>的学习</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul>
<li><p>第一步，自然是引入TweenMax库了，这个官方可以找到。</p>
</li>
<li><p>最基础的使用，我们制作一个逐渐隐藏的红色方块吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box1&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;lib&#x2F;TweenMax.min.js&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    	TweenLite.fromTo(&#39;.box1&#39;, 5, &#123;opacity:1&#125;, &#123;opacity:0&#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同时请注意文档中的这一句话：例子中使用的CSS属性动画（opacity、x等）需要CSSPlugin插件支持，此插件包含在<code>TweenMax.min.js</code>中。如果你使用<code>TweenLite.min.js</code>，需另外加载<code>CSSPlugin.min.js</code>。<strong>不是全量引入的话需要额外的css插件支持</strong></p>
</blockquote>
</li>
</ul>
<h3 id="TweenLite和TweenMax区别"><a href="#TweenLite和TweenMax区别" class="headerlink" title="TweenLite和TweenMax区别"></a>TweenLite和TweenMax区别</h3><p>TweenMax和TweenLite差不多，后者是轻量级的，不包含插件，如果需要对应的特性需要引入不同的插件库。这也就导致这一些API的不同，不过这两者大部分的API是一样的。</p>
<h2 id="扩展使用"><a href="#扩展使用" class="headerlink" title="扩展使用"></a>扩展使用</h2><h3 id="暂停与恢复"><a href="#暂停与恢复" class="headerlink" title="暂停与恢复"></a>暂停与恢复</h3><p>我们采用实例的方式一步步的学习。经过上面的示例，我们扩展一下，尝试写出一个控制按钮，按一下播放，再按一下暂停。这就需要一个简单的流程：</p>
<ol>
<li>动画是否再执行中，如果是，暂停</li>
<li>动画是否停止了，如果是，开始</li>
</ol>
<p>我们可以看到<a href="https://www.tweenmax.com.cn/api/tweenmax/" target="_blank" rel="external nofollow noopener noreferrer">这里</a>的文档,里面有简要的列出一些API，但是我貌似没有看到具体的用法，我们猜测一下:</p>
<ol>
<li><code>TweenLite</code>或<code>TweenMax</code>写好链式语法后会返回自身的实例，我们可以用它来调用具体方法。</li>
<li>在<strong>TweenLite 和TweenMax 共有方法</strong>中，我们可以看到我们需要的几个函数：<code>pause()</code>,<code>paused()</code>,<code>resume()</code>这三个是属于暂停的方法，通过英文名大概可以得知，<code>paused()</code>是判断是否暂停的</li>
</ol>
<p>因此：以下的代码就顺利成章了，可以实验以下是否得到想要的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">   &lt;button onclick&#x3D;&quot;toggle()&quot;&gt;播放&lt;&#x2F;button&gt;</span><br><span class="line">   &lt;script src&#x3D;&quot;..&#x2F;lib&#x2F;TweenMax.min.js&quot;&gt; &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       let anim1 &#x3D; TweenLite.fromTo(&#39;.box1&#39;, 5, &#123;opacity:1&#125;, &#123;opacity:0&#125;);</span><br><span class="line">       function toggle()&#123;</span><br><span class="line">           if (anim1.paused()) &#123;</span><br><span class="line">               anim1.resume()</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               anim1.pause()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意的是这里是暂停与恢复，不能判断是否播放完毕，如果判断播放完毕可以用<code>anim1.progress()</code>判断是否播放到1了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function toggle()&#123;</span><br><span class="line">          if (anim1.paused()&amp;&amp;anim1.progress()&lt;1) &#123;</span><br><span class="line">              anim1.resume()</span><br><span class="line">          &#125;else if (anim1.progress()&#x3D;&#x3D;1) &#123;</span><br><span class="line">              anim1.restart()</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              anim1.pause()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>isActive</strong>和<strong>paused</strong>的区别暂时不知道，貌似都是判断是否停止的，暂停之后paused是true,isActive是false,</p>
<p>动画开始之后paused是false,isActive是true,动画停止之后paused是false,isActive是false,</p>
</blockquote>
]]></content>
      <categories>
        <category>animation</category>
      </categories>
  </entry>
  <entry>
    <title>有关vmware中主机访问虚拟机端口</title>
    <url>/2020/07/12/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
<p>主题：主要是为了试一下nginx配置rtmp的网络推拉流<br>概述：了解以下虚拟机与主机的端口映射基本操作</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<ol>
<li><p>确认你的虚拟机的网络适配器是<code>NAT</code></p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231430886.png" alt="image-20200712231430886"></p>
</li>
<li><p>当然，我们首先打开<code>VMware</code>中的虚拟机，我用的是<code>elementoryOS中文版</code></p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712230538875.png" alt="image-20200712230538875"></p>
</li>
<li><p>打开终端，输入<code>ifconfig -a</code>查看你的IP地址，当你看到下面图的时候，不要慌，点击如下图那个图标，会弹出一个页面，里面可能会有你的ip地址显示，没有的话只能自己先去安装一个网络库了。</p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712230718842.png" alt="终端"></p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712230738863.png" alt="网络"></p>
</li>
<li><p>由于我想要转发是nginx配置的页面，所以先查看以下nginx是否启动了，然后确保你需要转发的端口是真实有效的，如图，我配置过了 nginx，因此就会显示一个网页，我需要的就是转发这个端口</p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231056969.png" alt="image-20200712231056969"></p>
</li>
<li><p>这个时候我们回到<code>vmware</code>上,我们打开，<code>编辑--&gt;虚拟网络地址编辑器</code></p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231252798.png" alt="image-20200712231252798"></p>
</li>
<li><p>如上图，我们必须要网络管理员的特权，因此点击那个更改设置，这个窗口就会重新加载，这个时候就可以编辑了。这个时候看图步骤操作：</p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231708242.png" alt="image-20200712231708242"></p>
<p>​    <img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231805058.png" alt="image-20200712231805058"></p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712231815534.png" alt="image-20200712231815534"></p>
</li>
<li><p>这个时候就需要填你自己的数据了：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>不知道的谢我推荐的</th>
</tr>
</thead>
<tbody><tr>
<td>主机端口</td>
<td>表示你在你PC上需要用到那个端口跟你虚拟机的映射</td>
<td>12345</td>
</tr>
<tr>
<td>类型</td>
<td>直接默认TCP就行了</td>
<td>TCP</td>
</tr>
<tr>
<td>虚拟机IP地址</td>
<td>这里填你上面查到的虚拟机的IP地址</td>
<td>192.168.x.x(x可不能乱填)</td>
</tr>
<tr>
<td>端口</td>
<td>填nginx中需要映射的端口</td>
<td>9606（我的虚拟机里配置过的网页端口）</td>
</tr>
<tr>
<td>描述</td>
<td>随意</td>
<td></td>
</tr>
</tbody></table>
<p>写玩点确认就行了，回到上一页的时候确认一下，没问题就表示OK了。</p>
</li>
<li><p>测试，OK，主机上能访问了</p>
<p><img src="/static/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%9C%89%E5%85%B3vmware%E4%B8%AD%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3/images/image-20200712232327323.png" alt="image-20200712232327323"></p>
</li>
</ol>
<blockquote>
<p>注意：</p>
<p>你挂起了或者关闭了虚拟机就没用了。</p>
</blockquote>
<p>更高级的用法请参见参考资料中的。</p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/u012268339/article/details/61204801" target="_blank" rel="external nofollow noopener noreferrer"><em>局域网访问电脑中VMware虚拟机</em></a></p>
</blockquote>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>关于移动端h5页面不能滑动问题的解决办法</title>
    <url>/2020/07/08/%E5%89%8D%E7%AB%AF/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E9%A1%B5%E9%9D%A2%E4%B8%8D%E8%83%BD%E6%BB%91%E5%8A%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>主题：<br>概述：</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<p>有的人说如果我写很多个p标签不写任何样式看能不能滑动，如果能滑动说明是样式的原因，要是也不能滑动那就应该是js的原因，是有一定的道理的，但是先别忘了看一下你的html或body是不是加了<code>height：100%；overflow：hidden</code></p>
<ol>
<li><p>下面分先说css的问题，主要排查<code>overflow：hidden</code>；</p>
<p>检查也有一定的顺序，检查超出高度的标签是否用了<code>overflow：hidden</code>；最好先检查<code>html</code>或<code>body</code>是不是加了<code>height：100%</code>；<code>overflow：hidden</code>；然后再看包裹在最外边的元素是否加了<code>overflow：hidden</code>;</p>
</li>
<li><p>再说下js方面的问题，主要是有在<code>touchstart</code>、<code>touchmove</code>或<code>touchend</code>等事件中的阻止默认事件的原因</p>
<p>例如：</p>
</li>
</ol>
<pre><code>$(&quot;#myCarousel&quot;).on(&quot;touchstart&quot;, function (e) {          
       e.preventDefault();   

                 startX = e.originalEvent.changedTouches[0].pageX,
                startY = e.originalEvent.changedTouches[0].pageY;

      })；</code></pre><p>   这种代码其中<code>e.preventDefault();</code>会阻止掉默认的滚动行为。</p>
<ol start="3">
<li><p>我的情况是能上滑，不能下滑经过排查，之前是写了<code>\* {margin:0;padding: 0;touch-action: none;}</code>代码，是为了解决一个报错的问题，但是在结合<code>mescroll</code>之后，排查问题发现是这里的问题，后来这样改就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.list&#123;</span><br><span class="line">	*&#123;</span><br><span class="line">       touch-action: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是将手指滑动的区域的<code>touch-action</code>设置为<code>auto</code>.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax简述</title>
    <url>/2020/07/05/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/Ajax%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>主题：Ajax的使用与意义<br>概述：为了加深基础的理解，能够在不借助库的情况下实现不同方式的请求才能够更好的理解那些异步请求库的工作流程</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<p><strong>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong></p>
<p>如上，我们不需要重新加载页面就能够更新页面的数据，AJAX的出现意味着颠覆了传统的开发模式，使得页面更加的流畅，用户体验能够做到极致。</p>
<p>其中，<strong>XMLHttpRequest 是 AJAX 的基础。</strong></p>
<h2 id="什么是XMLHttpRequest-呢？"><a href="#什么是XMLHttpRequest-呢？" class="headerlink" title="什么是XMLHttpRequest 呢？"></a>什么是XMLHttpRequest 呢？</h2><p>所有现代浏览器均支持 <code>XMLHttpRequest</code> 对象（IE5 和 IE6 使用 <code>ActiveXObject</code>）。</p>
<p><code>XMLHttpRequest</code> 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h2 id="发送一个请求"><a href="#发送一个请求" class="headerlink" title="发送一个请求"></a>发送一个请求</h2><p>我们需要分几步实现：</p>
<ol>
<li>创建 XMLHttpRequest 对象</li>
<li>确定请求方式以及传递的数据</li>
<li>接收数据的递回做下一步的处理</li>
</ol>
<h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><p>由于老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象，为了做部分的兼容，我们可以做以下的方式的创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h3><p>现在我们可以配置需要发送给服务器数据的东西了。</p>
<p>一般来说，只需要下面这两个就能够发送了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>open(method,url,async)</code></td>
<td align="left">规定请求的类型、URL 以及是否异步处理请求。<em>method</em>：请求的类型；<code>GET</code> 或 <code>POST</code><em>url</em>：文件在服务器上的位置<code>async：true</code>（异步）或 false（同步）</td>
</tr>
<tr>
<td align="left"><code>send(string)</code></td>
<td align="left">将请求发送到服务器。<em>string</em>：仅用于 POST 请求</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>GET 还是 POST？</strong></p>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<p><strong>GET</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"demo_get.asp"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p><strong>POST</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"demo_post.asp"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>设置请求头</strong></p>
<p>请求头也是一个必须要配置的东西：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"ajax_test.asp"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xmlhttp.send(<span class="string">"fname=Bill&amp;lname=Gates"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>setRequestHeader(header,value)</code></td>
<td align="left">向请求添加 HTTP 头。<em>header</em>: 规定头的名称<em>value</em>: 规定头的值</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="有关同步与异步的分别"><a href="#有关同步与异步的分别" class="headerlink" title="有关同步与异步的分别"></a>有关同步与异步的分别</h4><p><strong><code>Async = true</code></strong>(异步)</p>
<p>当使用 <code>async=true</code> 时，请规定在响应处于 <code>onreadystatechange</code> 事件中的就绪状态时执行的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p><strong><code>Async = false</code></strong>（同步）</p>
<p>如需使用 <code>async=false</code>，请将 open() 方法中的第三个参数改为 false：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br></pre></td></tr></table></figure>

<p>我们不推荐使用<code>async=false</code>，但是对于一些小型的请求，也是可以的。</p>
<p>请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>
<p><strong>注释：</strong>当您使用<code>async=false</code> 时，请不要编写 <code>onreadystatechange</code> 函数 - 把代码放到 send() 语句后面即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br></pre></td></tr></table></figure>

<h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>如需获得来自服务器的响应，请使用 <code>XMLHttpRequest</code> 对象的 <code>responseText</code> 或 <code>responseXML</code> 属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>responseText</code></td>
<td align="left">获得字符串形式的响应数据。</td>
</tr>
<tr>
<td align="left"><code>responseXML</code></td>
<td align="left">获得 XML 形式的响应数据。</td>
</tr>
</tbody></table>
<p><strong><code>responseText</code>属性</strong></p>
<p>如果来自服务器的响应并非 XML，请使用 <code>responseText</code> 属性。</p>
<p><code>responseText</code> 属性返回字符串形式的响应，因此您可以这样使用：</p>
<p><strong><code>responseXML</code> 属性</strong></p>
<p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 <code>responseXML</code>属性：</p>
<p>请求 <a href="https://www.w3school.com.cn/example/xmle/books.xml" target="_blank" rel="external nofollow noopener noreferrer">books.xml</a> 文件，并解析响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlDoc=xmlhttp.responseXML;</span><br><span class="line">txt=<span class="string">""</span>;</span><br><span class="line">x=xmlDoc.getElementsByTagName(<span class="string">"ARTIST"</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  txt=txt + x[i].childNodes[<span class="number">0</span>].nodeValue + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=txt;</span><br></pre></td></tr></table></figure>

<h3 id="附录（onreadystatechange-事件）"><a href="#附录（onreadystatechange-事件）" class="headerlink" title="附录（onreadystatechange 事件）"></a>附录（<code>onreadystatechange</code> 事件）</h3><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p>
<p>每当 <code>readyState</code> 改变时，就会触发 <code>onreadystatechange</code> 事件。</p>
<p><code>readyState</code> 属性存有 <code>XMLHttpRequest</code> 的状态信息。</p>
<p>下面是 <code>XMLHttpRequest</code> 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>onreadystatechange</code></td>
<td align="left">存储函数（或函数名），每当 <code>readyState</code> 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td align="left"><code>readyState</code></td>
<td align="left">存有 <code>XMLHttpRequest</code> 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">200: “OK”404: 未找到页面</td>
</tr>
</tbody></table>
<p>在 <code>onreadystatechange</code> 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>
<p>当 <code>readyState</code> 等于 4 且状态为 200 时，表示响应已就绪：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange&#x3D;function()</span><br><span class="line">  &#123;</span><br><span class="line">  if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)</span><br><span class="line">    &#123;</span><br><span class="line">    document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注释：</strong><code>onreadystatechange</code> 事件被触发 5 次（0 - 4），对应着 <code>readyState</code>的每个变化。</p>
</blockquote>
<blockquote>
<p>来源：</p>
<p><a href="https://www.w3school.com.cn/ajax/ajax_intro.asp" target="_blank" rel="external nofollow noopener noreferrer">w3school</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>网络相关</category>
      </categories>
  </entry>
  <entry>
    <title>html的加载事件DOMContentLoaded和load</title>
    <url>/2020/07/04/%E5%89%8D%E7%AB%AF/%E7%9F%A5%E8%AF%86/html%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6DOMContentLoaded%E5%92%8Cload/</url>
    <content><![CDATA[<blockquote>
<p>主题：html的加载事件DOMContentLoaded和load<br>概述：有关html的加载事件的粗略整理，用于后面快速理解</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<h2 id="页面加载方式"><a href="#页面加载方式" class="headerlink" title="页面加载方式"></a>页面加载方式</h2><ol>
<li>解析HTML结构。</li>
<li>加载并解析外部脚本。</li>
<li>DOM树构建完成，执行脚本。//DOMInteractive –&gt; DOMContentLoaded</li>
<li>加载图片、样式表文件等外部文件。</li>
<li>页面加载完毕。//window.onload</li>
</ol>
<h2 id="涉及到的事件"><a href="#涉及到的事件" class="headerlink" title="涉及到的事件"></a>涉及到的事件</h2><ol>
<li>window.onload:<br>当页面全部加载完成（包括所有资源）</li>
<li>document.onload:<br>当整个html文档加载的时候就触发了，也就是在body元素加载之前就开始执行了</li>
<li>DOMContentLoaded:<br>当页面的DOM树解析好并且需要等待JS执行完才触发<br>DOMContentLoaded事件不直接等待CSS文件、图片的加载完成</li>
<li>onreadytstatechange:<br>当对象状态变更时触发这个事件，一旦document的readyState属性发生变化就会触发</li>
</ol>
<h5 id="DOMContentLoaded：dom内容加载完毕"><a href="#DOMContentLoaded：dom内容加载完毕" class="headerlink" title="DOMContentLoaded：dom内容加载完毕"></a>DOMContentLoaded：dom内容加载完毕</h5><p>当输入一个URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发DOMContentLoaded事件。而这段时间就是HTML文档被加载和解析完成。</p>
<h5 id="load页面所有内容（包括图像、脚本文件、CSS-文件等）对象已加载时触发；"><a href="#load页面所有内容（包括图像、脚本文件、CSS-文件等）对象已加载时触发；" class="headerlink" title="load页面所有内容（包括图像、脚本文件、CSS 文件等）对象已加载时触发；"></a>load页面所有内容（包括图像、脚本文件、CSS 文件等）对象已加载时触发；</h5><p>1）支持DOMContentLoaded事件的，就使用DOMContentLoaded事件；<br>2）IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。</p>
<p>3)  更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(“left”);</p>
<p> 可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function ready(fn)&#123;</span><br><span class="line">    if(document.addEventListener) &#123;</span><br><span class="line">        document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;</span><br><span class="line">            document.removeEventListener(&#39;DOMContentLoaded&#39;,arguments.callee, false);</span><br><span class="line">            fn();</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 如果IE</span><br><span class="line">    else if(document.attachEvent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 确保当页面是在iframe中加载时，事件依旧会被安全触发</span><br><span class="line">        document.attachEvent(&#39;onreadystatechange&#39;, function() &#123;</span><br><span class="line">            if(document.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">                document.detachEvent(&#39;onreadystatechange&#39;, arguments.callee);</span><br><span class="line">                fn();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕</span><br><span class="line">        if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                document.documentElement.doScroll(&#39;left&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(error)&#123;</span><br><span class="line">                return setTimeout(arguments.callee, 20);</span><br><span class="line">            &#125;;</span><br><span class="line">            fn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="document-ready的实现"><a href="#document-ready的实现" class="headerlink" title="document.ready的实现"></a>document.ready的实现</h2><p>作用：监控dom是否加载完毕，dom加载完毕时及资源加载之前触发 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;jquery中默认为document对象</span><br><span class="line">$().ready(function()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转载：</p>
<p><a href="https://blog.csdn.net/u011700203/article/details/47656857" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/u011700203/article/details/47656857</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>知识</category>
      </categories>
  </entry>
  <entry>
    <title>scss主题切换功能</title>
    <url>/2020/05/14/%E5%89%8D%E7%AB%AF/scss%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>主题：scss主题切换功能<br>概述：该文章主要为了实现css切换主题的功能，这只是一种方法，别的方式也可以实现。</p>
</blockquote>
<!--正文-->
<a id="more"></a>



<p>结构类似下面这样：</p>
<p><img src="/static/%E5%89%8D%E7%AB%AF/scss%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/images/image-20200514140159247.png" alt="image-20200514140159247"></p>
<p><strong><code>index.html</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot;</span><br><span class="line">          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;index.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body data-theme&#x3D;&quot;light&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app-home&quot;&gt;</span><br><span class="line">        dsakdjsafs</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>index.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &#39;.&#x2F;_themeify.scss&#39;;</span><br><span class="line"></span><br><span class="line">.app-home &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  @include themeify &#123;</span><br><span class="line">    color: themed(&#39;text-color-primary&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_themeify.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &#39;.&#x2F;_themes.scss&#39;;</span><br><span class="line"></span><br><span class="line">@mixin themeify &#123;</span><br><span class="line">  @each $theme-name, $theme-map in $themes &#123;</span><br><span class="line">    $theme-map: $theme-map !global;</span><br><span class="line">    body[data-theme&#x3D;#&#123;$theme-name&#125;] &amp; &#123;</span><br><span class="line">      @content;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@function themed($key) &#123;</span><br><span class="line">  @return map-get($theme-map, $key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_themes.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$themes: (</span><br><span class="line">        default: (</span><br><span class="line">          &#x2F;* font-size *&#x2F;</span><br><span class="line">                font-size-default: 14px,</span><br><span class="line">                font-size-lg: 16px,</span><br><span class="line">                font-size-sm: 12px,</span><br><span class="line">                color-white: #FFF,</span><br><span class="line">          &#x2F;* Color *&#x2F;</span><br><span class="line">                color-success: #13CE66,</span><br><span class="line">                color-error: #FF4949,</span><br><span class="line">                color-warning: #FFC82C,</span><br><span class="line">                color-info: #78A4FA,</span><br><span class="line">          &#x2F;&#x2F; Text Color</span><br><span class="line">                text-color-primary: #dc2b34,</span><br><span class="line">                text-color-white: #ffffff,</span><br><span class="line">                text-color-black: #000000,</span><br><span class="line">                text-color-default: #4a4a4a,</span><br><span class="line">                text-color-placeholder: #C9C9C9,</span><br><span class="line">                text-color-disabled: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Background Color</span><br><span class="line">                bg-color-primary: #d91720,</span><br><span class="line">                bg-color-primary-light: #b51d29,</span><br><span class="line">                bg-color-white: #ffffff,</span><br><span class="line">                bg-color-grey: #F7F7F7,</span><br><span class="line">                bg-color-light: #ECF5FD,</span><br><span class="line">                bg-color-verifycode: #cfcfcf,</span><br><span class="line">          &#x2F;&#x2F; Border Color</span><br><span class="line">                borer-color-primary: #e64644,</span><br><span class="line">                borer-color-primary-light: #dc2b34,</span><br><span class="line">                borer-color-white: #ffffff,</span><br><span class="line">                borer-color-default: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Link Color</span><br><span class="line">                link-color-primary: #d91721,</span><br><span class="line">                link-color-primary-light: #b51d29,</span><br><span class="line">                link-color: #6190E8,</span><br><span class="line">                link-color-light: #79A1EB,</span><br><span class="line">                link-color-disabled: #BFBFBF,</span><br><span class="line">          &#x2F;&#x2F; Icon Color</span><br><span class="line">                icon-color-base: #CCC,</span><br><span class="line">        ),</span><br><span class="line">        light: (</span><br><span class="line">          &#x2F;* font-size *&#x2F;</span><br><span class="line">                font-size-default: 14px,</span><br><span class="line">                font-size-lg: 16px,</span><br><span class="line">                font-size-sm: 12px,</span><br><span class="line">                color-white: #FFF,</span><br><span class="line">          &#x2F;* Color *&#x2F;</span><br><span class="line">                color-success: #13CE66,</span><br><span class="line">                color-error: #FF4949,</span><br><span class="line">                color-warning: #FFC82C,</span><br><span class="line">                color-info: #78A4FA,</span><br><span class="line">          &#x2F;&#x2F; Text Color</span><br><span class="line">                text-color-primary: #78A4FA,</span><br><span class="line">                text-color-white: #ffffff,</span><br><span class="line">                text-color-black: #000000,</span><br><span class="line">                text-color-default: #4a4a4a,</span><br><span class="line">                text-color-placeholder: #C9C9C9,</span><br><span class="line">                text-color-disabled: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Background Color</span><br><span class="line">                bg-color-primary: #d91720,</span><br><span class="line">                bg-color-primary-light: #b51d29,</span><br><span class="line">                bg-color-white: #ffffff,</span><br><span class="line">                bg-color-grey: #F7F7F7,</span><br><span class="line">                bg-color-light: #ECF5FD,</span><br><span class="line">                bg-color-verifycode: #cfcfcf,</span><br><span class="line">          &#x2F;&#x2F; Border Color</span><br><span class="line">                borer-color-primary: #e64644,</span><br><span class="line">                borer-color-primary-light: #dc2b34,</span><br><span class="line">                borer-color-white: #ffffff,</span><br><span class="line">                borer-color-default: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Link Color</span><br><span class="line">                link-color-primary: #d91721,</span><br><span class="line">                link-color-primary-light: #b51d29,</span><br><span class="line">                link-color: #6190E8,</span><br><span class="line">                link-color-light: #79A1EB,</span><br><span class="line">                link-color-disabled: #BFBFBF,</span><br><span class="line">          &#x2F;&#x2F; Icon Color</span><br><span class="line">                icon-color-base: #CCC,</span><br><span class="line">        ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面只需要切换<code>data-theme</code>的名字就行了，一共内置了两套主题。</p>
</blockquote>
<p><strong>编译过后的css</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@charset &quot;UTF-8&quot;;</span><br><span class="line">.app-home &#123;</span><br><span class="line">  font-size: 18px; &#125;</span><br><span class="line">  body[data-theme&#x3D;default] .app-home &#123;</span><br><span class="line">    color: #dc2b34; &#125;</span><br><span class="line">  body[data-theme&#x3D;light] .app-home &#123;</span><br><span class="line">    color: #78A4FA; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出就是做了两套兼容而已。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2020/04/23/%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<blockquote>
<p>主题：内网穿透<br>概述：这是工具推荐类文章，推荐的是<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="external nofollow noopener noreferrer">frp</a>库，经由国人开发，主要是把内网的网页进行映射，使得可以再公网访问，前提是有一个公网服务器。</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>公网服务器 IP 140.140.192.192</p>
</li>
<li><p>域名 <a href="http://www.good.com" target="_blank" rel="external nofollow noopener noreferrer">www.good.com</a> 解析至上面的服务器</p>
</li>
<li><p>本地运行的服务</p>
</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>利用<code>frp</code>，可以实现任何人都可以通过配置的端口如 <code>www.good.com:7001</code> 访问我本机的<code>hbuilder</code>网页应用</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>服务器和内网本机分别<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="external nofollow noopener noreferrer">下载</a>对应系统平台的frp，<br>这里ubuntu服务器需要下载linux_arm_64， mac本机是frp_0.32.1_windows_amd64.zip</p>
<ul>
<li><p>先配服务端</p>
<p>linux_arm_64文件包在服务器上下载解压，编辑 <code>frps.ini</code>， 然后启动 <code>./frps -c ./frps.ini</code>，放后台启动命令 <code>nohup ./frps -c ./frps.ini &amp;</code>，配置修改如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span> <span class="meta"># 自己设定的frp服务端端口</span></span><br><span class="line"><span class="meta"># 客户端定义的端口,自己设定的http访问端口，通过这里就能访问内网了</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置客户端</p>
<p>frp_0.32.1_windows_amd64.zip文件包解压，编辑 <code>frpc.ini</code>,然后启动 <code>frpc -c ./frpc.ini</code>,可以自己放在后台执行，配置如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">server_addr = <span class="number">140.140</span><span class="number">.192</span><span class="number">.192</span>   <span class="meta">#公网服务器ip frp服务端的ip（也就是外网主机的IP）</span></span><br><span class="line">server_port = <span class="number">7000</span>                       <span class="meta">#与服务端bind_port一致 </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#公网访问内部web服务器以http方式</span></span><br><span class="line">[<span class="meta">web</span>]</span><br><span class="line">type = http         <span class="meta">#访问协议</span></span><br><span class="line">local_port = <span class="number">4200</span>   <span class="meta">#内网web服务的端口号</span></span><br><span class="line">custom_domains = www.good.com   <span class="meta">#所绑定的公网服务器域名，一级、二级域名都可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="配置服务端面板"><a href="#配置服务端面板" class="headerlink" title="配置服务端面板"></a>配置服务端面板</h4><p>修改服务端的 <code>frps.ini</code>， 添加 dashboard 信息，重启启动后可以通过<code>140.140.192.192:7500</code>打开控制面板</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line"><span class="meta"># 客户端定义的端口</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">dashboard_port = <span class="number">7002</span></span><br><span class="line"><span class="meta"># dashboard 用户名密码，默认都为 admin</span></span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后访问<a href="http://www.good.top:7001/" target="_blank" rel="external nofollow noopener noreferrer">http://www.good.top:7001/</a> 就行了</p>
<p>可以配置一个naginx的网址，指向本地的7001端口就可以不带端口访问了</p>
</blockquote>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p> Invalid Host header</p>
</blockquote>
<p>如果本机的web项目用了webpack server(目前vue cli, react cli, angular 本地开发用的都是这个) , 这个是webpack server的安全策略，如果是angular项目，需要在启动配置中加上 <code>--disable-host-check</code> 类似 <code>ng serve --open --host $IP --port $PORT --disable-host-check</code>。</p>
<p>如果是<code>uniapp</code>项目，进行如下配置：</p>
<p><img src="/static/%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/images/image-20200423140150925.png" alt="image-20200423140150925"></p>
<blockquote>
<p>参考文档</p>
<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81</a></p>
<p><a href="https://www.jianshu.com/p/d579c2156311" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/d579c2156311</a></p>
<p><a href="https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/" target="_blank" rel="external nofollow noopener noreferrer">https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/</a></p>
<p><a href="https://www.it72.com/12580-1.htm" target="_blank" rel="external nofollow noopener noreferrer">https://www.it72.com/12580-1.htm</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1572324" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1572324</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git本地多账号配置</title>
    <url>/2020/04/20/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li><code>git环境</code></li>
</ul>
<a id="more"></a>

<h3 id="生成第一个账号的密钥"><a href="#生成第一个账号的密钥" class="headerlink" title="生成第一个账号的密钥"></a>生成第一个账号的密钥</h3><p>先确保你已经有多个git账号（如：一个github的账号、一个码云的账号、…）。</p>
<p>在Git Bash Here的控制台里输入：</p>
<p><code>git config --global user.name &quot;你的名称&quot;</code></p>
<p><code>git config --global user.email &quot;你的邮箱&quot;</code></p>
<p>这里的邮箱是你申请git账号时的邮箱，不报错就是正确的，继续往下走</p>
<p>输入 <code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>  回车，再连续3次回车见下图：</p>
<p>此时看下图中有一行提示：<code>Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub</code></p>
<p>到该路径（<code>C/Users/xxx/.ssh</code>）可以看见两个文件：id_rsa、id_rsa.pub 。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110415002.png" alt="image-20200420110415002"></p>
<p>把密钥添加进git账号中：</p>
<p>用编辑器打开<code>id_rsa.pub</code>，推荐使用Notepad++，不要使用记事本打开，因为记事本的默认编码不是utf-8，拷贝里面的全部内容，登录你其中一个git 账号，例如:我登录github平台，后添加公钥里把它添加进去，公钥名称可以随便写。提交保存，输入你的github登录密码并提示添加成功。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110453118.png" alt="image-20200420110453118"></p>
<p>测试刚才添加的github密钥是否成功：</p>
<p>在Git Bash Here中输入 ssh <a href="mailto:git@github.com" rel="external nofollow noopener noreferrer" target="_blank">git@github.com</a>  回车</p>
<p>会出现一个提示，输入 yes 回车，可以看见一个successfully的提示信息，说明添加成功，可以使用了。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110505960.png" alt="image-20200420110505960"></p>
<h3 id="生成第二个账号的密钥"><a href="#生成第二个账号的密钥" class="headerlink" title="生成第二个账号的密钥"></a>生成第二个账号的密钥</h3><p>重复上面的步骤，那用户名和邮箱改成另一个账号的</p>
<blockquote>
<p>注：在输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>的第一个选择存储路径的时候请自行改成自己的自定义名字，例如输入：smalldemons，这个时候一般是在<code>C/Users/xxx/.ssh</code>目录下就会又增加两个文件：smalldemons、smalldemons.pub,如果没看到的话，一般是在命令行打开的当前目录下，把这两个文件复制过去就行了</p>
</blockquote>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110803461.png" alt="image-20200420110803461"></p>
<p>添加多账号配置文件config（<code>C/Users/xxx/.ssh</code>）：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110903542.png" alt="image-20200420110903542"></p>
<p>里面的代码 如下：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111043623.png" alt="image-20200420111043623"></p>
<blockquote>
<p>Host 配置的别名</p>
<p>HostName  填写改git账号的官网地址</p>
<p>IdentityFile：是对应的密钥文件</p>
<p>如此就可以在多个账号间切换使用了</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这样的话只能使用<code>git@github.com:xxxx/xxxx.git</code>的方式拉取或推送代码，另一种我试的是失效的，得再看一下。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111258450.png" alt="image-20200420111258450"></p>
<p>切换<code>npmrun</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line"># 上面两步不是必须的</span><br><span class="line">git@npmrun.github.com:npmrun&#x2F;npmrun.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@npmrun.github.com,我加了npmrun,对应的是config里面的Host</span><br></pre></td></tr></table></figure>

<p>切换<code>1549469775</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line"># 上面两步不是必须的</span><br><span class="line">git@1549469775.github.com:npmrun&#x2F;1549469775.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@1549469775.github.com,我加了1549469775,对应的是config里面的Host</span><br></pre></td></tr></table></figure>



<blockquote>
<p>查看自己的用户名和邮箱地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">$ git config user.email</span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>注意别把两个账号的ssh密钥都放一个账号里去了，会出问题，我就是有一个放一起了，结果两个配置访问的都是一个账号下的仓库了。</p>
</blockquote>
<blockquote>
<p>此时由于你的id_rsa存放的是1549469775的密钥，于是在使用<code>ssh git@github.com</code>发送的是默认的这个密钥，如果要修改默认登录的账号，可以在<code>config</code>文件里添加如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;#npmrun Git账号</span><br><span class="line">&gt;Host github.com</span><br><span class="line">&gt;HostName github.com</span><br><span class="line">&gt;User git</span><br><span class="line">&gt;IdentityFile ~&#x2F;.ssh&#x2F;npmrun</span><br></pre></td></tr></table></figure>

<p>就是把<code>github.com</code>默认指向npmrun这个账号</p>
</blockquote>
<blockquote>
<p>之后可以自己添加对应的git的，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#poorman账号,这是我自建的git网站</span><br><span class="line">Host git.poorman.top</span><br><span class="line">HostName git.poorman.top</span><br><span class="line">User xxx  #</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;poorman</span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>有关别的账号使用默认配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;## 加在最下面</span><br><span class="line">&gt;Host *</span><br><span class="line">&gt;User git</span><br><span class="line">&gt;IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/fanbi/p/7825746.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/fanbi/p/7825746.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>cocos creator常用api</title>
    <url>/2020/04/07/cocos/cocos-creator%E5%B8%B8%E7%94%A8api/</url>
    <content><![CDATA[<blockquote>
<p>主题：cocos creator常用api<br>概述：收集cocos creator常用的函数，防止老年痴呆，记得东西太多会使自己混乱，写下来才是王道。</p>
</blockquote>
<!--正文-->
<a id="more"></a>

<blockquote>
<p><a href="https://blog.csdn.net/sotmwhat/article/details/93884076" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/sotmwhat/article/details/93884076</a></p>
</blockquote>
<h3 id="给自己的忠告"><a href="#给自己的忠告" class="headerlink" title="给自己的忠告"></a>给自己的忠告</h3><ol>
<li>异步读取的必须要判断节点或者组件是否isValid可用</li>
<li>龙骨动画节点中途中断并重新执行，异步的情况下并不会触发结束，导致后面的代码无法执行，处理时开一个定时器当作判断，而不是用动画结束判断</li>
<li>文件名就算在不同文件夹最好也不要一样</li>
<li>文件名里面注意可能手贱多打的空格，cocos不会帮你清掉</li>
<li>处理每一个需求的时候先考虑高可用性，而不是性能，毕竟手机越来越好，放弃低端机</li>
<li>ts文件只导出一个对象的时候，游戏可能报错，这时候在这个文件中随便改点东西保存就好了</li>
<li>依赖的路径一定要写对，最好全部用绝对路径，按住ctrl能打开的那种</li>
</ol>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cc.director.loadScene(<span class="string">'场景名称'</span>);<span class="comment">//场景跳转</span></span><br><span class="line">cc.director.preloadScene(<span class="string">'场景名称'</span>);<span class="comment">//预加载场景</span></span><br><span class="line">cc.director.getScene();<span class="comment">//获取当前场景</span></span><br></pre></td></tr></table></figure>

<!--more-->



<h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = cc.find(<span class="string">"Canvas/bg"</span>);<span class="comment">//通过访问路径来获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByName(<span class="string">'name'</span>);<span class="comment">//通过名字获取子节点</span></span><br><span class="line">node.getComponent(cc.Label).string = <span class="string">'abc'</span>;<span class="comment">//获取节点上的组件值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"Canvas/bg"</span>).getComponent(cc.Sprite);<span class="comment">//通过访问路径来获取节点，及获取该节点的指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node .getChildByName(<span class="string">'节点名称'</span>).getComponent(cc.Label)<span class="comment">//通过节点名获取子节点，获取该节点指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node;<span class="comment">//获取当前脚本所在的节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.parent;<span class="comment">//获取父节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签获取子节点</span></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"bg/score"</span>,<span class="keyword">this</span>.node);<span class="comment">//通过指定节点下的路径获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.children;<span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.childrenCount;<span class="comment">//获取子节点数量</span></span><br><span class="line"><span class="keyword">var</span> a = cc.director.getScene();<span class="comment">//获取场景主节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.instantiate(node);<span class="comment">//克隆节点</span></span><br><span class="line"><span class="keyword">this</span>.node.parent = cc.find(<span class="string">'Canvas'</span>);<span class="comment">//绑定父节点</span></span><br><span class="line"><span class="keyword">this</span>.node.addChild(nodeName,zIndex,tag);<span class="comment">//添加子节点,可设置层级和标签</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(nodeName);<span class="comment">//通过名字移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag (nodeTag);<span class="comment">//通过标签移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroy();<span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.node.isValid;<span class="comment">//判定节点是否可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(newNode);<span class="comment">//移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeAllChildren();<span class="comment">//移除所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroyAllChildren();<span class="comment">//销毁所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.cleanup();<span class="comment">//停止所有正在播放的动作和计时器</span></span><br><span class="line"><span class="keyword">var</span> sprites = <span class="keyword">this</span>.node.getComponentsInChildren(cc.Label);<span class="comment">//递归查找自身及所有子节点中指定类型的组件</span></span><br></pre></td></tr></table></figure>

<h2 id="获取节点位置，设置节点"><a href="#获取节点位置，设置节点" class="headerlink" title="获取节点位置，设置节点"></a>获取节点位置，设置节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = node.getPositionX();或 getPositionY() <span class="comment">//获取节点的X轴或Y轴坐标</span></span><br><span class="line"><span class="keyword">var</span> a = node.getScaleX(); 或getScaleY() <span class="comment">//获取节点的X轴或Y轴缩放比例</span></span><br><span class="line">node.x = <span class="number">100</span>;<span class="comment">//设置节点x轴坐标</span></span><br><span class="line">node.y = <span class="number">100</span>;<span class="comment">//设置节点y轴坐标</span></span><br><span class="line">node.setPosition(x,y); <span class="comment">//设置节点坐标</span></span><br><span class="line">node.rotation = <span class="number">90</span>; <span class="comment">//设置节点旋转角度</span></span><br><span class="line">node.scaleX = <span class="number">2</span>; <span class="comment">//设置节点x轴缩放倍数</span></span><br><span class="line">node.scaleY = <span class="number">2</span>; <span class="comment">//设置节点y轴缩放倍数</span></span><br><span class="line">node.setScale(<span class="number">2</span>); <span class="comment">//设置节点整体缩放倍数</span></span><br><span class="line">node.width = <span class="number">100</span>; <span class="comment">//设置节点宽度大小</span></span><br><span class="line">node.height = <span class="number">100</span>;  <span class="comment">//设置节点高度大小</span></span><br><span class="line">node.setContentSize(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置节点宽高尺寸大小</span></span><br><span class="line">node.anchorX = <span class="number">1</span>; <span class="comment">//设置节点x轴锚点坐标</span></span><br><span class="line">node.anchorY = <span class="number">0</span>; <span class="comment">//设置节点y轴锚点坐标</span></span><br><span class="line">node.setAnchorPoint(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//设置节点锚点坐标</span></span><br><span class="line">node.opacity = <span class="number">128</span>; <span class="comment">//设置节点透明度大小（0-255）</span></span><br><span class="line">node.setOpacity(<span class="number">20</span>); <span class="comment">//设置节点透明度（0~255）</span></span><br><span class="line">node.color = <span class="keyword">new</span> cc.color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>); <span class="comment">//设置节点颜色（R,G,B,透明度）</span></span><br><span class="line"><span class="keyword">if</span> (cc.isValid(<span class="keyword">this</span>.label.node) ) <span class="comment">//判定节点是否存在</span></span><br><span class="line">node.destroy(); <span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = [];</span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildren(); <span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildrenCount(); <span class="comment">//获取子节点数量</span></span><br><span class="line">node.active = <span class="literal">false</span>; <span class="comment">//关闭节点(隐藏节点)</span></span><br><span class="line">cc.game.addPersistRootNode(myNode); <span class="comment">//常驻节点（全局变量）</span></span><br><span class="line">cc.game.removePersistRootNode(myNode); <span class="comment">//取消常驻节点</span></span><br></pre></td></tr></table></figure>

<h2 id="动作操作"><a href="#动作操作" class="headerlink" title="动作操作"></a>动作操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.show()&#x2F;&#x2F;立即显示</span><br><span class="line">cc.hide ()&#x2F;&#x2F;立即隐藏</span><br><span class="line">cc.toggleVisibility()&#x2F;&#x2F;显隐切换</span><br><span class="line">cc.fadeIn(1)&#x2F;&#x2F;渐显效果</span><br><span class="line">cc.fadeOut(1)&#x2F;&#x2F;渐隐效果</span><br><span class="line">cc.delayTime(1)&#x2F;&#x2F;等待1秒</span><br><span class="line">node.runAction(cc.moveTo(1,0,0)); &#x2F;&#x2F;移动到当前节点（时间（s），X轴坐标，Y 轴坐标）</span><br><span class="line">node.runAction(cc.scaleTo(1,0.7,0.8));&#x2F;&#x2F;缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）</span><br><span class="line">node.runAction(cc.rotateTo(1,160,160));&#x2F;&#x2F;旋转到指定角度（时间（s），X轴角度，Y 轴角度）</span><br><span class="line">node.runAction(cc.skewTo(1,5,-5));&#x2F;&#x2F;变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.fadeTo(2,0));&#x2F;&#x2F;变化当前节点的透明度（时间（s），透明度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.tintTo(2,255,255,0));&#x2F;&#x2F;变化当前节点颜色（时间，R,G,B）</span><br><span class="line">node.stopAllActions();&#x2F;&#x2F;停止所有动作</span><br><span class="line">&#x2F;&#x2F;自定义动作</span><br><span class="line">var action &#x3D; cc.moveTo(2, 100, 100);&#x2F;&#x2F; 创建一个移动动作</span><br><span class="line">node.runAction(action);&#x2F;&#x2F; 执行动作</span><br><span class="line">node.stopAction(action);&#x2F;&#x2F; 停止一个动作</span><br><span class="line"></span><br><span class="line">cc.sequence(action1,action2); &#x2F;&#x2F;按顺序连续执行，先action1，后action2</span><br><span class="line"></span><br><span class="line">cc.spawn(action1，action2); &#x2F;&#x2F;同时执行，action1和action2一起执行</span><br><span class="line"></span><br><span class="line">cc.repeatForever(cc.sequence(action1,action2)); &#x2F;&#x2F;一直重复括号里的动作</span><br></pre></td></tr></table></figure>

<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只用1次的计时器,2秒后执行</span><br><span class="line">        this.scheduleOnce(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,2); &#x2F;&#x2F;(function()&#123;&#125;,时间（s）)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每隔5秒执行1次</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次）</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句</span><br><span class="line"></span><br><span class="line">        &#125;,0.1,10,1); &#x2F;&#x2F;(function()&#123;&#125;,间隔时间，次数，多久后开始)</span><br><span class="line"></span><br><span class="line">this.unscheduleAllCallbacks(this);&#x2F;&#x2F;停止某组件的所有计时器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）</span><br><span class="line">var cb&#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;;</span><br><span class="line">this.schedule(cb,1);&#x2F;&#x2F;启动定时器</span><br><span class="line">this.unschedule(cb);&#x2F;&#x2F;取消定时器</span><br></pre></td></tr></table></figure>

<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(开始：&#39;touchstart&#39;，移动：&#39;touchmove&#39;，结束：&#39;touchend&#39;，取消：&#39;touchcancel&#39;)</span><br><span class="line">node.on(&#39;touchstart&#39;,function(event)&#123;</span><br><span class="line">    this.doSomething();</span><br><span class="line">&#125;,this);  </span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line">var a &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的坐标X</span><br><span class="line">var b &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的坐标Y</span><br><span class="line"></span><br><span class="line">cc.eventManager.addListener(&#123;</span><br><span class="line">            event: cc.EventListener.KEYBOARD&#x2F;TOUCH_ONE_BY_ONE,myfunction&#125;,self.node);</span><br></pre></td></tr></table></figure>

<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获得设备分辨率</span><br><span class="line">var b &#x3D; cc.director.getWinSizeInPixels()</span><br><span class="line">var bx &#x3D; b.width</span><br><span class="line">var by &#x3D; b.height</span><br><span class="line"></span><br><span class="line">cc.view.getCanvasSize().width;&#x2F;&#x2F;获得设备分辨率的宽度</span><br><span class="line">cc.view.getCanvasSize().height;&#x2F;&#x2F;获得设备分辨率的高度</span><br><span class="line">cc.director.setDisplayStats(true);&#x2F;&#x2F;显示帧数信息</span><br></pre></td></tr></table></figure>

<h2 id="音频控制"><a href="#音频控制" class="headerlink" title="音频控制"></a>音频控制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.audioEngine.playMusic(this.BGAudio,true);&#x2F;&#x2F;播放音乐（true代表循环）</span><br><span class="line">cc.audioEngine.stopMusic()&#x2F;&#x2F;停止播放背景音乐</span><br><span class="line">cc.audioEngine.playEffect(this.ClickAudio,false);&#x2F;&#x2F;播放音效（false代表只播放一次）</span><br><span class="line">cc.audioEngine.stopEffect(音效变量名);&#x2F;&#x2F;停止指定音效（需要先把音效赋值给变量）</span><br><span class="line">cc.audioEngine.AllEffects();&#x2F;&#x2F;停止所有音效</span><br><span class="line">cc.audioEngine.setMusicVolume(参数);  &#x2F;&#x2F;设置背景音乐的音量（该参数范围是0到1）</span><br><span class="line">cc.audioEngine.setEffectsVolume(参数);  &#x2F;&#x2F;设置音效的音量（该参数范围是0到1）</span><br></pre></td></tr></table></figure>

<h2 id="存档操作"><a href="#存档操作" class="headerlink" title="存档操作"></a>存档操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.localStorage.setItem(&#39;存储标识名&#39;,变量名);&#x2F;&#x2F;存储存档数据</span><br><span class="line">var a &#x3D; cc.sys.localStorage.getItem(&#39;存储标识名&#39;);&#x2F;&#x2F;读取存档数据</span><br><span class="line">cc.sys.localStorage.removeItem(&#39;存储标识名&#39;);&#x2F;&#x2F;擦除存档数据</span><br><span class="line">userData &#x3D; &#123;</span><br><span class="line">    name: &#39;Tracer&#39;,</span><br><span class="line">    level: 1,</span><br><span class="line">    gold: 100</span><br><span class="line">&#125;;</span><br><span class="line">cc.sys.localStorage.setItem(&#39;userData&#39;, JSON.stringify(userData));&#x2F;&#x2F;存取复杂对象数据</span><br><span class="line">var userData &#x3D; JSON.parse(cc.sys.localStorage.getItem(&#39;userData&#39;));&#x2F;&#x2F;读取复杂对象数据</span><br></pre></td></tr></table></figure>

<h2 id="判断平台"><a href="#判断平台" class="headerlink" title="判断平台"></a>判断平台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.isNative  &#x2F;&#x2F;是否是本地</span><br><span class="line">cc.sys.isBrowser  &#x2F;&#x2F;是否是网页</span><br><span class="line">cc.sys.isMobile  &#x2F;&#x2F;是否是移动系统</span><br><span class="line">cc.sys.platform  &#x2F;&#x2F;正在运行的平台</span><br><span class="line">cc.sys.language  &#x2F;&#x2F;当前运行系统的语言</span><br><span class="line">cc.sys.os  &#x2F;&#x2F;当前正在运行的系统</span><br><span class="line">cc.sys.OS_IOS  &#x2F;&#x2F;是否是IOS系统</span><br><span class="line">cc.sys.OS_ANDROID  &#x2F;&#x2F;是否是android系统</span><br><span class="line">cc.sys.OS_WINDOWS  &#x2F;&#x2F;是否是windows系统</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);  &#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>

<h2 id="监听和发射事件"><a href="#监听和发射事件" class="headerlink" title="监听和发射事件"></a>监听和发射事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.node.pauseSystemEvents(true);&#x2F;&#x2F;暂停节点系统事件</span><br><span class="line">this.node.resumeSystemEvents(true);&#x2F;&#x2F;恢复节点系统事件</span><br><span class="line">this.node.targetOff(this);&#x2F;&#x2F;移除所有注册事件</span><br><span class="line"></span><br><span class="line">触摸监听：开始&#39;touchstart&#39;,移动&#39;touchmove&#39;,结束&#39;touchend&#39;,取消&#39;touchcancel&#39;</span><br><span class="line">var pos &#x3D; event.getLocation();&#x2F;&#x2F;获取触摸点的坐标(包含X和Y)</span><br><span class="line">var x &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的X坐标</span><br><span class="line">var y &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的Y坐标</span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line"></span><br><span class="line">鼠标监听：鼠标按下&#39;mousedown&#39;,移入节点&#39;mouseenter&#39;,节点中移动&#39;mousemove&#39;,移出节点&#39;mouseleave,&#39;松开鼠标&#39;mouseup&#39;</span><br><span class="line">var a &#x3D; event.getScrollY();&#x2F;&#x2F;获取滚轮滚动的 Y 轴距离，只有滚动时才有效</span><br><span class="line">var a &#x3D; event.getLocation();&#x2F;&#x2F;获取鼠标位置对象，对象包含 x 和 y 属性</span><br><span class="line"></span><br><span class="line">输入框监听：获得焦点&#39;editing-did-began&#39;,文字变化&#39;text-changed&#39;,失去焦点&#39;editing-did-ended&#39;,按下回车&#39;editing-return&#39;</span><br><span class="line"></span><br><span class="line">属性变化监听：位置&#39;position-changed&#39;,宽高 &#39;size-changed&#39;,旋转&#39;rotation-changed&#39;,缩放&#39;scale-changed&#39;</span><br><span class="line"></span><br><span class="line">ScrollView控件监听：滚动中&#39;scrolling&#39;,停止滚动&#39;scroll-ended&#39;</span><br><span class="line"></span><br><span class="line">用户自定义事件:</span><br><span class="line">this.node.on(&#39;事件名&#39;,function,this);&#x2F;&#x2F;注册监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;);&#x2F;&#x2F;发送监听广播</span><br><span class="line">this.node.off(&#39;事件名&#39;,function,this);&#x2F;&#x2F;关闭监听</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册带参数监听</span><br><span class="line">this.node.on(&#39;事件名&#39;,function(event)&#123;</span><br><span class="line"></span><br><span class="line">“具体方法函数内容”</span><br><span class="line"></span><br><span class="line">&#125;,this);</span><br><span class="line">&#x2F;&#x2F;发送带参数的监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;,&#123;id:1001&#125;);</span><br><span class="line">cc.eventManager.addListener(listener, node);&#x2F;&#x2F;添加事件</span><br><span class="line">cc.eventManager.removeListener((listener);&#x2F;&#x2F;移除事件</span><br></pre></td></tr></table></figure>

<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.director.pause();&#x2F;&#x2F;暂停</span><br><span class="line">cc.director.resume();&#x2F;&#x2F;继续</span><br><span class="line">cc.director.end();&#x2F;&#x2F;退出整个应用</span><br><span class="line">cc.log(变量)  或 console.log(something);&#x2F;&#x2F;输出想要的信息</span><br><span class="line">let self &#x3D; this;&#x2F;&#x2F;锁定当前使用的this指向</span><br><span class="line">node.getLocalZOrder();&#x2F;&#x2F;层级获取</span><br><span class="line">node.setLocalZOrder(1);&#x2F;&#x2F;层级改变</span><br><span class="line">cc.find(&#39;canvas&#x2F;map&#39; + num)&#x2F;&#x2F;读取带变量的路径</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);&#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>

<h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cc.screen.fullScreen()) &#123;</span><br><span class="line">     cc.screen.exitFullScreen();</span><br><span class="line">&#125;else cc.screen.requestFullScreen();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
</search>
