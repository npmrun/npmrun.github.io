<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网址</title>
    <url>/2020/05/07/%E6%94%B6%E9%9B%86/%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p><a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">中文文档</a></p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><a href="http://css.cuishifeng.cn/index.html" target="_blank" rel="noopener">参考手册</a></p>
<a id="more"></a>

<h3 id="Vue生态链"><a href="#Vue生态链" class="headerlink" title="Vue生态链"></a>Vue生态链</h3><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官网</a>，<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex(状态管理)</a>，<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vuerouter(路由管理)</a></p>
<h3 id="个人旗下网站"><a href="#个人旗下网站" class="headerlink" title="个人旗下网站"></a>个人旗下网站</h3><p><a href="http://wiki.poorman.top/" target="_blank" rel="noopener">Wiki</a>，</p>
<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><p><a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">官网</a></p>
<h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p><a href="http://lesscss.cn/" target="_blank" rel="noopener">官网</a></p>
<h3 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h3><p><a href="https://stylus.bootcss.com/" target="_blank" rel="noopener">官网</a></p>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p><a href="https://www.pugjs.cn/api/getting-started.html" target="_blank" rel="noopener">pug</a>, <a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a></p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener">echarts</a> ,<a href="https://d3js.org/" target="_blank" rel="noopener">D3</a>, <a href="https://www.highcharts.com.cn/" target="_blank" rel="noopener">highcharts</a>, <a href="http://chartjs.cn/" target="_blank" rel="noopener">chartjs</a> ，<a href="https://ecomfe.github.io/zrender-doc/public/" target="_blank" rel="noopener">zrender</a></p>
<p><strong>扩展文章</strong></p>
<p><a href="https://www.zhihu.com/question/28687373" target="_blank" rel="noopener">https://www.zhihu.com/question/28687373</a></p>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
  </entry>
  <entry>
    <title>知识/前端/同源与跨域/细说同域-同父域-跨域</title>
    <url>/2020/06/26/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/%E7%BB%86%E8%AF%B4%E5%90%8C%E5%9F%9F-%E5%90%8C%E7%88%B6%E5%9F%9F-%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><strong>一、域名级别</strong></p>
<p><strong>域名</strong>级别是网址分类的一个标准，包括顶级域名、二级域名等。一个完整的域名由二个或二个以上部分组成，各部分之间用英文的句号”.”来分隔，倒数第一个”.”的右边部分称为<strong>顶级域名</strong>（TLD，也称为一级域名，包含一个合法字符串和一个域名后缀），顶级域名的左边部分字符串到下个”.”为止称为二级域名（SLD），二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。</p>
<p><strong>二、域名组成</strong></p>
<p>域名组成方式是由一下域名级别类型构成的</p>
<ol>
<li>顶级域名</li>
<li>二级域名</li>
<li>三级域名</li>
<li>国家代码域名</li>
</ol>
<p><strong>顶级域名</strong>：分为两类：　一是国家顶级域名（nationaltop-leveldomainnames，简称nTLDs），目前200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，美国是us，日本是jp等；二是国际顶级域名（internationaltop-leveldomainnames，简称iTDs），例如表示工商企业的.com，表示网络提供商的.net，表示非盈利组织的.org等。目前大多数域名争议都发生在com的顶级域名下，因为多数公司上网的目的都是为了赢利。为加强域名管理，解决域名资源的紧张，Internet协会、Internet分址机构及世界知识产权组织（WIPO）等国际组织经过广泛协商，在原来三个国际通用顶级域名：（com）的基础上，新增加了7个国际通用顶级域名：firm（公司企业）、store（销售公司或企业）、Web（突出WWW活动的单位）、arts（突出文化、娱乐活动的单位）、rec(突出消遣、娱乐活动的单位）、info(提供信息服务的单位）、nom(个人），并在世界范围内选择新的注册机构来受理域名注册申请。</p>
<p><strong>二级域名：</strong>是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如com，edu，gov，net等。　中国在国际互联网络信息中心（InterNIC）正式注册并运行的顶级域名是cn，这也是中国的一级域名。在顶级域名之下，中国的二级域名又分为类别域名和行政区域名两类。类别域名共6个，包括用于科研机构的ac；用于工商金融企业的com；用于教育机构的edu；用于政府部门的gov；用于互联网络信息中心和运行中心的net；用于非盈利组织的org。而行政区域名有34个，分别对应于中国各省、自治区和直辖市。</p>
<p><strong>三级域名</strong>：用字母（A～Z，a～z，大小写等）、数字（0～9）和连接符（－）组成，各级域名之间用实点（.）连接，三级域名的长度不能超过20个字符。如无特殊原因，建议采用申请人的英文名（或者缩写）或者汉语拼音名（或者缩写）作为三级域名，以保持域名的清晰性和简洁性。</p>
<p><strong>国家代码</strong>：由两个字母组成的顶级域名如.cn,.uk,.de和.jp称为国家代码顶级域名（ccTLDs),其中.cn是中国专用的顶级域名，其注册归CNNIC管理，以.cn结尾的二级域名我们简称为国内域名。注册国家代码顶级域名下的二级域名的规则和政策与不同的国家的政策有关。您在注册时应咨询域名注册机构，问清相关的注册条件及与注册相关的条款。某些域名注册商除了提供以.com,.net和.org结尾的域名的注册服务之外，还提供国家代码顶级域名的注册。ICANN并没有特别授权注册商提供国家代码顶级域名的注册服务。</p>
<p><strong>三、同域-同父域-跨域区分</strong></p>
<p><strong>同域</strong>：即同源，所谓同源，指的是协议、域名、端口号都必须完全相同。这里同源既是同域。</p>
<p><strong>同父域</strong>：即存在父域相同。例如，Http：<a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com/</a> 与Http：ww.baidu.com/ 就是同父域。</p>
<p><strong>跨域</strong>：所谓跨域，就是不同源（IP地址相同，但域名不同也是跨域）。那这里的同父域你就懂得了？</p>
<blockquote>
<p>原文链接：</p>
<p><a href="https://www.cnblogs.com/julygift/p/8535825.html" target="_blank" rel="noopener">https://www.cnblogs.com/julygift/p/8535825.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>随想/readme</title>
    <url>/2020/06/26/%E9%9A%8F%E6%83%B3/readme/</url>
    <content><![CDATA[<p>这是一个electron项目，属于聚合项目，集合多种功能，方便我的使用</p>
<ol>
<li><p>用于开发一个代码笔记项目。记录灵感释放的瞬间。</p>
</li>
<li><p>提供markdown项目部署</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>随想/as</title>
    <url>/2020/06/26/%E9%9A%8F%E6%83%B3/as/</url>
    <content><![CDATA[<p>这是一个导航网站项目，旨在收集网络资源。为了提供更好的体验，必须提供后台，用于对网站数据的编辑</p>
<p>整理需求，功能列举</p>
<p>设计页面，配色，主题</p>
<p>后台数据库设计，接口开发</p>
<p>前端页面实现</p>
]]></content>
  </entry>
  <entry>
    <title>西风颂---灵感</title>
    <url>/2020/06/23/%E5%B0%8F%E8%AF%B4/%E8%A5%BF%E9%A3%8E%E9%A2%82---%E7%81%B5%E6%84%9F/</url>
    <content><![CDATA[<h2 id="墟城"><a href="#墟城" class="headerlink" title="墟城"></a>墟城</h2><h3 id="废墟城"><a href="#废墟城" class="headerlink" title="废墟城"></a>废墟城</h3><p>主角生活在废墟城城郊，主要工作是一个企业的小职员，大学毕业就来到了这个城市，然后准备干一番事业。这个世界是力量与科技的结合，修仙者吸收天地源力，凡人追寻科技进步。又力量的差距，必定存在着等级的差距，现在凡人的科技尚弱，但是表现的威力开始引起了修仙者的注意，也是此时，修仙者开始入世。</p>
<p>主角所在的是一个小公司，主要靠接客户的订单完成相应的任务赚取酬劳。</p>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title>西风颂</title>
    <url>/2020/06/23/%E5%B0%8F%E8%AF%B4/%E8%A5%BF%E9%A3%8E%E9%A2%82/</url>
    <content><![CDATA[<blockquote>
<p>知道吗？修炼乃逆天而为，想要攀上至强的高峰，所付出的一定是你的一切。问题是，你愿意赌上你的一切去追寻那虚无缥缈的未来吗？会么？</p>
</blockquote>
<h2 id="远方的来客"><a href="#远方的来客" class="headerlink" title="远方的来客"></a>远方的来客</h2>]]></content>
      <categories>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title>inquirer的试用</title>
    <url>/2020/06/23/npm/%E8%AF%95%E7%94%A8/inquirer%E7%9A%84%E8%AF%95%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>开始通过npm init 创建package.json的时候就有大量与用户的交互(当然也可以通过参数来忽略输入)；而现在大多数工程都是通过脚手架来创建的，使用脚手架的时候最明显的就是与命令行的交互，如果想自己做一个脚手架或者在某些时候要与用户进行交互，这个时候就不得不提到inquirer.js了。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由于交互的问题种类不同，<code>inquirer</code>为每个问题提供很多参数：</p>
<ul>
<li><p>type：表示提问的类型，包括：<code>input</code>, <code>confirm</code>, <code>list</code>, <code>rawlist</code>, <code>expand</code>, <code>checkbox</code>, <code>password</code>, <code>editor</code>；</p>
</li>
<li><p>name: 存储当前问题回答的变量；</p>
</li>
<li><p>message：问题的描述；</p>
</li>
<li><p>default：默认值；</p>
</li>
<li><p>choices：列表选项，在某些<code>type</code>下可用，并且包含一个分隔符(separator)；</p>
</li>
<li><p>validate：对用户的回答进行校验；</p>
</li>
<li><p>filter：对用户的回答进行过滤处理，返回处理后的值；</p>
</li>
<li><p>transformer：对用户回答的显示效果进行处理(如：修改回答的字体或背景颜色)，但不会影响最终的答案的内容；</p>
</li>
<li><p>when：根据前面问题的回答，判断当前问题是否需要被回答；</p>
</li>
<li><p>pageSize：修改某些type类型下的渲染行数；</p>
</li>
<li><p>prefix：修改message默认前缀；</p>
</li>
<li><p>suffix：修改message默认后缀</p>
</li>
</ul>
<blockquote>
<p>上面的属性(除<code>transformer</code>外)在下面都有对应使用。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const inquirer &#x3D; require(&#39;inquirer&#39;);</span><br><span class="line"></span><br><span class="line">const promptList &#x3D; [</span><br><span class="line">    &#x2F;&#x2F; 具体交互内容</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inquirer.prompt(promptList).then(answers &#x3D;&gt; &#123;</span><br><span class="line">    console.log(answers); &#x2F;&#x2F; 返回的结果</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;input&#39;,</span><br><span class="line">    message: &#39;设置一个用户名:&#39;,</span><br><span class="line">    name: &#39;name&#39;,</span><br><span class="line">    default: &quot;test_user&quot; &#x2F;&#x2F; 默认值</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    type: &#39;input&#39;,</span><br><span class="line">    message: &#39;请输入手机号:&#39;,</span><br><span class="line">    name: &#39;phone&#39;,</span><br><span class="line">    validate: function(val) &#123;</span><br><span class="line">        if(val.match(&#x2F;\d&#123;11&#125;&#x2F;g)) &#123; &#x2F;&#x2F; 校验位数</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;请输入11位数字&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526163529495" alt="input"></p>
<h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm"></a>confirm</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;confirm&quot;,</span><br><span class="line">    message: &quot;是否使用监听？&quot;,</span><br><span class="line">    name: &quot;watch&quot;,</span><br><span class="line">    prefix: &quot;前缀&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    type: &quot;confirm&quot;,</span><br><span class="line">    message: &quot;是否进行文件过滤？&quot;,</span><br><span class="line">    name: &quot;filter&quot;,</span><br><span class="line">    suffix: &quot;后缀&quot;,</span><br><span class="line">    when: function(answers) &#123; &#x2F;&#x2F; 当watch为true的时候才会提问当前问题</span><br><span class="line">        return answers.watch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526171059692" alt="confirm_y"></p>
<p><img src="/images/20180526171118828" alt="confirm_n"></p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;list&#39;,</span><br><span class="line">    message: &#39;请选择一种水果:&#39;,</span><br><span class="line">    name: &#39;fruit&#39;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;Apple&quot;,</span><br><span class="line">        &quot;Pear&quot;,</span><br><span class="line">        &quot;Banana&quot;</span><br><span class="line">    ],</span><br><span class="line">    filter: function (val) &#123; &#x2F;&#x2F; 使用filter将回答变为小写</span><br><span class="line">        return val.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526171358697" alt="list_1"></p>
<p><img src="/images/20180526171252867" alt="list"></p>
<h4 id="rawlist"><a href="#rawlist" class="headerlink" title="rawlist"></a>rawlist</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;rawlist&#39;,</span><br><span class="line">    message: &#39;请选择一种水果:&#39;,</span><br><span class="line">    name: &#39;fruit&#39;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;Apple&quot;,</span><br><span class="line">        &quot;Pear&quot;,</span><br><span class="line">        &quot;Banana&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526171501268" alt="rawlist"></p>
<h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;expand&quot;,</span><br><span class="line">    message: &quot;请选择一种水果：&quot;,</span><br><span class="line">    name: &quot;fruit&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;a&quot;,</span><br><span class="line">            name: &quot;Apple&quot;,</span><br><span class="line">            value: &quot;apple&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;O&quot;,</span><br><span class="line">            name: &quot;Orange&quot;,</span><br><span class="line">            value: &quot;orange&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;p&quot;,</span><br><span class="line">            name: &quot;Pear&quot;,</span><br><span class="line">            value: &quot;pear&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/2018052617182848" alt="expend_1"></p>
<p><img src="/images/2018052617184757" alt="expend_2"></p>
<h4 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;checkbox&quot;,</span><br><span class="line">    message: &quot;选择颜色:&quot;,</span><br><span class="line">    name: &quot;color&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;red&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        new inquirer.Separator(), &#x2F;&#x2F; 添加分隔符</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;blur&quot;,</span><br><span class="line">            checked: true &#x2F;&#x2F; 默认选中</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;green&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        new inquirer.Separator(&quot;--- 分隔符 ---&quot;), &#x2F;&#x2F; 自定义分隔符</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;yellow&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F; 或者下面这样</span><br><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;checkbox&quot;,</span><br><span class="line">    message: &quot;选择颜色:&quot;,</span><br><span class="line">    name: &quot;color&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;red&quot;,</span><br><span class="line">        &quot;blur&quot;,</span><br><span class="line">        &quot;green&quot;,</span><br><span class="line">        &quot;yellow&quot;</span><br><span class="line">    ],</span><br><span class="line">    pageSize: 2 &#x2F;&#x2F; 设置行数</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526172231673" alt="checkbox_sep"></p>
<p><img src="/images/20180526172246307" alt="checkbox_size"></p>
<h4 id="password"><a href="#password" class="headerlink" title="password"></a>password</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;password&quot;, &#x2F;&#x2F; 密码为密文输入</span><br><span class="line">    message: &quot;请输入密码：&quot;,</span><br><span class="line">    name: &quot;pwd&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/2018052617241416" alt="pwd"></p>
<h4 id="editor"><a href="#editor" class="headerlink" title="editor"></a>editor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;editor&quot;,</span><br><span class="line">    message: &quot;请输入备注：&quot;,</span><br><span class="line">    name: &quot;editor&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/images/20180526172640212" alt="editor_inset"></p>
<p><img src="/images/20180526172652359" alt="editor_res"></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>npm库</title>
    <url>/2020/06/23/npm/npm%E5%BA%93/</url>
    <content><![CDATA[<h3 id="命令行相关"><a href="#命令行相关" class="headerlink" title="命令行相关"></a>命令行相关</h3><ul>
<li><p><code>commander.js</code></p>
<p>node.js命令行开发工具开发库，使node.js开发CLI工具变得简单，允许快捷的定义形如<code>&lt;command&gt; [options]</code>的命令。</p>
</li>
<li><p><code>inquirer.js</code></p>
<p>node.js 交互式命令行界面开发库，允许方便的定义使用上下左右进行列表选择等交互式命令。</p>
</li>
<li><p><code>ora</code></p>
<p>优雅的命令行<code>Loading</code>动画。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>CSS可替换元素</title>
    <url>/2020/06/14/%E5%89%8D%E7%AB%AF/css/CSS%E5%8F%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> 中，<strong>可替换元素</strong>（<strong>replaced element</strong>）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p>
<a id="more"></a>

<p>简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <code>[&lt;iframe&gt;](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe)</code>元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p>
<p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element#控制内容框中的对象位置" target="_blank" rel="noopener">控制内容框中的对象位置</a>。</p>
<h2 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h2><p>典型的可替换元素有：</p>
<ul>
<li><p><code>&lt;iframe&gt;</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe</a></p>
</li>
<li><p><code>&lt;video&gt;</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video</a></p>
</li>
<li><p><code>&lt;embed&gt;</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed</a></p>
</li>
<li><p><code>&lt;img&gt;</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img</a></p>
</li>
</ul>
<p>有些元素仅在特定情况下被作为可替换元素处理，例如：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/option" target="_blank" rel="noopener"><code>&lt;option&gt;</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="noopener"><code>audio</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener"><code>canvas</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object" target="_blank" rel="noopener"><code>object</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/applet" target="_blank" rel="noopener"><code>applet</code></a></li>
</ul>
<p>HTML 规范也说了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener"><code>&lt;input&gt;</code></a> 元素可替换，因为 <code>&quot;image&quot;</code> 类型的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener"><code>&lt;input&gt;</code></a> 元素就像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img" target="_blank" rel="noopener"><code>&lt;img&gt;</code></a>一样被替换。但是其他形式的控制元素，包括其他类型的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener"><code>&lt;input&gt;</code></a> 元素，被明确地列为非可替换元素（non-replaced elements）。该规范用术语小挂件（Widgets）来描述它们默认的限定平台的渲染行为。</p>
<p>用 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content" target="_blank" rel="noopener"><code>content</code></a> 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。</p>
<h2 id="CSS-与可替换元素"><a href="#CSS-与可替换元素" class="headerlink" title="CSS 与可替换元素"></a>CSS 与可替换元素</h2><p>CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin" target="_blank" rel="noopener"><code>margin</code></a>）和一些 <code>auto</code> 的具体值。</p>
<p>需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener"><code>vertical-align</code></a>。只有可替换元素才能具有这种自带值。</p>
<blockquote>
<p> 控制内容框中的对象位置</p>
</blockquote>
<p>某些CSS属性可用于指定 可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式。这些属性的具体定义可以在 <a href="https://drafts.csswg.org/css-images-3/" target="_blank" rel="noopener">CSS Images Module Level 3</a> 和 <a href="https://drafts.csswg.org/css-images-4/" target="_blank" rel="noopener">CSS Images Module Level 4</a> 规范中找到：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit" target="_blank" rel="noopener"><code>object-fit</code></a></p>
<p>指定可替换元素的内容对象在元素盒区域中的填充方式。（有些类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size" target="_blank" rel="noopener"><code>background-size</code></a> ）</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-position" target="_blank" rel="noopener"><code>object-position</code></a></p>
<p>指定可替换元素的内容对象在元素盒区域中的位置。（类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position" target="_blank" rel="noopener"><code>background-position</code></a> ）</p>
<blockquote>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element</a></li>
<li>可替换元素的 <a href="https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements" target="_blank" rel="noopener">HTML 规范</a></li>
<li>CSS Key Concepts: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax" target="_blank" rel="noopener">CSS 语法</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule" target="_blank" rel="noopener">@规则</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Comments" target="_blank" rel="noopener">注释</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">优先级</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance" target="_blank" rel="noopener">继承</a>, the <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">盒模型</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode" target="_blank" rel="noopener">布局模式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model" target="_blank" rel="noopener">视觉格式化模型</a>，以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">外边距合并</a>，或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial_value" target="_blank" rel="noopener">初始</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value" target="_blank" rel="noopener">计算</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/resolved_value" target="_blank" rel="noopener">解析</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/specified_value" target="_blank" rel="noopener">指定</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/used_value" target="_blank" rel="noopener">使用</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/actual_value" target="_blank" rel="noopener">实际</a>值。 Definitions of <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Value_definition_syntax" target="_blank" rel="noopener">值语法</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">简写属性</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element" target="_blank" rel="noopener">可替换元素</a>。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>前端SVG库</title>
    <url>/2020/06/14/%E6%94%B6%E9%9B%86/%E5%89%8D%E7%AB%AFSVG%E5%BA%93/</url>
    <content><![CDATA[<h3 id="Vivus"><a href="#Vivus" class="headerlink" title="Vivus"></a><a href="http://maxwellito.github.io/vivus/" target="_blank" rel="noopener">Vivus</a></h3><p>Vivus 是一个能动画js类库，它能够给SVG图像显示出被画出来的过程。Vivus是没有其他类库依赖的（比如jQuery)。你仅仅需要在页面中加入这个.js文件，然后传入需要被用来动画的SVG部分就行。同时通过指定一些配置，它能够在页面加载后直接显示动画效果</p>
<h3 id="Bonsai"><a href="#Bonsai" class="headerlink" title="Bonsai"></a><a href="http://bonsaijs.org/" target="_blank" rel="noopener">Bonsai</a></h3><p>Bonsai 是一个功能丰富的 JS 类库，你能够用它来画和 animate 动态内容在网站上。这些内容包括了 HTML5 video、变化的 Canvas 和 SVG。通过 Bonsai 框架，你能画一个简单的矩形、甚至一段矩形，如果你喜欢甚至可以画一个丰富的多人卡通游戏进去。</p>
<h3 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a><a href="http://julian.com/research/velocity/" target="_blank" rel="noopener">Velocity</a></h3><p>Velocity 是一个 JS 类库，它是用来做频繁动画用的。Velocity 的 js 动画“速度”是非常快的。它比JQuery 快，甚至比 CSS 动画还要快。Velocity 的 API 和 $.fn.animate 很像，都是通过$()来操作。velocity()是另一种方法，相比 $().animate()。总而言之，你应该使用一致的animate效果，包括 fadeIn 和 fadeOut 方法（译者：Velocity 提供了 fadeIn 和 fadeOut 方法）。</p>
<h3 id="Raphael"><a href="#Raphael" class="headerlink" title="Raphael"></a><a href="http://raphaeljs.com/" target="_blank" rel="noopener">Raphael</a></h3><p>RaphaelJS 也通常是用来在网页上画SVG图和动画的。它兼容各种windows浏览器一直到IE6，因为如此，Raphael成为了市面上最受信赖的js（svg）类库。有了它，你可以制作分析图表、地图、游戏就像在厨房做饭一样。</p>
<h3 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a><a href="http://snapsvg.io/" target="_blank" rel="noopener">Snap</a></h3><p>SnapSVG 是另一个知名 JS 类库，它是由 Dmitry Baranovskiy 开发的（Raphael 同样也是）。同样它也是 Adobe Web Software Group 来维护。和 Raphael 不同的是，它只提供了 ie 最新版支持。这使得 SnapSVG 在体积上小了许多（相比 Raphel）以实现相同的功能（比如 trim）和支持最新的功能。</p>
<h3 id="Lazy-Line-Painter"><a href="#Lazy-Line-Painter" class="headerlink" title="Lazy Line Painter"></a><a href="http://lazylinepainter.info/" target="_blank" rel="noopener">Lazy Line Painter</a></h3><p>Laid back Range Painter 是一个 jQuery 插件，通常被用来作绘制图集，有点像 Vivus。通常你会吐槽的是它的也就只有这么一个特殊的功能。让我来解释下，如果你是用Illustrator 或者Inkscape制作的SVG图像，而且SVG图像没有任何颜色上的变化，仅仅是轨迹的变化，可以用它。</p>
<h3 id="SVG-js"><a href="#SVG-js" class="headerlink" title="SVG.js"></a><a href="http://svgjs.com/" target="_blank" rel="noopener">SVG.js</a></h3><p>SVG.js 是一个轻量级的操作和动画 SVG 类库。你能够操作变化方向、位置和颜色。这还没完，你甚至可以自己实现插件等一些其他功能。这个实例可以attach一些插件，比如svg.filter.js，他可以为你的图片实现 Gaussian blur, desaturase, compare, sepia 等等功能。</p>
<h3 id="Walkway"><a href="#Walkway" class="headerlink" title="Walkway"></a><a href="https://github.com/ConnorAtherton/walkway" target="_blank" rel="noopener">Walkway</a></h3><p>Walkway 支持3种方式, path, line 和 用polyline来画的svg线。它提供了一个很好的例子，绘制了一个PlayStation 的集合动画。</p>
<h3 id="Progressbar-js"><a href="#Progressbar-js" class="headerlink" title="Progressbar.js"></a><a href="http://kimmobrunfeldt.github.io/progressbar.js/" target="_blank" rel="noopener">Progressbar.js</a></h3><p>ProgressBar.js 是一个可爱的和易于接受的增长曲线图用来绘制卡通SVG线条。有了它，各种形状都可以用作增长曲线。它集成了一些实用的形状如Range,Circle和Block，你甚至可以自行开发一个增长图通过Illustrator或者其他的矢量图绘制工具。 ProgressBar.js 是轻量级，MIT许可的而且支持IE9+。你可以通过它修改大型柱状增长图。你还可以改变属性生成动画，比如stroke breadth, load opacity, load coloring等等。</p>
<h3 id="Chartlist-js"><a href="#Chartlist-js" class="headerlink" title="Chartlist.js"></a><a href="http://gionkunz.github.io/chartist-js/" target="_blank" rel="noopener">Chartlist.js</a></h3><p>Chartist.js 是一个简单的容易被接受的图标库，它是通过SVG绘制的。Chartist的宗旨是提供一个简单的，轻量级的，非侵入式的图表库。你需要提供一些javascript配置对象做一些自定义配置，要不然它会使用默认的配置，即已经默认是排序过后的。</p>
<p>Chartist是通过 inline-SVG绘制的，所以它对DOM操作影响很小，相对于它提供的功能来说。而且意味着Chartist不会提供个人控制、水印、行为等等一些你能够通过简单的HTML, JavaScript and CSS实现的。</p>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
  </entry>
  <entry>
    <title>前端Canvas库</title>
    <url>/2020/06/14/%E6%94%B6%E9%9B%86/%E5%89%8D%E7%AB%AFCanvas%E5%BA%93/</url>
    <content><![CDATA[<h2 id="开源-JavaScript-Canvas-库"><a href="#开源-JavaScript-Canvas-库" class="headerlink" title="开源 JavaScript Canvas 库"></a>开源 JavaScript Canvas 库</h2><ul>
<li>Processing.js Processing.js是一个开放的编程语言，在不使用Flash或Java小程序的前提下，可以实现程序图像、动画和互动的应用。Processing.js是轻量，易于了解掌握的理想工具，可用于可视化的数据，创建用户界面和开发基于Web的游戏。</li>
<li>FABRIC.JS FABRIC.JS是一款简单而强大的JavaScript Canvas 库，提供了互动的对象模型，同时还包含 Canvas-to-SVG 解析器。</li>
<li>oCanvas oCanvas是一个JavaScript框架，用于简化HTML5 Canvas标签的使用，可以利用对象来代替像素。 oCanvas 可以帮助你很容易的在 HTML5 的 Canvas 标签上创建对象，并且创建这些对象的动画</li>
<li>jCanvas jCanvas 就是一个 jQuery 的绘图插件，它封装了一些绘制图形的方法，只需编写几行代码即可生成图形。</li>
<li>RGraph RGraph是一个使用HTML5 Canvas标签实现的图表制作Library。利用该Library生成的Chart具有可交互性，当鼠标点击或移过时会显示相应的信息，可以动态加载Chart或对特殊点进行缩放。</li>
<li>Two.js Two.js 是面向现代 Web 浏览器的一个二维绘图 API。Two.js 可以用于多个场合：SVG，Canvas 和 WebGL，旨在使平面形状和动画的创建更方便，更简洁。</li>
<li>Paper.js Paper.js是一款开源的矢量图形脚本框架，基于 HTML5 Canvas 开发，提供清晰的场景图、DOM和大量强大的功能用来创建各种向量图和贝塞尔曲线。</li>
<li>EaselJS EaselJS 是一个封装了 HTML5 画布(Canvas) 元素的 JavaScript 库。</li>
<li>Kinetic.JS Kinetic.JS 是一个封装了 HTML5 Canvas的JavaScript 库，能为桌面和移动应用提供高性能动画，转场效果，节点嵌套，分层，滤镜，缓存，事件处理以及更多功能。</li>
<li>Pixi.js Pixi.js 是一个 2D webGL 渲染器，提供无缝 Canvas 回退，支持主流浏览器，包括桌面和移动。</li>
</ul>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
  </entry>
  <entry>
    <title>前端动画库</title>
    <url>/2020/06/14/%E6%94%B6%E9%9B%86/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
    <content><![CDATA[<p><a href="https://www.uisdc.com/10-best-free-animation-libraries" target="_blank" rel="noopener">https://www.uisdc.com/10-best-free-animation-libraries</a></p>
<ul>
<li><p>GSAP <a href="https://greensock.com/gsap" target="_blank" rel="noopener">https://greensock.com/gsap</a></p>
</li>
<li><p>Anime.js <a href="http://animejs.com/" target="_blank" rel="noopener">http://animejs.com/</a></p>
</li>
<li><p>Wicked CSS</p>
</li>
<li><p>Animate CSS</p>
</li>
<li><p>Tuesday</p>
</li>
<li><p>CSShake <a href="http://csshake.surge.sh/" target="_blank" rel="noopener">http://csshake.surge.sh/</a></p>
</li>
<li><p>Mo.js <a href="http://mojs.io/" target="_blank" rel="noopener">http://mojs.io/</a></p>
</li>
<li><p>Animate Plus</p>
</li>
<li><p>Bounce.js</p>
</li>
<li><p>Magic</p>
</li>
<li><p>wow.js <a href="https://www.delac.io/wow/" target="_blank" rel="noopener">https://www.delac.io/wow/</a></p>
</li>
<li><p>GreenSock <a href="https://www.tweenmax.com.cn/" target="_blank" rel="noopener">https://www.tweenmax.com.cn/</a> 可以用作一镜到底的动画制作</p>
</li>
<li><p>fullPage.js <a href="http://www.dowebok.com/demo/2014/77/" target="_blank" rel="noopener">http://www.dowebok.com/demo/2014/77/</a></p>
</li>
<li><p>视差动画库 <a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="noopener">http://matthew.wagerfield.com/parallax/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx中server_name 参数详解</title>
    <url>/2020/06/11/%E7%9F%A5%E8%AF%86/nginx/Nginx%E4%B8%ADserver_name%20%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Nginx中的<code>server_name</code>指令主要用于配置基于名称的虚拟主机，<code>server_name</code>指令在接到请求后的匹配顺序分别为：</p>
<p>1、准确的server_name匹配，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  domain.com  www.domain.com;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、以*通配符开始的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  *.domain.com;     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、以*通配符结束的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  www.*;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、匹配正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  ~^(?.+)\.domain\.com$;     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nginx</code>将按照1,2,3,4的顺序对<code>server name</code>进行匹配，只有有一项匹配以后就会停止搜索，所以我们在使用这个指令的时候一定要分清楚它的匹配顺序（类似于<code>location</code>指令）。</p>
<p><code>server_name</code>指令一项很实用的功能便是可以在使用正则表达式的捕获功能，这样可以尽量精简配置文件，毕竟太长的配置文件日常维护也很不方便。下面是2个具体的应用：</p>
<p>1、在一个server块中配置多个站点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">   &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  ~^(www\.)?(.+)$;</span><br><span class="line">     index index.php index.html;</span><br><span class="line">     root  &#x2F;data&#x2F;wwwsite&#x2F;$2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>站点的主目录应该类似于这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;domain.com</span><br><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;nginx.org</span><br><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;baidu.com</span><br><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;google.com</span><br></pre></td></tr></table></figure>

<p>这样就可以只使用一个server块来完成多个站点的配置。</p>
<p>2、在一个server块中为一个站点配置多个二级域名。</p>
<p>实际网站目录结构中我们通常会为站点的二级域名独立创建一个目录，同样我们可以使用正则的捕获来实现在一个server块中配置多个二级域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">   &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  ~^(.+)?\.domain\.com$;     </span><br><span class="line">     index index.html;</span><br><span class="line">     if ($host &#x3D; domain.com)&#123;         </span><br><span class="line">     	rewrite ^ http:&#x2F;&#x2F;www.domain.com permanent;     </span><br><span class="line">     &#125;</span><br><span class="line">     root  &#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;$1&#x2F;;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>站点的目录结构应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;www&#x2F;</span><br><span class="line">&#x2F;data&#x2F;wwwsite&#x2F;domain.com&#x2F;nginx&#x2F;</span><br></pre></td></tr></table></figure>

<p>这样访问<a href="http://www.domain.com时root目录为/data/wwwsite/domain.com/www/，nginx.domain.com时为/data/wwwsite/domain.com/nginx/，以此类推。" target="_blank" rel="noopener">www.domain.com时root目录为/data/wwwsite/domain.com/www/，nginx.domain.com时为/data/wwwsite/domain.com/nginx/，以此类推。</a></p>
<p>后面if语句的作用是将domain.com的方位重定向到<a href="http://www.domain.com，这样既解决了网站的主目录访问，又可以增加seo中对www.domain.com的域名权重。" target="_blank" rel="noopener">www.domain.com，这样既解决了网站的主目录访问，又可以增加seo中对www.domain.com的域名权重。</a></p>
<p><code>server_name</code>同样也可以使用 ip进行匹配，以下是自己使用IP进行配置单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> upstream web_app &#123;</span><br><span class="line">  server 127.0.0.1:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">  server 127.0.0.1:8081 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">&#125;</span><br><span class="line"> server&#123;</span><br><span class="line"> listen 8093;</span><br><span class="line"> \#server_name 127.0.0.1:8093;</span><br><span class="line"> server_name 192.168.47.128:8093</span><br><span class="line"> access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"> location &#x2F;</span><br><span class="line"> &#123;</span><br><span class="line"> proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line"> proxy_set_header Host  $host;</span><br><span class="line"> proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"> proxy_pass http:&#x2F;&#x2F;web_app;</span><br><span class="line"> expires    3d;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上配置的为用两个tomcat做负载均衡，分别为8080、8081，当通过 192.168.47.128:8093 访问时会随机分配到这两个tomcat上,但是在配置时我把 listen 换成 80 就会访问不到，原因还没弄清楚，有知道原因的还请留言告知，不胜感激！！！！</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript与有限状态机</title>
    <url>/2020/06/09/%E7%9F%A5%E8%AF%86/JavaScript%E4%B8%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="http://zh.wikipedia.org/wiki/有限状态机" target="_blank" rel="noopener">有限状态机</a>（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物。</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/JavaScript%E4%B8%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/images/bg2013090201.png" alt="img"></p>
<p>简单说，它有三个特征：</p>
<blockquote>
<p>　　* 状态总数（state）是有限的。<br>　　* 任一时刻，只处在一种状态之中。<br>　　* 某种条件下，会从一种状态转变（transition）到另一种状态。</p>
</blockquote>
<p>它对JavaScript的意义在于，很多对象可以写成有限状态机。</p>
<p>举例来说，网页上有一个菜单元素。鼠标悬停的时候，菜单显示；鼠标移开的时候，菜单隐藏。如果使用有限状态机描述，就是这个菜单只有两种状态（显示和隐藏），鼠标会引发状态转变。</p>
<p>代码可以写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　var menu &#x3D; &#123;</span><br><span class="line">　　　　&#x2F;&#x2F; 当前状态</span><br><span class="line">　　　　currentState: &#39;hide&#39;,</span><br><span class="line">　　　　&#x2F;&#x2F; 绑定事件</span><br><span class="line">　　　　initialize: function() &#123;</span><br><span class="line">　　　　　　var self &#x3D; this;</span><br><span class="line">　　　　　　self.on(&quot;hover&quot;, self.transition);</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　&#x2F;&#x2F; 状态转换</span><br><span class="line">　　　　transition: function(event)&#123;</span><br><span class="line">　　　　　　switch(this.currentState) &#123;</span><br><span class="line">　　　　　　　　case &quot;hide&quot;:</span><br><span class="line">　　　　　　　　　　this.currentState &#x3D; &#39;show&#39;;</span><br><span class="line">　　　　　　　　　　doSomething();</span><br><span class="line">　　　　　　　　　　break;</span><br><span class="line">　　　　　　　　case &quot;show&quot;:</span><br><span class="line">　　　　　　　　　　this.currentState &#x3D; &#39;hide&#39;;</span><br><span class="line">　　　　　　　　　　doSomething();</span><br><span class="line">　　　　　　　　　　break;</span><br><span class="line">　　　　　　　　default:</span><br><span class="line">　　　　　　　　　　console.log(&#39;Invalid State!&#39;);</span><br><span class="line">　　　　　　　　　　break;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，有限状态机的写法，逻辑清晰，表达力强，有利于封装事件。一个对象的状态越多、发生的事件越多，就越适合采用有限状态机的写法。</p>
<p>另外，JavaScript语言是一种<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html" target="_blank" rel="noopener">异步操作</a>特别多的语言，常用的解决方法是指定回调函数，但这样会造成代码结构混乱、难以测试和除错等问题。有限状态机提供了<a href="http://tech.pro/blog/1402/five-patterns-to-help-you-tame-asynchronous-javascript" target="_blank" rel="noopener">更好的办法</a>：把异步操作与对象的状态改变挂钩，当异步操作结束的时候，发生相应的状态改变，由此再触发其他操作。这要比回调函数、事件监听、发布/订阅等解决方案，在逻辑上更合理，更易于降低代码的复杂度。</p>
<p>下面介绍一个有限状态机的函数库<a href="https://github.com/jakesgordon/javascript-state-machine" target="_blank" rel="noopener">Javascript Finite State Machine</a>。这个库非常好懂，可以帮助我们加深理解，而且功能一点都不弱。</p>
<p>该库提供一个全局对象StateMachine，使用该对象的create方法，可以生成有限状态机的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fsm &#x3D; StateMachine.create();</span><br></pre></td></tr></table></figure>

<p>生成的时候，需要提供一个参数对象，用来描述实例的性质。比如，交通信号灯（红绿灯）可以这样描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">　　var fsm &#x3D; StateMachine.create(&#123;</span><br><span class="line">　　　　initial: &#39;green&#39;,</span><br><span class="line">　　　　events: [</span><br><span class="line">　　　　　　&#123; name: &#39;warn&#39;,  from: &#39;green&#39;,  to: &#39;yellow&#39; &#125;,</span><br><span class="line">　　　　　　&#123; name: &#39;stop&#39;, from: &#39;yellow&#39;, to: &#39;red&#39; &#125;,</span><br><span class="line">　　　　　　&#123; name: &#39;ready&#39;,  from: &#39;red&#39;,    to: &#39;yellow&#39; &#125;,</span><br><span class="line">　　　　　　&#123; name: &#39;go&#39;, from: &#39;yellow&#39;, to: &#39;green&#39; &#125;</span><br><span class="line">　　　　]</span><br><span class="line">　　</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>

<p>交通信号灯的初始状态（initial）为green，events属性是触发状态改变的各种事件，比如warn事件使得green状态变成yellow状态，stop事件使得yellow状态变成red状态等等。</p>
<p>生成实例以后，就可以随时查询当前状态。</p>
<blockquote>
<ul>
<li>fsm.current ：返回当前状态。</li>
<li>fsm.is(s) ：返回一个布尔值，表示状态s是否为当前状态。</li>
<li>fsm.can(e) ：返回一个布尔值，表示事件e是否能在当前状态触发。</li>
<li>fsm.cannot(e) ：返回一个布尔值，表示事件e是否不能在当前状态触发。</li>
</ul>
</blockquote>
<p>Javascript Finite State Machine允许为每个事件指定两个回调函数，以warn事件为例：</p>
<blockquote>
<ul>
<li>onbefore<strong>warn</strong>：在warn事件发生之前触发。</li>
<li>onafter<strong>warn</strong>（可简写成onwarn） ：在warn事件发生之后触发。</li>
</ul>
</blockquote>
<p>同时，它也允许为每个状态指定两个回调函数，以green状态为例：</p>
<blockquote>
<ul>
<li>onleave<strong>green</strong> ：在离开green状态时触发。</li>
<li>onenter<strong>green</strong>（可简写成ongreen） ：在进入green状态时触发。</li>
</ul>
</blockquote>
<p>假定warn事件使得状态从green变为yellow，上面四类回调函数的发生顺序如下：onbefore<strong>warn</strong> → onleave<strong>green</strong> → onenter<strong>yellow</strong> → onafter<strong>warn</strong>。</p>
<p>除了为每个事件和状态单独指定回调函数，还可以为所有的事件和状态指定通用的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* onbeforeevent ：任一事件发生之前触发。</span><br><span class="line">* onleavestate ：离开任一状态时触发。</span><br><span class="line">* onenterstate ：进入任一状态时触发。</span><br><span class="line">* onafterevent ：任一事件结束后触发。</span><br></pre></td></tr></table></figure>

<p>如果事件的回调函数里面有异步操作（比如与服务器进行Ajax通信），这时我们可能希望等到异步操作结束，再发生状态改变。这就要用到transition方法。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fsm.onleavegreen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　light.fadeOut(<span class="string">'slow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　fsm.transition();</span><br><span class="line">　　　　&#125;);</span><br><span class="line">　　　　<span class="keyword">return</span> StateMachine.ASYNC;</span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码的回调函数里面，有一个异步操作（light.fadeOut）。如果不希望状态立即改变，就要让回调函数返回StateMachine.ASYNC，表示状态暂时不改变；等到异步操作结束，再调用transition方法，使得状态发生改变。</p>
<p>Javascript Finite State Machine还允许指定错误处理函数，当发生了当前状态不可能发生的事件时自动触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fsm &#x3D; StateMachine.create(&#123;</span><br><span class="line">　　　　&#x2F;&#x2F; ...</span><br><span class="line">　　　　error: function(eventName, from, to, args, errorCode, errorMessage) &#123;</span><br><span class="line">　　　　　　return &#39;event &#39; + eventName + &#39;: &#39; + errorMessage;</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　&#x2F;&#x2F; ... </span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>

<p>比如，当前状态是green，理论上这时只可能发生warn事件。要是这时发生了stop事件，就会触发上面的错误处理函数。</p>
<p>Javascript Finite State Machine的基本用法就是上面这些，更详细的介绍可以参见它的<a href="https://github.com/jakesgordon/javascript-state-machine" target="_blank" rel="noopener">主页</a>。</p>
<p>（完）</p>
<blockquote>
<p>参考文献： </p>
<p><a href="https://github.com/yhanwen/fsm" target="_blank" rel="noopener">https://github.com/yhanwen/fsm</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>tsconfig.json模板文件</title>
    <url>/2020/06/09/ts/tsconfig.json%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;,</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@&#x2F;*&quot;: [&quot;.&#x2F;source&#x2F;*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;node_modules&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ts</category>
      </categories>
  </entry>
  <entry>
    <title>捕鱼轨迹的心路历程</title>
    <url>/2020/06/08/%E9%9A%8F%E6%83%B3/%E6%8D%95%E9%B1%BC%E8%BD%A8%E8%BF%B9%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>新的任务需求，要求上手一款捕鱼进行定制化修改，好在这款产品仍然处于初期状态，这样也就有了足够的时间来进行代码的梳理以及结构的调整。其中主要运用的是观察者发布者模式，其中提供一个中央事件总线进行管理。这些都是比较简单的，逻辑思维没啥比较绕的部分，不过在实现中，考虑到一些原因，现在记录下市面上一些捕鱼的轨迹实现，主要是为了能够方面的实现界面重绘。</p>
</blockquote>
<p>前提：</p>
<p>鱼的路线是一段一段的路径点，是一个一个点之间移动的。单条鱼的路径不需要特别的说明，比较难的是鱼阵的实现方式，考虑到鱼阵需要重新绘制，因此如果采用计时器方法周期性出鱼的话就会导致无法比较精确的重绘鱼，而且也会使得不知道当前需要出第几条鱼，除非服务器端有非常详细的出鱼时间。当前暂没有服务器端配合，我考虑的是一次性绘制出所有的鱼群，这样就能直接移动偏移就行了.</p>
<p>思路:</p>
<p>A-&gt;B-&gt;C-&gt;D-&gt;F…….鱼是按照这样一个一个点的走,中间AB间的过度采用的是匀速直线前进(有些人采用的是中间用内塞尔算法平滑过渡,但是这样我暂时没有办法让他匀速.控制不了速度感觉就如脱缰的野马一样).</p>
<p>我们先绘制出鱼阵的路线,编上号,在让每一条鱼根据对应的编号走就行了.</p>
<p>demo暂缓</p>
]]></content>
  </entry>
  <entry>
    <title>JS中自定义事件的使用与触发</title>
    <url>/2020/06/01/%E5%89%8D%E7%AB%AF/javascript/JS%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A7%A6%E5%8F%91/</url>
    <content><![CDATA[<h3 id="1-事件的创建"><a href="#1-事件的创建" class="headerlink" title="1. 事件的创建"></a>1. 事件的创建</h3><p>JS中，最简单的创建事件方法，是使用Event构造器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myEvent &#x3D; new Event(&#39;event_name&#39;);</span><br></pre></td></tr></table></figure>

<p>但是为了能够传递数据，就需要使用 CustomEvent 构造器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myEvent &#x3D; new CustomEvent(&#39;event_name&#39;, &#123;</span><br><span class="line">    detail:&#123;</span><br><span class="line">        &#x2F;&#x2F; 将需要传递的数据写在detail中，以便在EventListener中获取</span><br><span class="line">        &#x2F;&#x2F; 数据将会在event.detail中得到</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-事件的监听"><a href="#2-事件的监听" class="headerlink" title="2. 事件的监听"></a>2. 事件的监听</h3><p>JS的EventListener是根据事件的名称来进行监听的，比如我们在上文中已经创建了一个名称为<strong>‘event_name’</strong> 的事件，那么当某个元素需要监听它的时候，就需要创建相应的监听器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;假设listener注册在window对象上</span><br><span class="line">window.addEventListener(&#39;event_name&#39;, function(event)&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是CustomEvent，传入的数据在event.detail中</span><br><span class="line">    console.log(&#39;得到数据为：&#39;, event.detail);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...后续相关操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，window对象上就有了对<strong>‘event_name’</strong> 这个事件的监听器，当window上触发这个事件的时候，相关的callback就会执行。</p>
<h3 id="3-事件的触发"><a href="#3-事件的触发" class="headerlink" title="3. 事件的触发"></a>3. 事件的触发</h3><p>对于一些内置（built-in）的事件，通常都是有一些操作去做触发，比如鼠标单击对应MouseEvent的click事件，利用鼠标（ctrl+滚轮上下）去放大缩小页面对应WheelEvent的resize事件。<br>然而，自定义的事件由于不是JS内置的事件，所以我们需要在JS代码中去显式地触发它。方法是使用 <strong>dispatchEvent</strong> 去触发（IE8低版本兼容，使用fireEvent）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先需要提前定义好事件，并且注册相关的EventListener</span><br><span class="line">var myEvent &#x3D; new CustomEvent(&#39;event_name&#39;, &#123; </span><br><span class="line">    detail: &#123; title: &#39;This is title!&#39;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">window.addEventListener(&#39;event_name&#39;, function(event)&#123;</span><br><span class="line">    console.log(&#39;得到标题为：&#39;, event.detail.title);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 随后在对应的元素上触发该事件</span><br><span class="line">if(window.dispatchEvent) &#123;  </span><br><span class="line">    window.dispatchEvent(myEvent);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    window.fireEvent(myEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 根据listener中的callback函数定义，应当会在console中输出 &quot;得到标题为： This is title!&quot;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，当一个事件触发的时候，如果相应的element及其上级元素没有对应的EventListener，就不会有任何回调操作。<br>对于子元素的监听，可以对父元素添加事件托管，让事件在事件冒泡阶段被监听器捕获并执行。这时候，使用event.target就可以获取到具体触发事件的元素。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos中getLocation以左下角为坐标原点问题</title>
    <url>/2020/05/27/cocos/cocos%E4%B8%ADgetLocation%E4%BB%A5%E5%B7%A6%E4%B8%8B%E8%A7%92%E4%B8%BA%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>参考链接</p>
<p><a href="https://forum.cocos.org/t/creator/85600" target="_blank" rel="noopener">https://forum.cocos.org/t/creator/85600</a></p>
</blockquote>
<p>按下面这样从世界坐标转化为本地节点坐标就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">this</span>.map.on(cc.Node.EventType.MOUSE_DOWN,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> pos = <span class="keyword">this</span>.map.convertToNodeSpaceAR(event.getLocation());</span><br><span class="line">     <span class="keyword">this</span>.graphics.fillColor = <span class="keyword">new</span> cc.Color().fromHEX(<span class="string">'#0000ff'</span>);</span><br><span class="line">     <span class="keyword">this</span>.graphics.circle(pos.x,pos.y,<span class="number">10</span>)</span><br><span class="line">     <span class="keyword">this</span>.graphics.fill();</span><br><span class="line">&#125;,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript项目中锁定npm依赖包版本</title>
    <url>/2020/05/26/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/JavaScript%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%94%81%E5%AE%9Anpm%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p> <strong>前言：最近使用<code>cnpm</code>安装项目依赖后，运行项目出现样式错乱问题。</strong></p>
<p>描述：最近升级项目<code>webpack</code>的时候，删除了<code>node_modules</code>，重新安装了，<code>cnpm install</code>，运行项目发现有些地方样式和之前样式不一样，样式变得错乱了，然后就开始找问题,找到运行正常的同事对比了<code>package.json</code>发现版本信息都一样，问题就很奇怪，按理<code>package.json</code>里面一样，<code>node_modules</code>也一样才对。</p>
</blockquote>
<p><strong>然后把同事的<code>node_modules</code>拷贝过来，结果运行正常，</strong></p>
<h4 id="为什么node-modules会不一样？"><a href="#为什么node-modules会不一样？" class="headerlink" title="为什么node_modules会不一样？"></a>为什么<code>node_modules</code>会不一样？</h4><p>和同事对比了依赖的版本，发现还是有差异的，左边是有错误的，右边是正确;</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/JavaScript%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%94%81%E5%AE%9Anpm%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC/images/image-20200526134440533.png" alt="image-20200526134440533"></p>
<p>然后我安装成右边正确的版本，发现样式问题都好了。<br>为什么会造成安装的版本不一样？<br>图下是本地项目<code>package.json</code>依赖</p>
<p>网上找了下 包里面的<code>^</code>是什么意思,示例如下：<br><code>1.2.1</code><br>-匹配指定版本，这里是匹配1.2.1。</p>
<p><code>^1.0.0</code><br>匹配 &gt;=1.0.0 且 &lt;2.0.0的版本。<br>^ 前缀意为 与指定的版本兼容 。<br>^ 前缀表示最左边的非0段不允许改变，该段之后的段可以为更高版，所以<br>^1.1.0 匹配 &gt;=1.1.0 且 &lt;2.0.0<br>^0.0.3 匹配 &gt;=0.0.3 且 &lt;0.0.4</p>
<p><code>latest</code><br>当前发布版本。<br>这是一个标记（<code>tag</code>，详见 <code>dist-tag</code> |<code>npm Documentation</code>），默认情况下 npm install 安装的就是这个 <code>latest</code> 标记。 常见的标记还有 <code>next stable beta canary</code> 。</p>
<p><code>^5.x</code><br>匹配 &gt;=5.0.0 且 &lt;6.0.0。<br>X, x 及 * 为通配符，版本号尾部省略的段等同于通配符，所以<br>匹配 &gt;=0.0.0<br>1 匹配 &gt;=1.0.0 且 &lt;2.0.0<br>1.2 匹配 &gt;=1.2.0 且 &lt;1.3.0</p>
<p><code>~0.1.1</code><br>匹配 &gt;=0.1.1 且 &lt;0.2.0。</p>
<p><code>~</code><br>前缀意为 约等于版本<br>如果存在次版本号，则允许修订号为更高版，否则允许次版本号为更高版。</p>
<p><code>~1</code><br>匹配 &gt;=1.0.0 且 &lt;2.0.0<br>匹配 &gt;=0.0.0</p>
<p><code>=3.0.0</code><br>同字面意义 &gt;=3.0.0。</p>
<p><code>&lt; &lt;= &gt; &gt;= =</code><br>多个表达式之间用 空格 分隔表示并集，用 || 分隔交集。</p>
<p><code>1.30.2 - 2.30.2</code><br>匹配 &gt;=1.30.2 且 &lt;=2.30.2</p>
<h4 id="原因已经找到了，怎么来解决这个问题？"><a href="#原因已经找到了，怎么来解决这个问题？" class="headerlink" title="原因已经找到了，怎么来解决这个问题？"></a>原因已经找到了，怎么来解决这个问题？</h4><p>我们安装依赖常用的方式有3种<code>cnpm、npm、yarn</code>:</p>
<ul>
<li><code>cnpm</code>：优点是速度快，缺点是没办法保证每个同事安装依赖的时候版本一致，就会出现依赖升级不兼容性问题</li>
<li><code>npm</code>：优点是通过<code>package-lock.json</code>文件能够锁定版本，缺点是安装速度慢。</li>
<li><code>yarn</code>：优点是速度比<code>npm</code>快、<code>yarn.lock</code>文件能够锁定版本,缺点是学习成本相对高。</li>
</ul>
<p>基于团队考虑，还是使用的<code>yarn</code>来控制项目依赖的版本,<code>yarn</code>使用起来和<code>npm</code> 大同小异，学习起来还是比较快的。问题解决了，开心。下面解释下<code>yarn</code>常用方法，</p>
<h4 id="yarn-使用方法"><a href="#yarn-使用方法" class="headerlink" title="yarn 使用方法"></a>yarn 使用方法</h4><h5 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure>

<h5 id="安装项目的全部依赖"><a href="#安装项目的全部依赖" class="headerlink" title="安装项目的全部依赖"></a>安装项目的全部依赖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn || yarn install</span><br></pre></td></tr></table></figure>

<h5 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h5><p>分别添加到 <code>devDependencies</code>、<code>peerDependencies</code> 和 <code>optionalDependencies</code> 类别中：<br><code>yarn 类型npm install</code><br><code>yarn add [name] --dev</code><br><code>yarn add [name] --peer</code><br><code>yarn add [name] --optional</code></p>
<h5 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn upgrade [package] --dev&#96;</span><br><span class="line">&#96;yarn upgrade [package]@[version] --dev&#96;</span><br><span class="line">&#96;yarn upgrade [package]@[tag] --dev</span><br></pre></td></tr></table></figure>

<h5 id="删除依赖"><a href="#删除依赖" class="headerlink" title="删除依赖"></a>删除依赖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一直都是使用cnpm来安装依赖，安装速度快，也比较方便，但是多人协作开发是容易出现问题，多人协作开发依赖版本应该保持一致。避免依赖版本不兼容项目出现问题。</p>
]]></content>
  </entry>
  <entry>
    <title>圣杯布局,双飞翼布局</title>
    <url>/2020/05/25/%E5%89%8D%E7%AB%AF/css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80,%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<blockquote>
<p>作者：放羊的小桃桃<br>链接：<a href="https://www.jianshu.com/p/81ef7e7094e8" target="_blank" rel="noopener">https://www.jianshu.com/p/81ef7e7094e8</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。<br>参考： <a href="https://www.cnblogs.com/imwtr/p/4441741.html" target="_blank" rel="noopener">https://www.cnblogs.com/imwtr/p/4441741.html</a></p>
</blockquote>
<p>圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个 <strong>两侧宽度固定，中间宽度自适应的三栏布局。</strong><br><img src="https://upload-images.jianshu.io/upload_images/9397803-ab11463cd3c26105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/981/format/webp" alt="image"></p>
<p>圣杯布局来源于文章<a href="https://alistapart.com/article/holygrail" target="_blank" rel="noopener">In Search of the Holy Grail</a>，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点：</p>
<ul>
<li>两侧宽度固定，中间宽度自适应</li>
<li>中间部分在DOM结构上优先，以便先行渲染</li>
<li>允许三列中的任意一列成为最高列</li>
<li>只需要使用一个额外的<code>&lt;div&gt;</code>标签</li>
</ul>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;center&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>首先定义出整个布局的<code>DOM</code>结构，主体部分是由<code>container</code>包裹的<code>center</code>,<code>left</code>,<code>right</code>三列，其中<code>center</code>定义在最前面。</p>
<h3 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h3><p>假设左侧的固定宽度为200px，右侧的固定宽度为150px，则首先在<code>container</code>上设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">  padding-left: 200px; </span><br><span class="line">  padding-right: 150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为左右两列预留出相应的空间，得到如下示意图：<br><img src="https://upload-images.jianshu.io/upload_images/9397803-aaea086d37ac9e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="image"></p>
<p>随后分别为三列设置宽度与浮动，同时对<code>footer</code>设置清除浮动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container .column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-908ab18834f384ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="image"> </p>
<p>根据浮动的特性，由于<code>center</code>的宽度为100%，即占据了第一行的所有空间，所以<code>left</code>和<code>right</code>被“挤”到了第二行。</p>
<p>接下来的工作是将<code>left</code>放置到之前预留出的位置上，这里使用 <strong>负外边距</strong>（nagetive margin）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">  &#x2F;&#x2F;这里是父元素宽度的%</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-0092cb112431e076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="image"></p>
<p>随后还需要使用<code>定位(position)</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  position: relative;</span><br><span class="line">  right: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>position: relative</code>和<code>right: 200px</code>将left的位置在原有位置基础上左移200px，以完成left的放置：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-0f0134d16c865fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="image"></p>
<p>接下来放置<code>right</code>，只需添加一条声明即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">  margin-right: -150px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到最终的效果图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-e964c6f980b5da16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="image"></p>
<p>至此，布局效果完成。不过还需要考虑最后一步，那就是页面的最小宽度：要想保证该布局效果正常显示，由于两侧都具有固定的宽度，所以需要给定页面一个最小的宽度，但这并不只是简单的200+150=350px。回想之前left使用了position: relative，所以就意味着在center开始的区域，还存在着一个left的宽度。所以页面的最小宽度应该设置为200+150+200=550px：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 550px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，圣杯布局的CSS代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 550px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#container &#123;</span><br><span class="line">  padding-left: 200px; </span><br><span class="line">  padding-right: 150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#container .column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  position: relative;</span><br><span class="line">  right: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">  margin-right: -150px; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于圣杯布局的示例，可参考：<a href="https://litaooooo.github.io/page-examples/holy-grail.html" target="_blank" rel="noopener">圣杯布局</a></p>
<p>最后提醒一下很多朋友可能会忽略的小细节：在<code>#center</code>中，包含了一条声明<code>width: 100%</code>，这是中间栏能够做到自适应的关键。可能会有朋友认为不需要设置这条声明，因为觉得center在不设置宽度的情况下会默认将宽度设置为父元素(container)的100%宽度。但需要注意到，center是浮动元素，由于浮动具有包裹性，在不显式设置宽度的情况下会自动“收缩”到内容的尺寸大小。如果去掉width: 100%，则当中间栏不包含或者包含较少内容时，整个布局会“崩掉”，而达不到这样的效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-09a8a5617072d0a2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/904/format/webp" alt="image"></p>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><h3 id="DOM结构-1"><a href="#DOM结构-1" class="headerlink" title="DOM结构"></a>DOM结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;column&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;center&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure>
<p>双飞翼布局的<code>DOM结构</code>与<code>圣杯布局</code>的区别是用<code>container</code>仅包裹住center，另外将<code>.column</code>类从<code>center</code>移至<code>container</code>上。</p>
<h3 id="CSS代码-1"><a href="#CSS代码-1" class="headerlink" title="CSS代码"></a>CSS代码</h3><p>按照与圣杯布局相同的思路，首先设置各列的宽度与浮动，并且为左右两列预留出空间，以及为<code>footer</code>设置浮动清除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  margin-right: 150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下效果示意图:<br><img src="https://upload-images.jianshu.io/upload_images/9397803-a0f387a0dc99d388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<p>以上代码将<code>container</code>,<code>left</code>,<code>right</code>设置为<code>float</code>: <code>left</code>，而在<code>container</code>内部，<code>center</code>由于没有设置浮动，所以其宽度默认为<code>container</code>的100%宽度，通过对其设置<code>margin-left</code>和<code>margin-right</code>为左右两列预留出了空间。</p>
<p>将<code>left</code>放置到预留位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到：<br><img src="https://upload-images.jianshu.io/upload_images/9397803-7fcff771168c26cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"><br>将<code>right</code>放置到预留位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到最终效果：<br><img src="https://upload-images.jianshu.io/upload_images/9397803-639e4da232d31e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<p>最后计算最小页面宽度：由于双飞翼布局没有用到<code>position:relative</code>进行定位，所以最小页面宽度应该为200+150=350px。但是当页面宽度缩小到350px附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖，如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-7612899f07163703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp" alt="image"></p>
<p>因此在设置最小页面宽度时，应该适当增加一些宽度以供中间栏使用（假设为150px），则有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此双飞翼布局大功告成！其布局整体代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 500px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">#center &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  margin-right: 150px;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px; </span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于双飞翼布局的示例，可参考：<a href="https://litaooooo.github.io/page-examples/double-wings.html" target="_blank" rel="noopener">双飞翼布局</a></p>
<h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>通过对圣杯布局和双飞翼布局的介绍可以看出，圣杯布局在DOM结构上显得更加直观和自然，且在日常开发过程中，更容易形成这样的DOM结构（通常<code>&lt;aside&gt;</code>和<code>&lt;article&gt;/&lt;section&gt;</code>一起被嵌套在<code>&lt;main&gt;</code>中）；而双飞翼布局在实现上由于不需要使用定位，所以更加简洁，且允许的页面最小宽度通常比圣杯布局更小。</p>
<p>其实通过思考不难发现，两者在代码实现上都额外引入了一个<div>标签，其目的都是为了既能保证中间栏产生浮动（浮动后还必须显式设置宽度），又能限制自身宽度为两侧栏留出空间。</p>
<p>从这个角度出发，如果去掉额外添加的<div>标签，能否完成相同的布局呢？答案是肯定的，不过这需要在兼容性上做出牺牲：</p>
<h3 id="DOM结构-2"><a href="#DOM结构-2" class="headerlink" title="DOM结构"></a>DOM结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;center&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>去掉额外的<code>&lt;div&gt;</code>标签后，得到的DOM结构如上所示，基于双飞翼布局的实现思路，只需要在<code>center</code>上做出修改：</p>
<h3 id="使用calc"><a href="#使用calc" class="headerlink" title="使用calc()"></a>使用calc()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">#center &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  margin-right: 150px;</span><br><span class="line">  width: calc(100% - 350px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>calc()</code>可以十分方便地计算出center应该占据的自适应宽度，目前<code>calc()</code>支持到IE9。</p>
<h3 id="使用border-box"><a href="#使用border-box" class="headerlink" title="使用border-box"></a>使用border-box</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">#center &#123;</span><br><span class="line">  padding-left: 200px;</span><br><span class="line">  padding-right: 150px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>border-box</code>可以将<code>center</code>的整个盒模型宽度设置为父元素的100%宽度，此时再利用<code>padding-left</code>和<code>padding-right</code>可以自动得到中间栏的自适应宽度。不过需要注意的是，由于padding是盒子的一部分，所以padding部分会具有中间栏的背景色，当中间栏高于侧栏时，会出现这样的情况：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9397803-243751e1bb945634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/703/format/webp" alt="image"></p>
<p>目前<code>box-sizing</code>支持到IE8。</p>
<h3 id="使用flex"><a href="#使用flex" class="headerlink" title="使用flex"></a>使用flex</h3><p>这里使用flex还是需要与圣杯布局相同的DOM结构，不过在实现上将更加简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- DOM结构 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;center&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#left &#123;</span><br><span class="line">    flex: 0 0 200px;</span><br><span class="line">    order: -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#right &#123;</span><br><span class="line">    flex: 0 0 150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义设置hr的颜色</title>
    <url>/2020/05/25/%E5%89%8D%E7%AB%AF/css/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AEhr%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>1、hr的颜色不能使用color来控制，要使用background-color来控制</p>
<p>2、hr的高度不能为 0</p>
<p>3,、还会有灰色的阴影，设置border:none</p>
<p>默认的hr样式</p>
<p>自定的hr样式：</p>
<p>附上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hr &#123;</span><br><span class="line">  height: 1px;</span><br><span class="line">  background-color: #6EECB4;</span><br><span class="line">  border: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>让容器充满屏幕高度或自适应剩余高度</title>
    <url>/2020/05/25/%E5%89%8D%E7%AB%AF/css/%E8%AE%A9%E5%AE%B9%E5%99%A8%E5%85%85%E6%BB%A1%E5%B1%8F%E5%B9%95%E9%AB%98%E5%BA%A6%E6%88%96%E8%87%AA%E9%80%82%E5%BA%94%E5%89%A9%E4%BD%99%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<blockquote>
<p>在前端页面布局中，经常会碰到要让容器充满整个屏幕高度或者剩余屏幕高度的需求。一般这时候都会想当然的使用 height:100% 这样的 CSS 来写。这样写的话，当容器内内容很多的时候是没有问题的，可以达到预期的效果，但是如果容器内内容比较少，不足以撑起足够的高度的话，这个CSS 样式实际上是没起作用的。那要怎么解决这个问题呢？</p>
</blockquote>
<p><strong>让容器高度充满这个屏幕</strong></p>
<p>在容器内容很少的情况下，要想让这个容器充满整个屏幕可以这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;    </span><br><span class="line">	<span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个新的单位可能有的老浏览器不支持（说的是谁你们都知道的）。可以去caniuse看一下</p>
<p><strong>让容器高度充满剩余屏幕高度</strong></p>
<p>上面说的让容器充满整个屏幕是一个比较简单的情况，实际项目中这种简单情况是非常少的，一般碰到比较多的可能是要让容器充满屏幕的剩余高度，有了上面的那个做基础，这个需求也就简单了，用 vh 结合 flex 布局就可以很容器的实现。直接看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;    </span><br><span class="line">	min-height:100vh;    </span><br><span class="line">	display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.header&#123;    </span><br><span class="line">	height:100px</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;    </span><br><span class="line">	flex:1;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;    </span><br><span class="line">	height:100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面的样式就可以让 content 的高度自适应屏幕的剩余高度，简单方便。同样可能会面临老浏览器适配的问题。因为我做的项目主要是在移动端使用，所以就不管那老掉牙的家伙了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>css 伪类实现弧形</title>
    <url>/2020/05/25/%E5%89%8D%E7%AB%AF/css/css%20%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BC%A7%E5%BD%A2/</url>
    <content><![CDATA[<p>在实现页面五花八门的有特色的ui时，我们有时会遇到要用实现一个弧形，而这样的弧形要怎么实现呢？用图片？好像不大现实，因为这样就要无故多加载一张图片了，这里我们来说说怎么用css的after伪类来实现弧形。</p>
<p>![img](/static/前端/css/css 伪类实现弧形/images/7513201-18bc753766c1fc46.png)</p>
<p>先是一写元素，再给这个元素设置样式和伪类样式<br> <code>&lt;view class=&quot;pure_top&quot;&gt;&lt;/view&gt;</code><br> 比如说这个pure_top元素(因为这里是小程序所以用的是view，h5也是一样实现的啦)，我设置的样式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.pure_top &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.pure_top::after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  width: 140%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: -20%;</span><br><span class="line">  top: 0;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  border-radius: 0 0 50% 50%;</span><br><span class="line">  background: #1496f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何在元素后追加一个after，当然是元素自身定位为relative，伪类设置content:‘’，并相对定位为absolute，再设置下left ,top 值，使伪类元素的位置摆放的合理就行了。<br> 这里需要注意的是我把z-index值设为-1，因为弧形一般是作为背景图的，所有层级自然要放低些。<br> 实现效果如下图：</p>
<p>![img](/static/前端/css/css 伪类实现弧形/images/7513201-4d0d0a9438d118e3.png)</p>
<p>上面的图看起来好像弧度太大，几乎要看不出。依上面的实现原理，弧度要多少可以是自己微调。看上面的伪类<code>.pure_top::after { content: &#39;&#39;;width: 140%;}</code>宽度为140%，难怪弧度那么大呢？半径越大，弧度就越大(我应该没记错吧哈哈哈哈哈哈)，那我们是不是可以减小半径来达到变小弧度的需求？看下图的实现：</p>
<p>![img](/static/前端/css/css 伪类实现弧形/images/7513201-8833cd268690e1c6.png)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gradient_top &#123;</span><br><span class="line">  width:100%;</span><br><span class="line">    height: 330rpx;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.gradient_top::after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 330rpx;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  top:0;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  border-radius: 0 0 80% 80%;</span><br><span class="line">  background: linear-gradient(160deg,#1496f1, #E0F0FA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把伪类的宽设为100%，left ， top值自然就为0了。<br> 这里可以看到，如果要设置渐变，把background设为渐变就可以了，但是注意，我都是把颜色设置在伪类上的。</p>
<p>学会了就快去实现你丰富多彩的界面吧~</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>animation动画结束后css样式怎么保留最后状态</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/animation%E5%8A%A8%E7%94%BB%E7%BB%93%E6%9D%9F%E5%90%8Ecss%E6%A0%B7%E5%BC%8F%E6%80%8E%E4%B9%88%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-fill-mode:forwards</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>样式统一化</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/%E6%A0%B7%E5%BC%8F%E7%BB%9F%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li><a href="http://necolas.gihub.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a></li>
<li><a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">reset.css</a></li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>css权重简述</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/css%E6%9D%83%E9%87%8D%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>CSS权重指的是样式的优先级，有两条或者多条元素作用于同一个元素，权重高的样式会起作用，而权重相同的话，后面的权重会覆盖前面的。</p>
<h3 id="权重的等级"><a href="#权重的等级" class="headerlink" title="权重的等级"></a>权重的等级</h3><p>可以把样式的应用方式分为几个等级，按照等级来计算权重</p>
<ol>
<li><code>!important</code>，加在样式属性值后，权重值为 10000</li>
<li>内联样式，如：<code>style=&quot;&quot;</code>，权重值为1000</li>
<li>ID选择器，如：<code>#content</code>，权重值为100</li>
<li>类，伪类和属性选择器，如： <code>content</code>、<code>:hover</code> 权重值为10</li>
<li>标签选择器和伪元素选择器，如：<code>div</code>、<code>p</code>、<code>:before</code> 权重值为1</li>
<li>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</li>
</ol>
<p>有需要计算权重的时候只需要将以上规则套入然后计算就行了</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>cocos Web构建模板</title>
    <url>/2020/05/25/cocos/cocos%20Web%E6%9E%84%E5%BB%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<blockquote>
<p>V1.9.0模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(1.9.0).zip)</p>
<p>V2.2.2模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(2.2.2).zip)</p>
<p>其实两个都一样，有报错的话自己解决一下就好了</p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>数组篇：chunk分片</title>
    <url>/2020/05/24/loadsh/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%9Achunk%E5%88%86%E7%89%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>loadsh</category>
      </categories>
  </entry>
  <entry>
    <title>cocos两点之间的距离</title>
    <url>/2020/05/21/cocos/cocos%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startPos = cc.v2(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//开始位置</span></span><br><span class="line"><span class="keyword">let</span> endPos = cc.v2(<span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//结束位置</span></span><br><span class="line"><span class="keyword">let</span> distance = startPos.sub(endPos).mag();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>sourcemap概述</title>
    <url>/2020/05/20/%E7%9F%A5%E8%AF%86/sourcemap/sourcemap%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>这里直接摘抄阮一峰老师的博客文章用来理解，本身他讲的就通俗易懂</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html</a></p>
</blockquote>
</blockquote>
<p><a href="http://blog.jquery.com/2013/01/15/jquery-1-9-final-jquery-2-0-beta-migrate-final-released/" target="_blank" rel="noopener">jQuery 1.9</a>发布。</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/sourcemap/sourcemap%E6%A6%82%E8%BF%B0/images/bg2013012203.png" alt="img"></p>
<p>这是2.0版之前的最后一个新版本，有很多新功能，其中一个就是支持Source Map。</p>
<p>访问 <a href="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，打开压缩后的版本，滚动到底部，你可以看到最后一行是这样的：" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，打开压缩后的版本，滚动到底部，你可以看到最后一行是这样的：</a></p>
<p>这就是Source Map。它是一个独立的map文件，与源码在同一个目录下，你可以<a href="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.map" target="_blank" rel="noopener">点击进去</a>，看看它的样子。</p>
<p>这是一个很有用的功能，本文将详细讲解这个功能。</p>
<h2 id="一、从源码转换讲起"><a href="#一、从源码转换讲起" class="headerlink" title="一、从源码转换讲起"></a>一、从源码转换讲起</h2><p>JavaScript脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。</p>
<p>常见的源码转换，主要是以下三种情况：</p>
<p>（1）压缩，减小体积。比如jQuery 1.9的源码，压缩前是252KB，压缩后是32KB。</p>
<p>（2）多个文件合并，减少HTTP请求数。</p>
<p>（3）其他语言编译成JavaScript。最常见的例子就是CoffeeScript。</p>
<p>这三种情况，都使得实际运行的代码不同于开发代码，除错（debug）变得困难重重。</p>
<p>通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。</p>
<p>这就是Source map想要解决的问题。</p>
<h2 id="二、什么是Source-map"><a href="#二、什么是Source-map" class="headerlink" title="二、什么是Source map"></a>二、什么是Source map</h2><p>简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p>
<p>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/sourcemap/sourcemap%E6%A6%82%E8%BF%B0/images/bg2013012204.png" alt="img"></p>
<p>目前，暂时只有Chrome浏览器支持这个功能。在Developer Tools的Setting设置中，确认选中<code>&quot;Enable source maps&quot;</code>。</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/sourcemap/sourcemap%E6%A6%82%E8%BF%B0/images/bg2013012201.png" alt="img"></p>
<h2 id="三、如何启用Source-map"><a href="#三、如何启用Source-map" class="headerlink" title="三、如何启用Source map"></a>三、如何启用Source map</h2><p>正如前文所提到的，只要在转换后的代码尾部，加上一行就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　&#x2F;&#x2F;@ sourceMappingURL&#x3D;&#x2F;path&#x2F;to&#x2F;file.js.map</span><br></pre></td></tr></table></figure>

<p><code>map</code>文件可以放在网络上，也可以放在本地文件系统。</p>
<h2 id="四、如何生成Source-map"><a href="#四、如何生成Source-map" class="headerlink" title="四、如何生成Source map"></a><strong>四、如何生成Source map</strong></h2><blockquote>
<p>这里不太对，现在前端webpack，gulp都可以自己生成sourcmap,这一段了解一下就行了，毕竟是好早的了。</p>
</blockquote>
<p>最常用的方法是使用Google的<a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure编译器</a>。</p>
<p>生成命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　java -jar compiler.jar \</span><br><span class="line">　　　　--js script.js \</span><br><span class="line">　　　　--create_source_map .&#x2F;script-min.js.map \</span><br><span class="line">　　　　--source_map_format&#x3D;V3 \</span><br><span class="line">　　　　--js_output_file script-min.js</span><br></pre></td></tr></table></figure>

<p>各个参数的意义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- js： 转换前的代码文件</span><br><span class="line">　　- create_source_map： 生成的source map文件</span><br><span class="line">　　- source_map_format：source map的版本，目前一律采用V3。</span><br><span class="line">　　- js_output_file： 转换后的代码文件。</span><br></pre></td></tr></table></figure>

<h2 id="五、Source-map的格式"><a href="#五、Source-map的格式" class="headerlink" title="五、Source map的格式"></a><strong>五、Source map的格式</strong></h2><p>打开Source map文件，它大概是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　 &#123;</span><br><span class="line">　　　　version : 3,</span><br><span class="line">　　　　file: &quot;out.js&quot;,</span><br><span class="line">　　　　sourceRoot : &quot;&quot;,</span><br><span class="line">　　　　sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span><br><span class="line">　　　　names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span><br><span class="line">　　　　mappings: &quot;AAgBC,SAAQ,CAAEA&quot;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>整个文件就是一个JavaScript对象，可以被解释器读取。它主要有以下几个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- version：Source map的版本，目前为3。</span><br><span class="line"></span><br><span class="line">- file：转换后的文件名。</span><br><span class="line"></span><br><span class="line">- sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</span><br><span class="line"></span><br><span class="line">- sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。</span><br><span class="line"></span><br><span class="line">- names：转换前的所有变量名和属性名。</span><br><span class="line"></span><br><span class="line">- mappings：记录位置信息的字符串，下文详细介绍。</span><br></pre></td></tr></table></figure>

<h2 id="六、mappings属性"><a href="#六、mappings属性" class="headerlink" title="六、mappings属性"></a><strong>六、mappings属性</strong></h2><p>下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。</p>
<p>关键就是map文件的mappings属性。这是一个很长的字符串，它分成三层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。</span><br><span class="line"></span><br><span class="line">第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。</span><br><span class="line"></span><br><span class="line">第三层是位置转换，以VLQ编码表示，代表该位置对应的转换前的源码位置。</span><br></pre></td></tr></table></figure>

<p>举例来说，假定mappings属性的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mappings:&quot;AAAAA,BBBBB;CCCCC&quot;</span><br></pre></td></tr></table></figure>

<p>就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。</p>
<h2 id="七、位置对应的原理"><a href="#七、位置对应的原理" class="headerlink" title="七、位置对应的原理"></a><strong>七、位置对应的原理</strong></h2><p>每个位置使用五位，表示五个字段。</p>
<p>从左边算起，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　- 第一位，表示这个位置在（转换后的代码的）的第几列。</span><br><span class="line"></span><br><span class="line">　　- 第二位，表示这个位置属于sources属性中的哪一个文件。</span><br><span class="line"></span><br><span class="line">　　- 第三位，表示这个位置属于转换前代码的第几行。</span><br><span class="line"></span><br><span class="line">　　- 第四位，表示这个位置属于转换前代码的第几列。</span><br><span class="line"></span><br><span class="line">　　- 第五位，表示这个位置属于names属性中的哪一个变量。</span><br></pre></td></tr></table></figure>

<p>有几点需要说明。首先，所有的值都是以0作为基数的。其次，第五位不是必需的，如果该位置没有对应names属性中的变量，可以省略第五位。再次，每一位都采用VLQ编码表示；由于VLQ编码是变长的，所以每一位可以由多个字符构成。</p>
<p>如果某个位置是AAAAA，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。</p>
<h2 id="八、VLQ编码"><a href="#八、VLQ编码" class="headerlink" title="八、VLQ编码"></a><strong>八、VLQ编码</strong></h2><p>最后，谈谈如何用<a href="http://en.wikipedia.org/wiki/Variable-length_quantity" target="_blank" rel="noopener">VLQ编码</a>表示数值。</p>
<p>这种编码最早用于MIDI文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。</p>
<p>VLQ编码是变长的。如果（整）数值在-15到+15之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用6个两进制位，正好可以借用<a href="http://en.wikipedia.org/wiki/Base_64" target="_blank" rel="noopener">Base 64</a>编码的字符表。</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/sourcemap/sourcemap%E6%A6%82%E8%BF%B0/images/bg2013012202.png" alt="img"></p>
<p>在这6个位中，左边的第一位（最高位）表示是否”连续”（continuation）。如果是1，代表这６个位后面的6个位也属于同一个数；如果是0，表示该数值到这6个位结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　Continuation</span><br><span class="line">　　|　　　　　Sign</span><br><span class="line">　　|　　　　　|</span><br><span class="line">　　V　　　　　V</span><br><span class="line">　　１０１０１１</span><br></pre></td></tr></table></figure>

<p>这6个位中的右边最后一位（最低位）的含义，取决于这6个位是否是某个数值的VLQ编码的第一个字符。如果是的，这个位代表”符号”（sign），0为正，1为负（Source map的符号固定为0）；如果不是，这个位没有特殊含义，被算作数值的一部分。</p>
<h2 id="九、VLQ编码：实例"><a href="#九、VLQ编码：实例" class="headerlink" title="九、VLQ编码：实例"></a><strong>九、VLQ编码：实例</strong></h2><p>下面看一个例子，如何对数值16进行VLQ编码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　第一步，将16改写成二进制形式10000。</span><br><span class="line"></span><br><span class="line">　　第二步，在最右边补充符号位。因为16大于0，所以符号位为0，整个数变成100000。</span><br><span class="line"></span><br><span class="line">　　第三步，从右边的最低位开始，将整个数每隔5位，进行分段，即变成1和00000两段。如果最高位所在的段不足5位，则前面补0，因此两段变成00001和00000。</span><br><span class="line"></span><br><span class="line">　　第四步，将两段的顺序倒过来，即00000和00001。</span><br><span class="line"></span><br><span class="line">　　第五步，在每一段的最前面添加一个&quot;连续位&quot;，除了最后一段为0，其他都为1，即变成100000和000001。</span><br><span class="line"></span><br><span class="line">　　第六步，将每一段转成Base 64编码。</span><br></pre></td></tr></table></figure>

<p>查表可知，100000为g，000001为B。因此，数值16的VLQ编码为gB。上面的过程，看上去好像很复杂，做起来其实很简单，具体的实现请看官方的<a href="https://github.com/mozilla/source-map/blob/master/lib/source-map/base64-vlq.js" target="_blank" rel="noopener">base64-vlq.js</a>文件，里面有详细的注释。</p>
<h2 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a><strong>十、参考链接</strong></h2><p>　　- <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="noopener">Introduction To JavaScript Source Maps</a><br>　　- <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit" target="_blank" rel="noopener">Source Map Revision 3 Proposal</a></p>
]]></content>
  </entry>
  <entry>
    <title>cocos龙骨局部换装</title>
    <url>/2020/05/16/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>在cocos中，动画是必不可少的，一个细腻的动画可能就是决定一款游戏的成败。对于一些没钱的开发者来说，龙骨动画是一个不错的选择，但是cocos对其的支持并不是十分的友好。这次我们需要解决的是换装的问题。</p>
<p>案例：v2.2.2编辑器，<a href="/static/cocos/cocos龙骨局部换装/files/龙骨插槽替换.zip">龙骨插槽替换.zip</a></p>
</blockquote>
<a id="more"></a>

<h2 id="需要实现的效果"><a href="#需要实现的效果" class="headerlink" title="需要实现的效果"></a>需要实现的效果</h2><p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143013713.png" alt="image-20200517143013713"></p>
<p>上面是原始效果，可以看到有两个插槽,一个是<code>fish</code>,一个是<code>number</code>。这个时候cocos并不能替换，因为是空的，因此就需要随便添加两个资源。</p>
<p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143122750.png" alt="image-20200517143122750"></p>
<p>这里我就添加<code>fish</code>插槽，那个<code>number</code>感觉太麻烦了，是一个滚动的数字。这样的话就能够使用cocos官方提供的方式进行换装替换 了。</p>
<h3 id="制作龙骨模型替换资源"><a href="#制作龙骨模型替换资源" class="headerlink" title="制作龙骨模型替换资源"></a>制作龙骨模型替换资源</h3><p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143330120.png" alt="image-20200517143330120"></p>
<blockquote>
<ul>
<li><code>Armature</code>表示 部件名称</li>
<li><code>killboss_bx</code>表示 插槽名称</li>
<li><code>kypy_killboss_hjcts</code>表示 插槽中的显示资源名称</li>
</ul>
</blockquote>
<p>接下来对两个资源进行导出，根据论坛中引擎开发人员的建议，将<code>_tex.json</code>后缀的改成了<code>_atlas.json</code>的。类似于</p>
<p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143824254.png" alt="image-20200517143824254"></p>
<p>这样的话准备条件就做好了。不过仍有两种方式。</p>
<h3 id="挂载节点替换"><a href="#挂载节点替换" class="headerlink" title="挂载节点替换"></a>挂载节点替换</h3><p>总代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;,</span><br><span class="line">        c: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    start () &#123;</span><br><span class="line">    	&#x2F;&#x2F; 需要被替换的fish插槽</span><br><span class="line">        let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;);</span><br><span class="line">        let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">        factory.replaceSlotDisplay(</span><br><span class="line">            this.c.getArmatureKey(), </span><br><span class="line">            &quot;Armature&quot;, &#x2F;&#x2F;  部件名称</span><br><span class="line">            &quot;killboss_bx&quot;, &#x2F;&#x2F; 插槽名称</span><br><span class="line">            &quot;kypy_killboss_mgy&quot;,  &#x2F;&#x2F; 显示资源名称</span><br><span class="line">            robotSlot</span><br><span class="line">        );</span><br><span class="line">        this.b.playAnimation(&quot;animation&quot;, 500);  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的<code>b</code>表示需要被替换资源的龙骨动画节点组件,<code>c</code>表示将要拿去替换的龙骨节点组件。</p>
<p>这里要保证<code>c</code>中的资源已经加载完毕，在我测试的时候，c节点必须处于激活状态，这样才保证了c节点中龙骨资源的加载。</p>
<h3 id="loader动态加载（推荐）"><a href="#loader动态加载（推荐）" class="headerlink" title="loader动态加载（推荐）"></a>loader动态加载（推荐）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;,</span><br><span class="line">        c: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    loadBones(cb) &#123;</span><br><span class="line">        let name &#x3D; &quot;NewProject&quot;</span><br><span class="line">        const resources &#x3D; [</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_ske.json&#96;),</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_atlas.json&#96;),</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_tex.png&#96;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        cc.loader.load(resources, (err, assets) &#x3D;&gt; &#123;</span><br><span class="line">            let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">            let data &#x3D; JSON.parse(cc.loader.getRes(resources[0])._dragonBonesJson);</span><br><span class="line">            factory.parseDragonBonesData(data);</span><br><span class="line"></span><br><span class="line">            let atlasData &#x3D; JSON.parse(cc.loader.getRes(resources[1])._atlasJson);</span><br><span class="line">            factory.parseTextureAtlasData(atlasData, cc.loader.getRes(resources[2]));</span><br><span class="line">            console.log(cc.loader.getRes(resources[1])._atlasJson);</span><br><span class="line">            </span><br><span class="line">            cb&amp;&amp;cb()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    start () &#123;</span><br><span class="line">        this.loadBones(()&#x3D;&gt;&#123;</span><br><span class="line">            let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;);</span><br><span class="line">            let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">            factory.replaceSlotDisplay(</span><br><span class="line">                &quot;NewProject&quot;,  &#x2F;&#x2F; 跟上面的一样就行了。</span><br><span class="line">                &quot;Armature&quot;, </span><br><span class="line">                &quot;killboss_bx&quot;, </span><br><span class="line">                &quot;kypy_killboss_mgy&quot;, </span><br><span class="line">                robotSlot</span><br><span class="line">            );</span><br><span class="line">            this.b.playAnimation(&quot;animation&quot;, 500); </span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; this.b.playAnimation(&quot;animation&quot;, 500);   </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我用的是<code>cc.loader.load</code>方式，这样就能保证资源已经加载完毕了。同时也减少了节点的创建。推荐使用这种方式。</p>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ol>
<li>被换装的插槽里必须有资源才行，空的一个插槽并不能替换。</li>
<li>换装的资源必须加载。如果挂载在节点上必须保证这个节点是激活状态而证明资源是加载过的。</li>
</ol>
<blockquote>
<p>参考资料</p>
<p><a href="https://forum.cocos.org/t/topic/89037" target="_blank" rel="noopener">https://forum.cocos.org/t/topic/89037</a></p>
<p><a href="https://docs.cocos.com/creator/manual/zh/components/dragonbones.html?h=插槽" target="_blank" rel="noopener">https://docs.cocos.com/creator/manual/zh/components/dragonbones.html?h=%E6%8F%92%E6%A7%BD</a></p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器的同源策略</title>
    <url>/2020/05/15/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/源" target="_blank" rel="noopener">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
</blockquote>
<h3 id="同源的例子"><a href="#同源的例子" class="headerlink" title="同源的例子"></a>同源的例子</h3><table>
<thead>
<tr>
<th><code>http://example.com/app1/index.html</code> <code>http://example.com/app2/index.html</code></th>
<th>same origin because same scheme (<code>http</code>) and host (<code>example.com</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><code>http://Example.com:80</code> <code>http://example.com</code></td>
<td>same origin because a server delivers HTTP content through port 80 by default</td>
</tr>
</tbody></table>
<h3 id="不同源的例子"><a href="#不同源的例子" class="headerlink" title="不同源的例子"></a>不同源的例子</h3><table>
<thead>
<tr>
<th><code>http://example.com/app1</code> <code>https://example.com/app2</code></th>
<th>different schemes</th>
</tr>
</thead>
<tbody><tr>
<td><code>http://example.com</code> <code>http://www.example.com</code> <code>http://myapp.example.com</code></td>
<td>different hosts</td>
</tr>
<tr>
<td><code>http://example.com</code> <code>http://example.com:8080</code></td>
<td>different ports</td>
</tr>
</tbody></table>
<h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a><strong>同源</strong>的<strong>定义</strong></h2><p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/port" target="_blank" rel="noopener">port</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/host" target="_blank" rel="noopener">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">结果</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://store.company.com/dir2/other.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com/dir/inner/another.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>https://store.company.com/secure.html</code></td>
<td align="left">失败</td>
<td align="left">协议不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com:81/dir/etc.html</code></td>
<td align="left">失败</td>
<td align="left">端口不同 ( <code>http://</code> 默认端口是80)</td>
</tr>
<tr>
<td align="left"><code>http://news.company.com/dir/other.html</code></td>
<td align="left">失败</td>
<td align="left">主机不同</td>
</tr>
</tbody></table>
<h3 id="源的-继承"><a href="#源的-继承" class="headerlink" title="源的**继承**"></a><strong>源的**</strong>继承**</h3><p>在页面中通过 <code>about:blank</code> 或 <code>javascript:</code> URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。</p>
<blockquote>
<p>例如，<code>about:blank</code> 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/open" target="_blank" rel="noopener">Window.open()</a> ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p>
</blockquote>
<blockquote>
<p>注意：在Gecko 6.0之前，如果用户在位置栏中输入 <code>data</code> URLs，<code>data</code> URLs 将继承当前浏览器窗口中网页的安全上下文。</p>
</blockquote>
<blockquote>
<p><code>data</code>：URLs 获得一个新的，空的安全上下文。</p>
</blockquote>
<h3 id="IE-中的特例"><a href="#IE-中的特例" class="headerlink" title="IE 中的特例"></a><strong>IE 中的特例</strong></h3><p>Internet Explorer 的同源策略有两个主要的差异点：</p>
<ul>
<li><strong>授信范围</strong>（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），则不受同源策略限制。</li>
<li><strong>端口</strong>：IE 未将端口号纳入到同源策略的检查中，因此 <code>https://company.com:81/index.html</code> 和 <code>https://company.com/index.html</code> 属于同源并且不受任何限制。</li>
</ul>
<p>这些差异点是不规范的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。</p>
<h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a><strong>源</strong>的更改</h2><p>满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain" target="_blank" rel="noopener"><code>document.domain</code></a> 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。</p>
<p>例如：假设 <a href="http://store.company.com/dir/other.html" target="_blank" rel="noopener">http://store.company.com/dir/other.html</a> 文档中的一个脚本执行以下语句：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.domain = "company.com";</span><br></pre></td></tr></table></figure>

<p>这条语句执行之后，页面将会成功地通过与 <code>http://company.com/dir/page.html</code> 的同源检测（假设<code>http://company.com/dir/page.html</code> 将其 <code>document.domain</code> 设置为“<code>company.com</code>”，以表明它希望允许这样做 - 更多有关信息，请参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain" target="_blank" rel="noopener"><code>document.domain</code></a> ）。然而，<code>company.com</code> 不能设置 <code>document.domain</code> 为 <code>othercompany.com</code>，因为它不是 <code>company.com</code> 的父域。</p>
<p>端口号是由浏览器另行检查的。任何对document.domain的赋值操作，包括 <code>document.domain = document.domain</code> 都会导致端口号被重写为 <code>null</code> 。因此 <code>company.com:8080</code> <strong>不能</strong>仅通过设置 <code>document.domain = &quot;company.com&quot;</code> 来与<code>company.com</code> 通信。必须在他们双方中都进行赋值，以确保端口号都为 <code>null</code> 。</p>
<blockquote>
<p>注意：使用 <code>document.domain</code> 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误。</p>
</blockquote>
<h2 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h2><p>同源策略控制不同源之间的交互，例如在使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img" target="_blank" rel="noopener"><code>![img](/D:/app/Typora)</code></a> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p>
<ul>
<li>跨域<strong>*写操作</strong>（Cross-origin writes）<em>一般是被允许的</em>。*例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 <a href="https://developer.mozilla.org/zh-CN/docs/HTTP/Access_control_CORS#Preflighted_requests" target="_blank" rel="noopener">preflight</a>。</li>
<li>跨域<strong>*资源嵌入</strong>（Cross-origin embedding）*一般是被允许（后面会举例说明）。</li>
<li>跨域<strong>*读操作</strong>（Cross-origin reads）<em>一般是不被允许的</em>，*但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或<a href="https://grepular.com/Abusing_HTTP_Status_Codes_to_Expose_Private_Information" target="_blank" rel="noopener">availability of an embedded resource</a>.</li>
</ul>
<p>以下是可能嵌入跨源的资源的一些示例：</p>
<ul>
<li><p><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本。语法错误信息只能被同源脚本中捕捉到。</p>
</li>
<li><p>`` 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的 HTTP 头部 <code>Content-Type</code> 。不同浏览器有不同的限制： <a href="http://msdn.microsoft.com/zh-CN/library/ie/gg622939(v=vs.85).aspx" target="_blank" rel="noopener">IE</a>, <a href="http://www.mozilla.org/security/announce/2010/mfsa2010-46.html" target="_blank" rel="noopener">Firefox</a>, <a href="http://code.google.com/p/chromium/issues/detail?id=9877" target="_blank" rel="noopener">Chrome</a>, <a href="http://support.apple.com/kb/HT4070" target="_blank" rel="noopener">Safari</a> (跳至CVE-2010-0051)部分 和 <a href="http://www.opera.com/support/kb/view/943/" target="_blank" rel="noopener">Opera</a>。</p>
</li>
<li><p>通过 <code>&lt;img&gt;</code> 展示的图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,…</p>
</li>
<li><p>通过<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>播放的多媒体资源。</p>
</li>
<li><p>通过<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;applet&gt;</code>嵌入的插件。</p>
</li>
<li><p>通过 <code>@font-face</code> 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</p>
</li>
<li><p>通过 <code>&lt;iframe&gt;</code> 载入的任何资源。站点可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/HTTP/X-Frame-Options" target="_blank" rel="noopener">X-Frame-Options</a> 消息头来阻止这种形式的跨域交互。</p>
</li>
</ul>
<h3 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a><strong>如何允许跨源访问</strong></h3><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a> 来允许跨源访问。CORS 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP" target="_blank" rel="noopener">HTTP</a> 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p>
<h3 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a><strong>如何阻止跨源访问</strong></h3><p>阻止跨域写操作，只要检测请求中的一个不可推测的标记(CSRF token)即可，这个标记被称为 <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noopener">Cross-Site Request Forgery (CSRF)</a> 标记。你必须使用这个标记来阻止页面的跨站读操作。</p>
<p>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</p>
<p>阻止跨站嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 <code>Content-Type</code> 头部定义的类型。例如，如果您在HTML文档中指定 `` 标记，则浏览器将尝试将标签内部的 HTML 解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。</p>
<h2 id="跨源脚本API访问"><a href="#跨源脚本API访问" class="headerlink" title="跨源脚本API访问"></a>跨源脚本API访问</h2><p>JavaScript 的 API 中，如 <code>iframe.contentWindow</code>、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/parent" target="_blank" rel="noopener"><code>window.parent</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open" target="_blank" rel="noopener"><code>window.open</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/opener" target="_blank" rel="noopener"><code>window.opener</code></a> 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window" target="_blank" rel="noopener">Window</a> 和 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#security-location" target="_blank" rel="noopener">Location</a>对象的访问添加限制，如下两节所述。</p>
<p>为了能让不同源中文档进行交流，可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener"><code>window.postMessage</code></a>。</p>
<p>规范: <a href="https://html.spec.whatwg.org/multipage/browsers.html#cross-origin-objects" target="_blank" rel="noopener">HTML Living Standard § Cross-origin objects</a> 。</p>
<h3 id="允许以下对-Window-属性的跨源访问："><a href="#允许以下对-Window-属性的跨源访问：" class="headerlink" title="允许以下对 Window 属性的跨源访问："></a>允许以下对 <code>Window</code> 属性的跨源访问：</h3><table>
<thead>
<tr>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/blur" target="_blank" rel="noopener"><code>window.blur</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/close" target="_blank" rel="noopener"><code>window.close</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/focus" target="_blank" rel="noopener"><code>window.focus</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener"><code>window.postMessage</code></a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/closed" target="_blank" rel="noopener"><code>window.closed</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frames" target="_blank" rel="noopener"><code>window.frames</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/length" target="_blank" rel="noopener"><code>window.length</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location" target="_blank" rel="noopener"><code>window.location</code></a></td>
<td align="left">读/写.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/opener" target="_blank" rel="noopener"><code>window.opener</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/parent" target="_blank" rel="noopener"><code>window.parent</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/self" target="_blank" rel="noopener"><code>window.self</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/top" target="_blank" rel="noopener"><code>window.top</code></a></td>
<td align="left">只读.</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/window" target="_blank" rel="noopener"><code>window.window</code></a></td>
<td align="left">只读.</td>
</tr>
</tbody></table>
<p>某些浏览器允许访问除上述外更多的属性。</p>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>允许以下对 <code>Location</code> 属性的跨源访问：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location/replace" target="_blank" rel="noopener"><code>location.replace</code></a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLUtils/href" target="_blank" rel="noopener"><code>URLUtils.href</code></a></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>某些浏览器允许访问除上述外更多的属性。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
</blockquote>
<h2 id="跨源数据存储访问"><a href="#跨源数据存储访问" class="headerlink" title="跨源数据存储访问"></a>跨源数据存储访问</h2><p>访问存储在浏览器中的数据，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage" target="_blank" rel="noopener">localStorage</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/IndexedDB" target="_blank" rel="noopener">IndexedDB</a>，是以源进行分割。每个源都拥有自己单独的存储空间，一个源中的 JavaScript 脚本不能对属于其它源的数据进行读写操作。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cookie" target="_blank" rel="noopener">Cookies</a> 使用不同的源定义方式。一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 <a href="http://publicsuffix.org/" target="_blank" rel="noopener">Public Suffix List</a> 检测一个域是否是公共后缀（public suffix）。Internet Explorer 使用其内部的方法来检测域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。当你设置 cookie 时，你可以使用 <code>Domain</code>、<code>Path</code>、<code>Secure</code>、和 <code>HttpOnly</code> 标记来限定其可访问性。当你读取 cookie 时，你无法知道它是在哪里被设置的。 即使您只使用安全的 https 连接，您看到的任何 cookie 都有可能是使用不安全的连接进行设置的。</p>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><ul>
<li><a href="http://www.w3.org/Security/wiki/Same_Origin_Policy" target="_blank" rel="noopener">Same-Origin Policy at W3C</a></li>
<li><a href="http://web.dev/secure/same-origin-policy" target="_blank" rel="noopener">http://web.dev/secure/same-origin-policy</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>560. 和为K的子数组</title>
    <url>/2020/05/15/leetcode/560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>输入的第一个形参是数组，第二个表示和。</p>
<p>数组的长度有限制。另外：</p>
<ol>
<li>求和的不一定是两个，可能有三个四个五个</li>
<li>大于k的也不一定不行，因为下一个可能是负数给抵消了</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>暴力遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var subarraySum &#x3D; function(nums, k) &#123;</span><br><span class="line">    let result &#x3D; 0;</span><br><span class="line">    for(let i &#x3D; 0; i&lt;&#x3D; nums.length; i++ )&#123;</span><br><span class="line">        let sum &#x3D; 0;</span><br><span class="line">        for(let j &#x3D; i; j&lt;&#x3D; nums.length; j++ )&#123;</span><br><span class="line">            sum +&#x3D; nums[j];</span><br><span class="line">            if(sum&#x3D;&#x3D;k)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他题解"><a href="#其他题解" class="headerlink" title="其他题解"></a>其他题解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var subarraySum &#x3D; function(nums, k) &#123;</span><br><span class="line">    const mp &#x3D; new Map();</span><br><span class="line">    mp.set(0, 1);</span><br><span class="line">    let count &#x3D; 0, pre &#x3D; 0;</span><br><span class="line">    for (const x of nums) &#123;</span><br><span class="line">        pre +&#x3D; x;</span><br><span class="line">        if (mp.has(pre - k)) count +&#x3D; mp.get(pre - k);</span><br><span class="line">        if (mp.has(pre)) mp.set(pre, mp.get(pre) + 1);</span><br><span class="line">        else mp.set(pre, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>10种跨域解决方案（终极大招）</title>
    <url>/2020/05/14/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%89%8D%E7%AB%AF/10%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E7%BB%88%E6%9E%81%E5%A4%A7%E6%8B%9B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>原文链接</p>
<p><a href="https://juejin.im/post/5e948bbbf265da47f2561705" target="_blank" rel="noopener">https://juejin.im/post/5e948bbbf265da47f2561705</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>scss主题切换功能</title>
    <url>/2020/05/14/%E5%89%8D%E7%AB%AF/scss%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>结构类似下面这样：</p>
<p><img src="/static/%E5%89%8D%E7%AB%AF/scss%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD/images/image-20200514140159247.png" alt="image-20200514140159247"></p>
<p><strong><code>index.html</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot;</span><br><span class="line">          content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;index.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body data-theme&#x3D;&quot;light&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app-home&quot;&gt;</span><br><span class="line">        dsakdjsafs</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>index.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &#39;.&#x2F;_themeify.scss&#39;;</span><br><span class="line"></span><br><span class="line">.app-home &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  @include themeify &#123;</span><br><span class="line">    color: themed(&#39;text-color-primary&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_themeify.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &#39;.&#x2F;_themes.scss&#39;;</span><br><span class="line"></span><br><span class="line">@mixin themeify &#123;</span><br><span class="line">  @each $theme-name, $theme-map in $themes &#123;</span><br><span class="line">    $theme-map: $theme-map !global;</span><br><span class="line">    body[data-theme&#x3D;#&#123;$theme-name&#125;] &amp; &#123;</span><br><span class="line">      @content;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@function themed($key) &#123;</span><br><span class="line">  @return map-get($theme-map, $key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>_themes.scss</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$themes: (</span><br><span class="line">        default: (</span><br><span class="line">          &#x2F;* font-size *&#x2F;</span><br><span class="line">                font-size-default: 14px,</span><br><span class="line">                font-size-lg: 16px,</span><br><span class="line">                font-size-sm: 12px,</span><br><span class="line">                color-white: #FFF,</span><br><span class="line">          &#x2F;* Color *&#x2F;</span><br><span class="line">                color-success: #13CE66,</span><br><span class="line">                color-error: #FF4949,</span><br><span class="line">                color-warning: #FFC82C,</span><br><span class="line">                color-info: #78A4FA,</span><br><span class="line">          &#x2F;&#x2F; Text Color</span><br><span class="line">                text-color-primary: #dc2b34,</span><br><span class="line">                text-color-white: #ffffff,</span><br><span class="line">                text-color-black: #000000,</span><br><span class="line">                text-color-default: #4a4a4a,</span><br><span class="line">                text-color-placeholder: #C9C9C9,</span><br><span class="line">                text-color-disabled: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Background Color</span><br><span class="line">                bg-color-primary: #d91720,</span><br><span class="line">                bg-color-primary-light: #b51d29,</span><br><span class="line">                bg-color-white: #ffffff,</span><br><span class="line">                bg-color-grey: #F7F7F7,</span><br><span class="line">                bg-color-light: #ECF5FD,</span><br><span class="line">                bg-color-verifycode: #cfcfcf,</span><br><span class="line">          &#x2F;&#x2F; Border Color</span><br><span class="line">                borer-color-primary: #e64644,</span><br><span class="line">                borer-color-primary-light: #dc2b34,</span><br><span class="line">                borer-color-white: #ffffff,</span><br><span class="line">                borer-color-default: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Link Color</span><br><span class="line">                link-color-primary: #d91721,</span><br><span class="line">                link-color-primary-light: #b51d29,</span><br><span class="line">                link-color: #6190E8,</span><br><span class="line">                link-color-light: #79A1EB,</span><br><span class="line">                link-color-disabled: #BFBFBF,</span><br><span class="line">          &#x2F;&#x2F; Icon Color</span><br><span class="line">                icon-color-base: #CCC,</span><br><span class="line">        ),</span><br><span class="line">        light: (</span><br><span class="line">          &#x2F;* font-size *&#x2F;</span><br><span class="line">                font-size-default: 14px,</span><br><span class="line">                font-size-lg: 16px,</span><br><span class="line">                font-size-sm: 12px,</span><br><span class="line">                color-white: #FFF,</span><br><span class="line">          &#x2F;* Color *&#x2F;</span><br><span class="line">                color-success: #13CE66,</span><br><span class="line">                color-error: #FF4949,</span><br><span class="line">                color-warning: #FFC82C,</span><br><span class="line">                color-info: #78A4FA,</span><br><span class="line">          &#x2F;&#x2F; Text Color</span><br><span class="line">                text-color-primary: #78A4FA,</span><br><span class="line">                text-color-white: #ffffff,</span><br><span class="line">                text-color-black: #000000,</span><br><span class="line">                text-color-default: #4a4a4a,</span><br><span class="line">                text-color-placeholder: #C9C9C9,</span><br><span class="line">                text-color-disabled: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Background Color</span><br><span class="line">                bg-color-primary: #d91720,</span><br><span class="line">                bg-color-primary-light: #b51d29,</span><br><span class="line">                bg-color-white: #ffffff,</span><br><span class="line">                bg-color-grey: #F7F7F7,</span><br><span class="line">                bg-color-light: #ECF5FD,</span><br><span class="line">                bg-color-verifycode: #cfcfcf,</span><br><span class="line">          &#x2F;&#x2F; Border Color</span><br><span class="line">                borer-color-primary: #e64644,</span><br><span class="line">                borer-color-primary-light: #dc2b34,</span><br><span class="line">                borer-color-white: #ffffff,</span><br><span class="line">                borer-color-default: #CCCCCC,</span><br><span class="line">          &#x2F;&#x2F; Link Color</span><br><span class="line">                link-color-primary: #d91721,</span><br><span class="line">                link-color-primary-light: #b51d29,</span><br><span class="line">                link-color: #6190E8,</span><br><span class="line">                link-color-light: #79A1EB,</span><br><span class="line">                link-color-disabled: #BFBFBF,</span><br><span class="line">          &#x2F;&#x2F; Icon Color</span><br><span class="line">                icon-color-base: #CCC,</span><br><span class="line">        ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面只需要切换<code>data-theme</code>的名字就行了，一共内置了两套主题。</p>
</blockquote>
<p><strong>编译过后的css</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@charset &quot;UTF-8&quot;;</span><br><span class="line">.app-home &#123;</span><br><span class="line">  font-size: 18px; &#125;</span><br><span class="line">  body[data-theme&#x3D;default] .app-home &#123;</span><br><span class="line">    color: #dc2b34; &#125;</span><br><span class="line">  body[data-theme&#x3D;light] .app-home &#123;</span><br><span class="line">    color: #78A4FA; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出就是做了两套兼容而已。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>随机概率分析</title>
    <url>/2020/05/13/%E5%8E%9F%E5%88%9B/%E9%9A%8F%E6%9C%BA%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><p>Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值</p>
<p>数学表达式：<code>[0,1)</code>左闭右开区间</p>
<p>因此我们将倍率调整到10的话：</p>
<p><code>Math.random()*10--&gt;[0,10)</code></p>
<a id="more"></a>

<p><code>parseInt(Math.random()*10)</code>分析:</p>
<table>
<thead>
<tr>
<th align="center">区间</th>
<th align="center">取整</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[0,1)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">[1,2)</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">[2,3)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">[3,4)</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">[4,5)</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">[5,6)</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">[6,7)</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">[7,8)</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">[8,9)</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">[9,10)</td>
<td align="center">9</td>
</tr>
</tbody></table>
<p>总结可得：<code>1-10</code>每个数的概率差不多是<code>1/10</code>.大致时一样的。那么我们将倍率调整至100并封装起来试一试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回概率之内的数字</span><br><span class="line"> * @param to 0-to为可随机的数字</span><br><span class="line"> * @param total 总数，to-total为不能随机的数字</span><br><span class="line"> * @returns &#123;number&#125; 0：随机到概率之外的数字，num:概率之内的数字</span><br><span class="line"> *&#x2F;</span><br><span class="line">function randomInt(to,total) &#123;</span><br><span class="line">    if (arguments.length!&#x3D;2||typeof to !&#x3D; &#39;number&#39;||typeof total !&#x3D; &#39;number&#39;)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;to给total扩容</span><br><span class="line">    var total&#x3D;total||100;</span><br><span class="line">    if (to&gt;total)&#123;</span><br><span class="line">        total&#x3D;to;</span><br><span class="line">    &#125;</span><br><span class="line">    var num&#x3D;parseInt(Math.random() * total)+1;</span><br><span class="line">    if (num&gt;to)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;1&#x2F;10概率:</span><br><span class="line">&#x2F;&#x2F;randomInt(1,10)</span><br><span class="line">&#x2F;&#x2F;返回值:0:未隨機到，&gt;0:隨機成功</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该方法主要用来代替<code>parseInt(Math.random()*10)&lt;1</code>此类的表达式</p>
</blockquote>
<p>再添加一个范围内随机，<br>用法：<code>[30,30,40]</code>表示从100中随机取值，1的概率时30%,2的概率是30%,3的概率是40%,获得的是传入的概率值索引+1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function randomRangeInt(args) &#123;</span><br><span class="line">    if (!args||args.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var sum&#x3D;0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum+&#x3D;args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    var total&#x3D;sum;</span><br><span class="line">    var length&#x3D;args.length;</span><br><span class="line">    var num&#x3D;parseInt(Math.random() * total)+1;</span><br><span class="line">    var index&#x3D;0;</span><br><span class="line">    var sum_2&#x3D;0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        sum_2+&#x3D;args[i];</span><br><span class="line">        if (num&lt;&#x3D;sum_2)&#123;</span><br><span class="line">            index&#x3D;i+1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展文章</p>
<p><a href="https://fed.taobao.org/blog/taofed/do71ct/some-thing-about-random/?spm=taofed.homepage.header.7.7eab5ac81EtpFe" target="_blank" rel="noopener">https://fed.taobao.org/blog/taofed/do71ct/some-thing-about-random/?spm=taofed.homepage.header.7.7eab5ac81EtpFe</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>rem响应式原理</title>
    <url>/2020/05/13/%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF/rem%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>参考文章</strong></p>
<p><a href="https://blog.csdn.net/qq_36263601/article/details/78366710" target="_blank" rel="noopener">https://blog.csdn.net/qq_36263601/article/details/78366710</a></p>
<p><a href="https://segmentfault.com/a/1190000007526917" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007526917</a></p>
<p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">https://github.com/amfe/lib-flexible</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>低版本vue打包之后一片空白</title>
    <url>/2020/05/13/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/vue/%E4%BD%8E%E7%89%88%E6%9C%ACvue%E6%89%93%E5%8C%85%E4%B9%8B%E5%90%8E%E4%B8%80%E7%89%87%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/dq674362263/article/details/81876445" target="_blank" rel="noopener">https://blog.csdn.net/dq674362263/article/details/81876445</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>作用域是什么</title>
    <url>/2020/05/12/%E9%9A%8F%E6%83%B3/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%20/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>网页棋牌游戏的注意事项</title>
    <url>/2020/05/12/%E9%9A%8F%E6%83%B3/%E7%BD%91%E9%A1%B5%E6%A3%8B%E7%89%8C%E6%B8%B8%E6%88%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="后台-gt-前台"><a href="#后台-gt-前台" class="headerlink" title="后台&gt;前台"></a>后台&gt;前台</h3><p>注意，最简单的办法就是先把界面全部清除，在获取重连数据，根据数据进行界面的重新绘制。清除包括界面一切元素，定时器，动画效果.</p>
]]></content>
  </entry>
  <entry>
    <title>增量时间（deltaTime）</title>
    <url>/2020/05/11/%E7%9F%A5%E8%AF%86/cocos/%E5%A2%9E%E9%87%8F%E6%97%B6%E9%97%B4%EF%BC%88deltaTime%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>作者：EickL<br>链接：<a href="https://www.jianshu.com/p/a628d1e8a8c5" target="_blank" rel="noopener">https://www.jianshu.com/p/a628d1e8a8c5</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>增量时间是根据上一帧更新游戏以来经过的时间，用于动态的更新游戏场景渲染。</p>
<h3 id="基于时间的动画"><a href="#基于时间的动画" class="headerlink" title="基于时间的动画"></a>基于时间的动画</h3><p>在早期游戏开发中，一些游戏的场景移动速度依赖于CPU的运行速度，游戏场景将每帧在屏幕上移动一定数量的像素。如果CPU只能以每秒15帧（FPS）运行游戏，并且游戏场景被代码定义为每秒向左移动10个像素，则游戏场景将以每秒150个像素向左移动。但是，如果性能更好的处理器可以每秒60帧运行游戏呢？游戏场景将以600像素移动！怎么能解决这个问题呢？</p>
<p>解决这个问题的关键是记录自上一帧以来经过的时间。这个时间通常叫做增量时间（deltaTime）。只要我们拿到了增量时间，我们就可以通过使用下面的公式计算出我们的游戏场景应该移动此帧的距离：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const distance &#x3D; speed * deltaTime </span><br><span class="line">&#x2F;&#x2F; 表示一帧移动的距离为speed * deltaTime</span><br><span class="line">&#x2F;&#x2F; 当两个游戏的cpu不同的时候，处理快的deltaTime就小，处理慢的deltaTime就大，主要是为了能够让在不同的处理速度小移动的距离一样。</span><br></pre></td></tr></table></figure>

<p>以上三个变量：</p>
<ul>
<li><code>distance</code>：移动当前帧的像素数</li>
<li><code>speed</code>：每秒像素的速度</li>
<li><code>deltaTime</code>：上一帧以来经过的时间</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const APP.core &#x3D; &#123;</span><br><span class="line"> frame() &#123;</span><br><span class="line"> APP.core.setDelta()</span><br><span class="line"> APP.core.update()</span><br><span class="line"> APP.core.render()</span><br><span class="line"> APP.core.animationFrame &#x3D; window.requestAnimationFrame(APP.core.frame)</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> setDelta() &#123;</span><br><span class="line"> APP.core.now &#x3D; Date.now()</span><br><span class="line"> APP.core.delta &#x3D; (APP.core.now - APP.core.lastTime ) &#x2F; 1000 &#x2F;&#x2F; 上一帧以来经过的秒数</span><br><span class="line"> APP.core.lastTime &#x3D; APP.core.now</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> update() &#123;</span><br><span class="line"> &#x2F;&#x2F; 更新值</span><br><span class="line"> &#x2F;&#x2F; var distance &#x3D; 100 * APP.core.delta</span><br><span class="line"> &#x2F;&#x2F; APP.thing.x +&#x3D; distance</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line"> &#x2F;&#x2F; 渲染更新</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>贝塞尔曲线</title>
    <url>/2020/05/11/%E7%9F%A5%E8%AF%86/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<blockquote>
<p>作者：骑小猪看流星<br>链接：<a href="https://www.jianshu.com/p/0c9b4b681724" target="_blank" rel="noopener">https://www.jianshu.com/p/0c9b4b681724</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="贝赛尔曲线的前世今生："><a href="#贝赛尔曲线的前世今生：" class="headerlink" title="贝赛尔曲线的前世今生："></a>贝赛尔曲线的前世今生：</h5><p>贝塞尔曲线，这个命名规则一眼看上去大概是一个叫贝塞尔的数学家发明的。但，贝塞尔曲线依据的最原始的数学公式，是在1912年在数学界广为人知的伯恩斯坦多项式。</p>
<p>简单理解，伯恩斯坦多项式可以用来证明，在[ a, b ] 区间上所有的连续函数都可以用多项式来逼近，并且收敛性很强，也就是一致收敛。再简单点，就是一个连续函数，你可以将它写成若干个伯恩斯坦多项式相加的形式，并且，随着 n→∞，这个多项式将一致收敛到原函数，这个就是伯恩斯坦斯的逼近性质。</p>
<p>时光荏苒岁月如梭，镜头切换到了1959年。当时就职于雪铁龙的法国数学家 Paul de Casteljau 开始对伯恩斯坦多项式进行了图形化的尝试，并且提供了一种数值稳定的德卡斯特里奥（de Casteljau） 算法。（多数理论公式是建立在大量且系统的数学建模基础之上研究的规律性成果）根据这个算法，就可以实现 <strong>通过很少的控制点，去生成复杂的平滑曲线，也就是贝塞尔曲线</strong>。</p>
<p>但贝塞尔曲线的声名大噪，不得不提到1962年就职于雷诺的法国工程师皮埃尔·贝塞尔（Pierre Bézier），他使用这种方法来辅助汽车的车体工业设计（最早计算机的诞生则是为了帮助美国海军绘制弹道图），并且广泛宣传（典型的理论联系实际并获得成功的示例），因此大家称为贝塞尔曲线 。</p>
</blockquote>
<a id="more"></a>

<h5 id="贝赛尔曲线的数学理论："><a href="#贝赛尔曲线的数学理论：" class="headerlink" title="贝赛尔曲线的数学理论："></a>贝赛尔曲线的数学理论：</h5><p>既然贝赛尔曲线的本质是通过数学计算公式去绘制平滑的曲线，那就可以通过数学工具进行实际求证以及解释说明。当然对其进行数学求证就没必要了，因为这些伟大的数学家们已经做过了，这里只是解释说明：</p>
<ul>
<li><p>步骤一：在平面内选3个不同线的点并且依次用线段连接。如下所示..</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/images/5417430-7ac24ea6e49bb425.webp" alt="img"></p>
</li>
<li><p>步骤二：在AB和BC线段上找出点D和点E，使得 <strong>AD/AB = BE/BC</strong></p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/images/5417430-d4157bc9a6cea222.webp" alt="img"></p>
</li>
<li><p>步骤三：连接DE，在DE上寻找点F，F点需要满足：<strong>DF/DE = AD/AB = BE/BC</strong></p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/images/5417430-894fcaf1a5809cb7.webp" alt="img"></p>
</li>
<li><p>步骤四：最最重要的！<strong>根据DE线段和计算公式找出所有的F点</strong>，记住是所有的F点，然后将其这些点连接起来。那，连接规则是什么？以上图为例，第一个连接点是A-F，第二连接点是A-F1（这个F1必须满足<strong>DF1/DE = AD/AB = BE/BC</strong>）以此类推，直到最后连接上C点，下面上一个动图加深理解：</p>
<p><img src="/static/%E7%9F%A5%E8%AF%86/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/images/5417430-0c59851cc48cadcd.webp" alt="img"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>一镜到底</title>
    <url>/2020/05/09/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E6%88%98/%E4%B8%80%E9%95%9C%E5%88%B0%E5%BA%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Widget</title>
    <url>/2020/05/06/cocos/Widget/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.cocos.com/creator/api/zh/classes/Widget.html#updatealignment" target="_blank" rel="noopener">https://docs.cocos.com/creator/api/zh/classes/Widget.html#updatealignment</a></p>
</blockquote>
<h5 id="updateAlignment"><a href="#updateAlignment" class="headerlink" title="updateAlignment"></a>updateAlignment</h5><p>立刻执行 widget 对齐操作。这个接口一般不需要手工调用。 只有当你需要在当前帧结束前获得 widget 对齐后的最新结果时才需要手动调用这个方法。</p>
<a id="more"></a>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">widget.top = <span class="number">10</span>;       <span class="comment">// change top margin</span></span><br><span class="line">cc.log(widget.node.y); <span class="comment">// not yet changed</span></span><br><span class="line">widget.updateAlignment();</span><br><span class="line">cc.log(widget.node.y); <span class="comment">// changed</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能会遇见的问题</p>
<p><a href="https://blog.csdn.net/u013654125/article/details/83379765" target="_blank" rel="noopener">https://blog.csdn.net/u013654125/article/details/83379765</a></p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>苹果录像有关hevc格式视频的网页播放</title>
    <url>/2020/05/01/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E8%8B%B9%E6%9E%9C%E5%BD%95%E5%83%8F%E6%9C%89%E5%85%B3hevc%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>格式可以使用window上的potplayer播放，右键看属性</p>
<p><a href="http://get.ftqq.com/9132.get" target="_blank" rel="noopener">http://get.ftqq.com/9132.get</a></p>
<p><a href="https://blog.csdn.net/keji_123/article/details/77717849?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">https://blog.csdn.net/keji_123/article/details/77717849?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50655841" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50655841</a></p>
<p><a href="https://tieba.baidu.com/p/5882990363?red_tag=1551058192" target="_blank" rel="noopener">https://tieba.baidu.com/p/5882990363?red_tag=1551058192</a></p>
<a id="more"></a>

<p><img src="/static/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E8%8B%B9%E6%9E%9C%E5%BD%95%E5%83%8F%E6%9C%89%E5%85%B3hevc%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE/images/image-20200501114203764.png" alt="image-20200501114203764"></p>
<p>改成兼容性最佳可以直接播放</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>代码笔记本推荐</title>
    <url>/2020/04/29/%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="Cacher"><a href="#Cacher" class="headerlink" title="Cacher"></a>Cacher</h1><p>其实GitHub上是有提供代码片段管理功能的, 名字叫gist<br>Cacher是它的一个桌面版Interface, 分为免费版, 个人专业版和协作版</p>
<p>官网地址: <a href="https://www.cacher.io/" target="_blank" rel="noopener">https://www.cacher.io/</a></p>
<h1 id="Lepton"><a href="#Lepton" class="headerlink" title="Lepton"></a>Lepton</h1><p>GitHub地址: <a href="https://github.com/hackjutsu/Lepton" target="_blank" rel="noopener">https://github.com/hackjutsu/Lepton</a></p>
<h1 id="Snippet-Store"><a href="#Snippet-Store" class="headerlink" title="Snippet Store"></a>Snippet Store</h1><p>官网地址: <a href="https://zerox-dg.github.io/SnippetStoreWeb/" target="_blank" rel="noopener">https://zerox-dg.github.io/SnippetStoreWeb/</a><br>GitHub地址: <a href="https://github.com/ZeroX-DG/SnippetStore" target="_blank" rel="noopener">https://github.com/ZeroX-DG/SnippetStore</a></p>
<h1 id="VNote"><a href="#VNote" class="headerlink" title="VNote"></a>VNote</h1><p>官网地址: <a href="https://tamlok.github.io/vnote/en_us/#!index.md" target="_blank" rel="noopener">https://tamlok.github.io/vnote/en_us/#!index.md</a><br>GitHub地址: <a href="https://github.com/tamlok/vnote" target="_blank" rel="noopener">https://github.com/tamlok/vnote</a></p>
<p><a href="https://boostnote.io/" target="_blank" rel="noopener">https://boostnote.io/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>vue响应式原理</title>
    <url>/2020/04/29/vue/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="观察器"><a href="#观察器" class="headerlink" title="观察器"></a>观察器</h3><blockquote>
<p>主要是对值变化的观察，针对该值对象的元素能够监听到其设置值与获取值才行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">    constructor(data) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果传入的值不是对象或者不存在，就直接退出</span><br><span class="line">        if (!data || typeof data !&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绑定单一的值</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        &#x2F;&#x2F; 遍历所有可遍历属性</span><br><span class="line">        this.walk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk() &#123;</span><br><span class="line">        for (const key in this.data) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 对每一个元素进行可监测处理</span><br><span class="line">            this.defineReactive(this.data, key, this.data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj, key, val) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果传入的又是一个对象，那么需要对其子元素继续进行监测处理</span><br><span class="line">        new Observer(val);</span><br><span class="line">        &#x2F;&#x2F; 定义可监测代码的主要函数</span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">            	&#x2F;&#x2F; 针对值获取的拦截处理，如console.log(obj.a)</span><br><span class="line">                console.log(&#39;1&#39;);</span><br><span class="line">                return val;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVaule) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 针对赋值的拦截处理，如obj.a &#x3D; 100</span><br><span class="line">                if (val &#x3D;&#x3D;&#x3D; newVaule) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(&#39;2&#39;);</span><br><span class="line">                val &#x3D; newVaule;</span><br><span class="line">                &#x2F;&#x2F; 对新改变的值继续进行可监测处理</span><br><span class="line">                new Observer(newVaule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &quot; cjg&quot;,</span><br><span class="line">    obj: &#123;</span><br><span class="line">        name: &quot;zht&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ob &#x3D; new Observer(data);</span><br><span class="line">ob.defineReactive(data,&#39;aa&#39;,5)</span><br><span class="line">data.aa&#x3D;4</span><br><span class="line">data.aa</span><br><span class="line">&#x2F;&#x2F;---&gt;</span><br><span class="line">&#x2F;&#x2F;2 &#x2F;&#x2F; 先是赋值</span><br><span class="line">&#x2F;&#x2F;1 &#x2F;&#x2F; 然后值获取</span><br></pre></td></tr></table></figure>

<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 观察器</span><br><span class="line">***</span><br><span class="line">  defineReactive(obj, key, val) &#123;</span><br><span class="line">    const dep &#x3D; new Dep(); &#x2F;&#x2F; 每一个值定义一个依赖管理</span><br><span class="line">    new Observer(val);</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        console.log(&#39;1&#39;);</span><br><span class="line">        if (Dep.target) &#123; &#x2F;&#x2F; 如果管理器绑定了一个监听器，那么就将可监测值推入管理队列中</span><br><span class="line">          dep.addSub(Dep.target); &#x2F;&#x2F; 推入操作</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVaule) &#123;</span><br><span class="line">        if (val &#x3D;&#x3D;&#x3D; newVaule) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        val &#x3D; newVaule;</span><br><span class="line">        new Observer(newVaule);</span><br><span class="line">        dep.notify(); &#x2F;&#x2F; 依赖刷新</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 依赖管理器</span><br><span class="line">class Dep &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    if (this.subs.indexOf(sub) &lt; 0) &#123;</span><br><span class="line">      this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    this.subs.forEach((sub) &#x3D;&gt; &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 用户绑定Watcher</span><br><span class="line">Dep.target &#x3D; null;</span><br></pre></td></tr></table></figure>

<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  &#x2F;&#x2F; vm: 响应式对象</span><br><span class="line">  &#x2F;&#x2F; keys: 响应式对象的属性</span><br><span class="line">  &#x2F;&#x2F; updateCb: 数值更新时的回调</span><br><span class="line">  constructor(vm, keys, updateCb) &#123;</span><br><span class="line">    this.vm &#x3D; vm;</span><br><span class="line">    this.keys &#x3D; keys;</span><br><span class="line">    this.updateCb &#x3D; updateCb;</span><br><span class="line">    this.value &#x3D; null;</span><br><span class="line">    this.get();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 监听器绑定</span><br><span class="line">  get() &#123;</span><br><span class="line">  	&#x2F;&#x2F; 依赖管理器设置该监听器</span><br><span class="line">    Dep.target &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 对属性的拆分，例如obj.a.a</span><br><span class="line">    const keys &#x3D; this.keys.split(&#39;.&#39;);</span><br><span class="line">    &#x2F;&#x2F; 获取响应式对象</span><br><span class="line">    let value &#x3D; this.vm;</span><br><span class="line">    &#x2F;&#x2F; 对属性进行值的获取，直到最终值</span><br><span class="line">    keys.forEach(_key &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里由于value[_key]获取了值，会执行上面监听器中defineProperty的get属性函数,这样get函数中的依赖收集变会启动并收集该属性.</span><br><span class="line">      value &#x3D; value[_key];</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 旧值的临时存储</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">    &#x2F;&#x2F; 因为上边依赖已经收集完毕,所有可以去掉了,方便下一个响应式对象的设置</span><br><span class="line">    Dep.target &#x3D; null;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">  	&#x2F;&#x2F; 依赖更新,值在被更新的时候执行的函数</span><br><span class="line">    const oldValue &#x3D; this.value;</span><br><span class="line">    const newValue &#x3D; this.get(); &#x2F;&#x2F;获取最新值</span><br><span class="line">    if (oldValue !&#x3D; newValue) &#123;</span><br><span class="line">      this.updateCb(oldValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>commander使用方法</title>
    <url>/2020/04/27/npm/commander%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md#parse-%e5%92%8c-parseasync" target="_blank" rel="noopener">npm commander</a></p>
<h2 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h2><p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i commander --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>Hello World</strong></p>
<p><code>main.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">const &#123; Command &#125; &#x3D; require(&#39;commander&#39;);</span><br><span class="line"></span><br><span class="line">const program &#x3D; new Command();</span><br><span class="line">program</span><br><span class="line">  .version(&#39;0.1.0&#39;)</span><br><span class="line">  .command(&#39;rmdir &lt;dir&gt; [otherDirs...]&#39;)</span><br><span class="line">  .action(function (dir, otherDirs) &#123;</span><br><span class="line">    console.log(&#39;rmdir %s&#39;, dir);</span><br><span class="line">    if (otherDirs) &#123;</span><br><span class="line">      otherDirs.forEach(function (oDir) &#123;</span><br><span class="line">        console.log(&#39;rmdir %s&#39;, oDir);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>

<p><strong>可执行文件</strong></p>
<p>在<code>package.json</code>中添加以下字段，确保<code>dist/main.js</code>是一个可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	***</span><br><span class="line">	&quot;bin&quot;: &#123;</span><br><span class="line">       &quot;gamecli&quot;: &quot;dist&#x2F;main.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的根路径下执行：<code>npm link</code>,会自动添加可执行文件,等待完成之后，执行<code>gamecli -V</code>就能看到效果了。</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>docker启蒙</title>
    <url>/2020/04/26/docker/docker%E5%90%AF%E8%92%99/</url>
    <content><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>Docker</code>允许你在容器内运行应用程序，使用<code>docker run</code>命令在容器中运行一个应用程序。如下：将会输出一个<code>Hello world</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br><span class="line">$ Hello world</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>docker`: Docker的二进制执行文件</li>
<li><code>run</code>：与前面的docker组合来运行一个容器</li>
<li><code>ubuntu:15.10</code> 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker就会从镜像仓库DockerHub下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器中执行的命令</li>
</ul>
<p>以上的代码大概意思是：Docker以ubuntu15.10镜像创建一个新容器，然后再容器里执行<code>/bin/echo &quot;Hello world&quot;</code>,输出结果</p>
<h2 id="运行交互式容器"><a href="#运行交互式容器" class="headerlink" title="运行交互式容器"></a>运行交互式容器</h2><p>有时我们需要自己进入容器的命令行来执行一些操作，这种情况显然是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这样的话，就会进入容器<code>ubuntu:15.10</code>内的命令行。</p>
<ul>
<li><code>-t</code>:再新容器中指定一个伪终端或终端</li>
<li><code>-i</code>:允许你在容器内的标77bd8交互</li>
</ul>
<p>当出现类似于<code>root@0123ce188bd8:/#</code>,表示我们已经进入一个``ubuntu15.10<code>系统的容器了，我们可以运行下</code>ls`查看当前目录的文件。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>在可交互式容器中输入<code>exit</code>,或者Ctrl+D来退出容器。</p>
<h2 id="以进程方式启动容器"><a href="#以进程方式启动容器" class="headerlink" title="以进程方式启动容器"></a>以进程方式启动容器</h2><p>使用以下命令创建一个进程式容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello world;sleep 1;done&quot;</span><br><span class="line">一长串的字符</span><br></pre></td></tr></table></figure>

<p>上面一长串的字符叫做容器ID，对于容器来说，这是唯一的。我们可以通过容器ID来查看容器发生了什么。当然，我们需要确认是否有容器在运行：<code>docker ps</code></p>
<p><img src="/static/docker/docker%E5%90%AF%E8%92%99/images/image-20200426220150273.png" alt="image-20200426220150273"></p>
<p>如果，我们可以看到有一个容器。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONTAINER ID</td>
<td>容器ID</td>
</tr>
<tr>
<td>IMAGE</td>
<td>使用的镜像</td>
</tr>
<tr>
<td>COMMAND</td>
<td>启动容器时运行的命令</td>
</tr>
<tr>
<td>STATUS</td>
<td>容器状态(7种)<br />create(已创建)     restarting(重启中)     running(运行中)<br />removing(迁移种)     paused(暂停)     exited(停止)    dead(死亡)</td>
</tr>
<tr>
<td>PORT</td>
<td>容器的端口细腻些和使用的链接类型（tcp\udp）</td>
</tr>
<tr>
<td>NAME</td>
<td>启动分配的容器名称</td>
</tr>
</tbody></table>
<p>为了查看宿主主机内的输出，我们可以运行<code>docker logs ***</code>，后面表示ID或者容器名称</p>
<p><img src="/static/docker/docker%E5%90%AF%E8%92%99/images/image-20200426220812571.png" alt="image-20200426220812571"></p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps  # 查看容器的信息</span><br><span class="line">docker stop *** # 后面接ID或者容器名称</span><br><span class="line">docker ps # 看到容器已经不在了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli3跨域代理配置</title>
    <url>/2020/04/25/vue/vue/vue-cli3%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>配置只能作用于本地，开发模式下，axios请不要设置默认服务器网址，这个在<code>vue.config.js</code>中设置。<img src="/static/vue/vue/vue-cli3%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/images/image-20200425141012188.png" alt="image-20200425141012188"></p>
</blockquote>
<p><code>vue.config.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	***</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		port: port, &#x2F;&#x2F; 本地服务的端口</span><br><span class="line">		open: true, &#x2F;&#x2F; 启动之后是否自动打开浏览器</span><br><span class="line">		proxy: &#123;</span><br><span class="line">          &#39;&#x2F;member&#39;: &#123;	&#x2F;&#x2F;配置&#96;&#x2F;member&#96;开头的网址</span><br><span class="line">            target: &#39;http:&#x2F;&#x2F;0000000:9002&#39;, &#x2F;&#x2F;请替换成你自己的服务器地址</span><br><span class="line">            ws: false, &#x2F;&#x2F; 是否代理websockets</span><br><span class="line">            changeOrigin: true, &#x2F;&#x2F; 默认是false：请求头中host仍然是浏览器发送过来的host</span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">              &#x2F;&#x2F; &#39;^&#x2F;member&#39;: &#39;&#39; &#x2F;&#x2F; 重写路径，这个的意思是去掉了&#x2F;member</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue+iframe通信于判断是否被引用</title>
    <url>/2020/04/25/vue/vue/vue+ifram%E9%80%9A%E4%BF%A1%E4%BA%8E%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #framePage&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      window.onload &#x3D; function() &#123;</span><br><span class="line">        var frame &#x3D; document.getElementById(&#39;framePage&#39;);</span><br><span class="line">        &#x2F;&#x2F; 发送消息</span><br><span class="line">        frame.contentWindow.postMessage(&#123;hide:true&#125;,&#39;*&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;iframe id&#x3D;&quot;framePage&quot; src&#x3D;&quot;http:&#x2F;&#x2F;localhost:9528&#x2F;#&#x2F;dashboard&quot; frameborder&#x3D;&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h2><p>我用的vue，因此用vue做示例，我的写在了main.js里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function(event) &#123;</span><br><span class="line">  if (event.data.hide) &#123;</span><br><span class="line">    store.state.isHideAll &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false)</span><br><span class="line">&#x2F;&#x2F;判断是不是被iframe引用了</span><br><span class="line">if (window.self !&#x3D;&#x3D; window.top) &#123;</span><br><span class="line">  store.state.isHideAll &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就被store管理了，在vue里也能够实时更新</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>node后端解决跨域</title>
    <url>/2020/04/25/%E8%B7%A8%E5%9F%9F/node%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>注意这个Access-Control-Allow-Headers,当然也可以设置为*</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app&#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置允许跨域访问该服务.</span><br><span class="line">app.all(&#39;*&#39;, function (req, res, next) &#123;</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);</span><br><span class="line">&#x2F;&#x2F;   Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type,token&#39;);</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;);</span><br><span class="line">  res.header(&#39;Content-Type&#39;, &#39;application&#x2F;json;charset&#x3D;utf-8&#39;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里虽说省略也可以，但是改成404就不行，因为会自动返回200</span><br><span class="line">app.options(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123;</span><br><span class="line">    res.sendStatus(200);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123;</span><br><span class="line">    res.send(&#123;aa:123&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, ()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Server is running at http:&#x2F;&#x2F;localhost:8083&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端针对跨域的两个条件：</p>
<ul>
<li><p>options请求返回200 （复杂请求会有预检请求）</p>
</li>
<li><p>响应携带允许跨域的请求头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line">Access-Control-Allow-Methods</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>跨域</category>
      </categories>
  </entry>
  <entry>
    <title>git-rebase详解</title>
    <url>/2020/04/24/git/git-rebase%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase" target="_blank" rel="noopener">https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase</a></p>
</blockquote>
<h1 id="Rebase-代替合并"><a href="#Rebase-代替合并" class="headerlink" title="Rebase 代替合并"></a>Rebase 代替合并</h1><p>虽然<code>合并（merge）</code>操作可以用来简单和方便地整合改动，但是它却不是唯一的方法。<code>“Rebase”</code> 就是另一种替代手段。</p>
<blockquote>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>虽然 rebase 相对于我们已知的整合操作来说有着比较显著的优点，但是这也是在很大程度上取决于个人的喜好。一些团队喜欢使用 rebase，而另一些可能倾向于使用合并。</p>
<p>Rebase 相对于合并来说是比较复杂的。我建议你可以跳过这一章，除非你和你的团队确定会用到 rebase 操作。当你积累了 Git 的一些基本使用流程的实践经验后，你也可以在以后的时间再回来学习本章的内容。</p>
</blockquote>
<a id="more"></a>

<h2 id="深入了解合并操作"><a href="#深入了解合并操作" class="headerlink" title="深入了解合并操作"></a>深入了解合并操作</h2><p>在你进入<code>rebase</code> 这个主题前，我们有必要来再次探讨一下更多关于合并操作的细节。当 Git 执行一个合并时，它实际上会查找三个提交：</p>
<p>(1)共同的原始提交<br>如果你在项目中查看两个分支的历史，它们总是会出自于一次共同的提交，那么在当时的时间点上，这两个分支还是拥有相同的内容。之后它们就开始有了差别。</p>
<p>(2) + (3) 两个分支的最终点<br>合并操作的目的就是把两个分支的最新状态结合起来。因此他们各自的最新版本是有特殊含义的。</p>
<p>结合这三个提交后得到的结果就是我们整合的目标。</p>
<h2 id="快进或合并提交"><a href="#快进或合并提交" class="headerlink" title="快进或合并提交"></a>快进或合并提交</h2><p>一种最简单的情况是，在其中的一个分支上没有任何一个新的改动提交发生。那么在它之前的最后一次提交就仍然还是那个共同的原始提交。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-fast-forward.gif" alt="img"></p>
<p>在这种情况下，执行整合操作就非常简单了。 Git 仅仅需要添加所有那些在另外一个分支上的新提交就可以了。在 Git 中，这种最简单的整合操作我们称之为 <code>“快进（fast-forward）”</code>合并。之后两个分支就拥有了完全相同的历史。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-fast-forward.gif" alt="img"></p>
<p>但是在大多数情况下，两个分支都会有自己不同的发展轨迹。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-merge-commit.gif" alt="img"></p>
<p>为了完成整合，Git 会需要创建一个新的提交来含括它们之间的差异，这就是整合提交（merge commit）。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-merge-commit.gif" alt="img"></p>
<h2 id="手工提交与合并提交"><a href="#手工提交与合并提交" class="headerlink" title="手工提交与合并提交"></a>手工提交与合并提交</h2><p>通常情况下，提交都是由手工精心创建的。这样也就能更好地保证一次提交只涉及一个关联改动，并且能更好地注释这个提交。</p>
<p>一个合并提交就不同了，它不是由开发人员手动创建的，而是由 Git 自动生成的。它也不涉及一个关联改动，其目的只是连接两个分支，就像节点一样。如果之后想要了解某个合并操作，你只需要查看这两个分支的历史记录和它们相应的提交树（version tree）。</p>
<h2 id="Rebase-整合"><a href="#Rebase-整合" class="headerlink" title="Rebase 整合"></a>Rebase 整合</h2><p>有些人并不喜欢使用这种自动合并提交。相反，他们希望项目拥有一个单一的历史发展轨迹。比如一条直线。在历史纪录上没有迹象表明在某些时间它被分成过多个分支。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-rebase.gif" alt="img"></p>
<p>现在就让我们一步一步地了解一下 <code>rebase</code> 操作吧！仍然来使用前面的例子：我们想合并分支 B 到 分支 A 中，但是这次使用 <code>rebase</code> 操作。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-rebase.gif" alt="img"></p>
<p>使用下面这个非常的简单的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase branch-B</span><br></pre></td></tr></table></figure>

<p>首先，Git 会 <code>“撤销”</code> 所有在分支 A 上的那些在与分支 B 的共同提交之后发生的提交。当然，Git 不会真的放弃这些提交，其实你可以把这些撤销的提交想像成 “<em>被暂时地存储</em>” 到另外的一个地方去了。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-1.gif" alt="img"></p>
<p>接下来它会整合那些在分支 B（这个我们想要整合的分支）上的还未整合的提交到分支 A 中。在这个时间点，这两个分支看起来会是一模一样的。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-2.gif" alt="img"></p>
<p>最后，那些在分支 A 的新的提交（也就是第一步中自动撤销掉的那些提交）会被重新应用到这个分支上，但是在不同的位置上，在那些从分支 B 被整合过来的提交之后，它们就被 <em>re-based</em> 了。<br>整个项目开发轨迹看起来就像发生在一条直线上。相对于一个合并提交，rebase 包括了所有的组合变化，最原始的提交结构会被保留下来。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-3.gif" alt="img"></p>
<h2 id="Rebase-存在的陷阱"><a href="#Rebase-存在的陷阱" class="headerlink" title="Rebase 存在的陷阱"></a>Rebase 存在的陷阱</h2><p>当然，使用 <strong>rebase</strong> 操作不会是永远一帆风顺的。很有可能会搬起石头砸自己的脚，因此你不能忽视一个重要的事实：<strong>rebase 会改写历史记录</strong>。</p>
<p>你有可能已经注意到了，在被 rebase 操作之后的版本中，提交 “C3*” 存在一个新添加的星号。这是因为，尽管这个提交的内容和 “C3” 完全一样，但是它实际上是一个不同的提交。这样做的原因是，它现在有一个新的源提交 C4（在最初创建 C3 时的源提交是 C1）。</p>
<p>一个提交仅仅包括很少的属性，比如作者，日期，变动和谁是它的父提交。如果改变其中任何一个信息，就必须创建一个全新的提交。当然，新的提交也会拥有一个新的 <code>hash ID</code> 。</p>
<p>如果还仅仅只是操作那些尚未发布的提交，重写历史记录本身也没有什么很大的问题。但是如果你重写了已经发布到公共服务器上的提交历史，这样做就非常危险了。其他的开发人员可能这时已经在最原始的提交 C3 上开始工作，并使它成为了一些新提交中不可或缺的部分，而现在你却把 C3 的改动设置到了另一个时间点（就是那个新的 C3*）。除此之外，通过rebase 操作，这个原始的 C3 还被删除掉了，这将是非常可怕的……</p>
<blockquote>
<p> 因此你应该只使用 rebase 来清理你的本地工作，千万不要尝试着对那些已经被发布的提交进行这个操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>ts使用paths配置路径别名</title>
    <url>/2020/04/24/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    ***</span><br><span class="line">    &#x2F;&#x2F; 配置基础路径</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">    	&#x2F;&#x2F; &#39;@&#x2F;*&#39; 表示中的@表示路径别名，*代表匹配所有声明的所有路径</span><br><span class="line">    	&#x2F;&#x2F; &#39;.&#x2F;app&#x2F;*&#39; 表示在baseUrl的相对目录下的app的所有文件都在paths的范围内</span><br><span class="line">        &quot;@&#x2F;*&quot;: [&quot;.&#x2F;app&#x2F;*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    ***</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;app&#x2F;public&quot;,</span><br><span class="line">    &quot;app&#x2F;views&quot;,</span><br><span class="line">    &quot;node_modules*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>webstrom的一些配置：</p>
<p><img src="/static/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/images/image-20200424105018577.png" alt="image-20200424105018577"></p>
<p><img src="/static/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/images/image-20200424105035089.png" alt="image-20200424105035089"></p>
<blockquote>
<p>不一定要一样，只是我这样是可以用的。</p>
<p>那个Recompile on changes不推荐钩选，不然会把你的所有ts文件的同级目录下编译出一个js文件</p>
</blockquote>
]]></content>
      <categories>
        <category>ts</category>
      </categories>
  </entry>
  <entry>
    <title>frp内网穿透</title>
    <url>/2020/04/23/%E5%B7%A5%E5%85%B7/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">frp</a>国人开发的免费开源工具</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>公网服务器 IP 140.140.192.192</p>
</li>
<li><p>域名 <a href="http://www.good.com" target="_blank" rel="noopener">www.good.com</a> 解析至上面的服务器</p>
</li>
<li><p>本地运行的服务</p>
</li>
</ul>
<a id="more"></a>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>利用<code>frp</code>，可以实现任何人都可以通过配置的端口如 <code>www.good.com:7001</code> 访问我本机的<code>hbuilder</code>网页应用</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>服务器和内网本机分别<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">下载</a>对应系统平台的frp，<br>这里ubuntu服务器需要下载linux_arm_64， mac本机是frp_0.32.1_windows_amd64.zip</p>
<ul>
<li><p>先配服务端</p>
<p>linux_arm_64文件包在服务器上下载解压，编辑 <code>frps.ini</code>， 然后启动 <code>./frps -c ./frps.ini</code>，放后台启动命令 <code>nohup ./frps -c ./frps.ini &amp;</code>，配置修改如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line"><span class="meta"># 客户端定义的端口</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置客户端</p>
<p>frp_0.32.1_windows_amd64.zip文件包解压，编辑 <code>frpc.ini</code>,然后启动 <code>./frpc -c ./frpsc.ini</code>,可以自己放在后台执行，配置如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">server_addr = <span class="number">140.140</span><span class="number">.192</span><span class="number">.192</span>   <span class="meta">#公网服务器ip</span></span><br><span class="line">server_port = <span class="number">7001</span>                       <span class="meta">#与服务端bind_port一致</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#公网访问内部web服务器以http方式</span></span><br><span class="line">[<span class="meta">web</span>]</span><br><span class="line">type = http         <span class="meta">#访问协议</span></span><br><span class="line">local_port = <span class="number">4200</span>   <span class="meta">#内网web服务的端口号</span></span><br><span class="line">custom_domains = www.good.com   <span class="meta">#所绑定的公网服务器域名，一级、二级域名都可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="配置服务端面板"><a href="#配置服务端面板" class="headerlink" title="配置服务端面板"></a>配置服务端面板</h4><p>修改服务端的 <code>frps.ini</code>， 添加 dashboard 信息，重启启动后可以通过<code>140.140.192.192:7500</code>打开控制面板</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line"><span class="meta"># 客户端定义的端口</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">dashboard_port = <span class="number">7500</span></span><br><span class="line"><span class="meta"># dashboard 用户名密码，默认都为 admin</span></span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p> Invalid Host header</p>
</blockquote>
<p>如果本机的web项目用了webpack server(目前vue cli, react cli, angular 本地开发用的都是这个) , 这个是webpack server的安全策略，如果是angular项目，需要在启动配置中加上 <code>--disable-host-check</code> 类似 <code>ng serve --open --host $IP --port $PORT --disable-host-check</code>。</p>
<p>如果是<code>uniapp</code>项目，进行如下配置：</p>
<p><img src="/static/%E5%B7%A5%E5%85%B7/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/images/image-20200423140150925.png" alt="image-20200423140150925"></p>
<blockquote>
<p>参考文档</p>
<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81</a></p>
<p><a href="https://www.jianshu.com/p/d579c2156311" target="_blank" rel="noopener">https://www.jianshu.com/p/d579c2156311</a></p>
<p><a href="https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/" target="_blank" rel="noopener">https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/</a></p>
<p><a href="https://www.it72.com/12580-1.htm" target="_blank" rel="noopener">https://www.it72.com/12580-1.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>3D前置知识</title>
    <url>/2020/04/23/3D/3D%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.场景(Scene)：是物体、光源等元素的容器，可以配合 chrome 插件使用，抛出 window.scene即可实时调整 obj 的信息和材质信息。</span><br><span class="line">2.相机（Camera）：场景中的相机，代替人眼去观察，场景中只能添加一个，一般常用的是透视相机（PerspectiveCamera）</span><br><span class="line">3.物体对象（Mesh）：包括二维物体（点、线、面）、三维物体，模型等等   </span><br><span class="line">4.光源（Light）：场景中的光照，如果不添加光照场景将会是一片漆黑，包括全局光、平行光、点光源等 </span><br><span class="line">5.渲染器（Renderer）:场景的渲染方式，如webGL\canvas2D\Css3D。 </span><br><span class="line">6.控制器(Control): 可通过键盘、鼠标控制相机的移动</span><br></pre></td></tr></table></figure>

<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>Three.js中我们常用到的又两种类型的相机：正交相机，透视相机。一般情况下为了模拟人眼我们都是使用透视相机。</p>
<p>正交镜头的特点是：物品的渲染尺寸与距离镜头的远近无关。也就是说在场景中移动一个物体，其大小不会变化。正交镜头适合2D游戏。</p>
<p>透视镜头则是模拟人眼的视觉特点，距离远的物体显得更小。透视镜头通常更适合3D渲染。</p>
<p><strong>PerspectiveCamera透视相机</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fov</td>
<td>视野角度，从镜头可以看到的场景的部分。通常3D游戏的FOV取值在60-90度之间较好的默认值为60</td>
</tr>
<tr>
<td>aspect</td>
<td>渲染区域的纵横比。较好的默认值为window.innerWidth/window.innerHeight</td>
</tr>
<tr>
<td>near</td>
<td>最近离镜头的距离</td>
</tr>
<tr>
<td>far</td>
<td>远离镜头的距离</td>
</tr>
</tbody></table>
<p><strong>透视相机示意图</strong></p>
<p><img src="/static/3D/3D%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/201809271025363f22144e-553d-4de9-af31-4ab884924e84.png" alt="img"></p>
<p>创建摄像机以后还要对其进行移动、然后对准物体积聚的场景中心位置，分别是设置其 <code>position</code>和调用 <code>lookAt</code> 方法，参数均是一个 xyz向量<code>(new THREE.Vector3(x,y,z))</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）</span><br><span class="line">camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)）</span><br></pre></td></tr></table></figure>

<h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><p>在<code>Three.js</code>中光源是必须的，如果一个场景你不设置灯光那么世界将会是一片漆黑。<code>Three.js</code>内置了多种光源以满足特定场景的需要。大家可以根据自己的项目需要来选择何种灯光</p>
<h3 id="光源分类"><a href="#光源分类" class="headerlink" title="光源分类"></a>光源分类</h3><table>
<thead>
<tr>
<th>光源</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AmbientLight</td>
<td>环境光，其颜色均匀的应用到场景及其所有对象上,这种光源为场景添加全局的环境光。 这种光没有特定的方向，不会产生阴影。通常不会把AmbientLight作为唯一的光源， 而是和SpotLight、DirectionalLight等光源结合使用，从而达到柔化阴影、添加全局色调的效果。 指定颜色时要相对保守，例如#0c0c0c。设置太亮的颜色会导致整个画面过度饱和，什么都看不清：</td>
</tr>
<tr>
<td>PointLight</td>
<td>3D空间中的一个点光源，向所有方向发出光线</td>
</tr>
<tr>
<td>SpotLight</td>
<td>产生圆锥形光柱的聚光灯，台灯、天花板射灯通常都属于这类光源,这种光源的使用场景最多 ，特别是在你需要阴影效果的时候。</td>
</tr>
<tr>
<td>DirectionalLight</td>
<td>也就无限光，光线是平行的。典型的例子是日光,用于模拟遥远的，类似太阳那样的光源。 该光源与SpotLight的主要区别是，它不会随着距离而变暗，所有被照耀的地方获得相同的光照强度。</td>
</tr>
<tr>
<td>HemisphereLight</td>
<td>特殊光源，用于创建户外自然的光线效果， 此光源模拟物体表面反光效果、微弱发光的天空,模拟穹顶（半球）的微弱发光效果， 让户外场景更加逼真。使用DirectionalLight + AmbientLight可以在某种程度上来模拟户外光线， 但是不够真实，因为无法体现大气层的散射效果、地面或物体的反射效果</td>
</tr>
<tr>
<td>AreaLight</td>
<td>面光源，指定一个发光的区域</td>
</tr>
<tr>
<td>LensFlare</td>
<td>不是光源，用于给光源添加镜头光晕效果</td>
</tr>
</tbody></table>
<p>关于光源的详细 API 大家可以参考 threejs 官网，很详细，demo 也很完整 <a href="https://threejs.org/examples/?q=light#webgl_lights_physical" target="_blank" rel="noopener">传送门</a></p>
<h2 id="Mesh-网格"><a href="#Mesh-网格" class="headerlink" title="Mesh(网格)"></a>Mesh(网格)</h2><p>在计算机的世界中，一条弧线是由有限个点构成的有限条段链接得到的。当线段数量越多，长度就越短，当达到你无法察觉这是线段时，一条平滑的弧线就出现了。计算机三位模型也是类似的。只不过是线段变成了平面，普遍用三角形组成的网格来描述。我们把这种模型称之为Mesh模型。在ThreeJs的世界中，材质（Mterial）+几何体（Geomtry） 及时一个<code>mesh</code>。设置其name属性可以通过scene.getObjectByName(name)获取改物体对象。Geomtry就好像是故交，材质则类似于皮肤，对于材质和几何体的分类见下表格：</p>
<h3 id="材质分类"><a href="#材质分类" class="headerlink" title="材质分类"></a>材质分类</h3><table>
<thead>
<tr>
<th>材质</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MeshBasicMaterial</td>
<td>基本的材质，显示为简单的颜色或者显示为线框。不考虑光线的影响</td>
</tr>
<tr>
<td>MeshDepthMaterial</td>
<td>使用简单的颜色，但是颜色深度和距离相机的远近有关</td>
</tr>
<tr>
<td>MeshNormalMaterial</td>
<td>基于面Geometry的法线（normals）数组来给面着色</td>
</tr>
<tr>
<td>MeshFacematerial</td>
<td>容器，允许为Geometry的每一个面指定一个材质</td>
</tr>
<tr>
<td>MeshLambertMaterial</td>
<td>考虑光线的影响，哑光材质</td>
</tr>
<tr>
<td>MeshPhongMaterial</td>
<td>考虑光线的影响，光泽材质</td>
</tr>
<tr>
<td>ShaderMaterial</td>
<td>允许使用自己的着色器来控制顶点如何被放置、像素如何被着色</td>
</tr>
<tr>
<td>LineBasicMaterial</td>
<td>用于THREE.Line对象，创建彩色线条</td>
</tr>
<tr>
<td>LineDashMaterial</td>
<td>用于THREE.Line对象，创建虚线条</td>
</tr>
<tr>
<td>RawShaderMaterial</td>
<td>仅和THREE.BufferedGeometry联用，优化静态Geometry（顶点、面不变）的渲染</td>
</tr>
<tr>
<td>SpriteCanvasMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
<tr>
<td>SpriteMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
<tr>
<td>PointCloudMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>3D</category>
      </categories>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法题</title>
    <url>/2020/04/22/leetcode/leetcode%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：输入的不是数组，而是类似这种图形结构的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;val&quot;: 1,</span><br><span class="line">    &quot;left&quot;: &#123;&quot;val&quot;: 2, &quot;left&quot;: null, &quot;right&quot;: &#123;&quot;val&quot;: 5, &quot;left&quot;: null, &quot;right&quot;: null&#125;&#125;,</span><br><span class="line">    &quot;right&quot;: &#123;&quot;val&quot;: 3, &quot;left&quot;: null, &quot;right&quot;: &#123;&quot;val&quot;: 4, &quot;left&quot;: null, &quot;right&quot;: null&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p>DFS(深度优先搜索算法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个节点树结构</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var rightSideView &#x3D; function(root) &#123;</span><br><span class="line">	&#x2F;&#x2F; 传入的是空的话返回空数组</span><br><span class="line">    if(!root) return [];</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    let run &#x3D; (tree,depth)&#x3D;&gt;&#123;</span><br><span class="line">        if(!tree) return [];</span><br><span class="line">        if (depth &#x3D;&#x3D; result.length)&#123;</span><br><span class="line">            result.push(tree.val)</span><br><span class="line">        &#125;</span><br><span class="line">        depth +&#x3D; 1</span><br><span class="line">        run(tree.right,depth)</span><br><span class="line">        run(tree.left,depth)</span><br><span class="line">    &#125;</span><br><span class="line">    run(root,0)</span><br><span class="line">    return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="对应知识点"><a href="#对应知识点" class="headerlink" title="对应知识点"></a>对应知识点</h3>]]></content>
  </entry>
  <entry>
    <title>node创建文件</title>
    <url>/2020/04/22/node/node%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="NodeJS-10"><a href="#NodeJS-10" class="headerlink" title="NodeJS 10+"></a>NodeJS 10+</h3><blockquote>
<p>fs.mkdir已经增加递归选项</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.mkdir(&#39;&#x2F;tmp&#x2F;test&#x2F;www.inull.cn&#39;, &#123; recursive: true &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">    if (err) throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="NodeJS-9以前版本"><a href="#NodeJS-9以前版本" class="headerlink" title="NodeJS 9以前版本"></a>NodeJS 9以前版本</h3><p>同步方案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步递归创建路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;string&#125;</span> </span>dir   处理的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> </span>cb  回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> $$mkdir = <span class="function"><span class="keyword">function</span>(<span class="params">dir, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathinfo = path.parse(dir)</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(pathinfo.dir)) &#123;</span><br><span class="line">        $$mkdir(pathinfo.dir,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fs.mkdirSync(pathinfo.dir)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    cb &amp;&amp; cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$$mkdir(path.join(__dirname, <span class="string">'demo/test/123/'</span>))</span><br></pre></td></tr></table></figure>

<p>异步方案</p>
<p>暂缓</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>html5plus分享模板</title>
    <url>/2020/04/21/uniapp/html5plus%E5%88%86%E4%BA%AB%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>微信公众号的分享链接在vue，hash模式下不要带/#/，会有问题</p>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
  </entry>
  <entry>
    <title>git本地多账号配置</title>
    <url>/2020/04/20/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li><code>git环境</code></li>
</ul>
<a id="more"></a>

<h3 id="生成第一个账号的密钥"><a href="#生成第一个账号的密钥" class="headerlink" title="生成第一个账号的密钥"></a>生成第一个账号的密钥</h3><p>先确保你已经有多个git账号（如：一个github的账号、一个码云的账号、…）。</p>
<p>在Git Bash Here的控制台里输入：</p>
<p><code>git config --global user.name &quot;你的名称&quot;</code></p>
<p><code>git config --global user.email &quot;你的邮箱&quot;</code></p>
<p>这里的邮箱是你申请git账号时的邮箱，不报错就是正确的，继续往下走</p>
<p>输入 <code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>  回车，再连续3次回车见下图：</p>
<p>此时看下图中有一行提示：<code>Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub</code></p>
<p>到该路径（<code>C/Users/xxx/.ssh</code>）可以看见两个文件：id_rsa、id_rsa.pub 。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110415002.png" alt="image-20200420110415002"></p>
<p>把密钥添加进git账号中：</p>
<p>用编辑器打开<code>id_rsa.pub</code>，推荐使用Notepad++，不要使用记事本打开，因为记事本的默认编码不是utf-8，拷贝里面的全部内容，登录你其中一个git 账号，例如:我登录github平台，后添加公钥里把它添加进去，公钥名称可以随便写。提交保存，输入你的github登录密码并提示添加成功。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110453118.png" alt="image-20200420110453118"></p>
<p>测试刚才添加的github密钥是否成功：</p>
<p>在Git Bash Here中输入 ssh <a href="mailto:git@github.com">git@github.com</a>  回车</p>
<p>会出现一个提示，输入 yes 回车，可以看见一个successfully的提示信息，说明添加成功，可以使用了。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110505960.png" alt="image-20200420110505960"></p>
<h3 id="生成第二个账号的密钥"><a href="#生成第二个账号的密钥" class="headerlink" title="生成第二个账号的密钥"></a>生成第二个账号的密钥</h3><p>重复上面的步骤，那用户名和邮箱改成另一个账号的</p>
<blockquote>
<p>注：在输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>的第一个选择存储路径的时候请自行改成自己的自定义名字，例如输入：smalldemons，这个时候一般是在<code>C/Users/xxx/.ssh</code>目录下就会又增加两个文件：smalldemons、smalldemons.pub,如果没看到的话，一般是在命令行打开的当前目录下，把这两个文件复制过去就行了</p>
</blockquote>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110803461.png" alt="image-20200420110803461"></p>
<p>添加多账号配置文件config（<code>C/Users/xxx/.ssh</code>）：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110903542.png" alt="image-20200420110903542"></p>
<p>里面的代码 如下：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111043623.png" alt="image-20200420111043623"></p>
<blockquote>
<p>Host 配置的别名</p>
<p>HostName  填写改git账号的官网地址</p>
<p>IdentityFile：是对应的密钥文件</p>
<p>如此就可以在多个账号间切换使用了</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这样的话只能使用<code>git@github.com:xxxx/xxxx.git</code>的方式拉取或推送代码，另一种我试的是失效的，得再看一下。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111258450.png" alt="image-20200420111258450"></p>
<p>切换<code>npmrun</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line">git@npmrun.github.com:npmrun&#x2F;npmrun.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@npmrun.github.com,我加了npmrun,对应的是config里面的Host</span><br></pre></td></tr></table></figure>

<p>切换<code>1549469775</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line">git@1549469775.github.com:npmrun&#x2F;1549469775.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@1549469775.github.com,我加了1549469775,对应的是config里面的Host</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>eggJS路由</title>
    <url>/2020/04/19/eggjs/eggJS%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h1><p>Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 <code>app/router.js</code> 文件用于统一所有路由规则。</p>
<p>通过统一的配置，我们可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。</p>
<a id="more"></a>

<h2 id="如何定义-Router"><a href="#如何定义-Router" class="headerlink" title="如何定义 Router"></a>如何定义 Router</h2><ul>
<li><p><code>app/router.js</code> 里面定义 URL 路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>app/controller</code> 目录下面实现 Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">class UserController extends Controller &#123;</span><br><span class="line">  async info() &#123;</span><br><span class="line">    const &#123; ctx &#125; &#x3D; this;</span><br><span class="line">    ctx.body &#x3D; &#123;</span><br><span class="line">      name: &#96;hello $&#123;ctx.params.id&#125;&#96;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样就完成了一个最简单的 Router 定义，当用户执行 <code>GET /user/123</code>，<code>user.js</code> 这个里面的 info 方法就会执行。</p>
<h2 id="Router-详细定义说明"><a href="#Router-详细定义说明" class="headerlink" title="Router 详细定义说明"></a>Router 详细定义说明</h2><p>下面是路由的完整定义，参数可以根据场景的不同，自由选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.verb(&#39;path-match&#39;, app.controller.action);</span><br><span class="line">router.verb(&#39;router-name&#39;, &#39;path-match&#39;, app.controller.action);</span><br><span class="line">router.verb(&#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action);</span><br><span class="line">router.verb(&#39;router-name&#39;, &#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action);</span><br></pre></td></tr></table></figure>

<p>路由完整定义主要包括5个主要部分:</p>
<ul>
<li><p>verb - 用户触发动作，支持 get，post 等所有 HTTP 方法，后面会通过示例详细说明。</p>
<ul>
<li>router.head - HEAD</li>
<li>router.options - OPTIONS</li>
<li>router.get - GET</li>
<li>router.put - PUT</li>
<li>router.post - POST</li>
<li>router.patch - PATCH</li>
<li>router.delete - DELETE</li>
<li>router.del - 由于 delete 是一个保留字，所以提供了一个 delete 方法的别名。</li>
<li>router.redirect - 可以对 URL 进行重定向处理，比如我们最经常使用的可以把用户访问的根目录路由到某个主页。</li>
</ul>
<p>router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 <code>pathFor</code> 和 <code>urlFor</code> 来生成 URL。(可选)</p>
</li>
<li><p>router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 <code>pathFor</code> 和 <code>urlFor</code> 来生成 URL。(可选)</p>
</li>
<li><p>path-match - 路由 URL 路径。</p>
</li>
<li><p>middleware1 - 在 Router 里面可以配置多个 Middleware。(可选)</p>
</li>
<li><p>controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法：</p>
<ul>
<li><code>app.controller.user.fetch</code> - 直接指定一个具体的 controller</li>
<li><code>&#39;user.fetch&#39;</code> - 可以简写为字符串形式</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在 Router 定义中， 可以支持多个 Middleware 串联执行</li>
<li>Controller 必须定义在 <code>app/controller</code> 目录中。</li>
<li>一个文件里面也可以包含多个 Controller 定义，在定义路由的时候，可以通过 <code>${fileName}.${functionName}</code> 的方式指定对应的 Controller。</li>
<li>Controller 支持子目录，在定义路由的时候，可以通过 <code>${directoryName}.${fileName}.${functionName}</code> 的方式制定对应的 Controller。</li>
</ul>
<p>下面是一些路由定义的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;home&#39;, controller.home);</span><br><span class="line">  router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.page);</span><br><span class="line">  router.post(&#39;&#x2F;admin&#39;, isAdmin, controller.admin);</span><br><span class="line">  router.post(&#39;&#x2F;user&#39;, isLoginUser, hasAdminPermission, controller.user.create);</span><br><span class="line">  router.post(&#39;&#x2F;api&#x2F;v1&#x2F;comments&#39;, controller.v1.comments.create); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;comments.js</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="RESTful-风格的-URL-定义"><a href="#RESTful-风格的-URL-定义" class="headerlink" title="RESTful 风格的 URL 定义"></a>RESTful 风格的 URL 定义</h3><p>如果想通过 RESTful 的方式来定义路由， 我们提供了 <code>app.router.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller)</code> 快速在一个路径上生成 <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank" rel="noopener">CRUD</a> 路由结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.resources(&#39;posts&#39;, &#39;&#x2F;api&#x2F;posts&#39;, controller.posts);</span><br><span class="line">  router.resources(&#39;users&#39;, &#39;&#x2F;api&#x2F;v1&#x2F;users&#39;, controller.v1.users); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;users.js</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码就在 <code>/posts</code> 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 <code>app/controller/posts.js</code> 接下来， 你只需要在 <code>posts.js</code> 里面实现对应的函数就可以了。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Path</th>
<th>Route Name</th>
<th>Controller.Action</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.index</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/new</td>
<td>new_post</td>
<td>app.controllers.posts.new</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.show</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id/edit</td>
<td>edit_post</td>
<td>app.controllers.posts.edit</td>
</tr>
<tr>
<td>POST</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.create</td>
</tr>
<tr>
<td>PUT</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.update</td>
</tr>
<tr>
<td>DELETE</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.destroy</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;posts.js</span><br><span class="line">exports.index &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.new &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.create &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.show &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.edit &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.update &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.destroy &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们不需要其中的某几个方法，可以不用在 <code>posts.js</code> 里面实现，这样对应 URL 路径也不会注册到 Router。</p>
<h2 id="router-实战"><a href="#router-实战" class="headerlink" title="router 实战"></a>router 实战</h2><p>下面通过更多实际的例子，来说明 router 的用法。</p>
<h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><h4 id="Query-String-方式"><a href="#Query-String-方式" class="headerlink" title="Query String 方式"></a>Query String 方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;search?name&#x3D;egg</span><br></pre></td></tr></table></figure>

<h4 id="参数命名方式"><a href="#参数命名方式" class="headerlink" title="参数命名方式"></a>参数命名方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;user&#x2F;:id&#x2F;:name&#39;, app.controller.user.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">exports.info &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;user: $&#123;ctx.params.id&#125;, $&#123;ctx.params.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user&#x2F;123&#x2F;xiaoming</span><br></pre></td></tr></table></figure>

<h4 id="复杂参数的获取"><a href="#复杂参数的获取" class="headerlink" title="复杂参数的获取"></a>复杂参数的获取</h4><p>路由里面也支持定义正则，可以更加灵活的获取参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#x2F;^\&#x2F;package\&#x2F;([\w-.]+\&#x2F;[\w-.]+)$&#x2F;, app.controller.package.detail);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;package.js</span><br><span class="line">exports.detail &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果请求 URL 被正则匹配， 可以按照捕获分组的顺序，从 ctx.params 中获取。</span><br><span class="line">  &#x2F;&#x2F; 按照下面的用户请求，&#96;ctx.params[0]&#96; 的 内容就是 &#96;egg&#x2F;1.0.0&#96;</span><br><span class="line">  ctx.body &#x3D; &#96;package:$&#123;ctx.params[0]&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;package&#x2F;egg&#x2F;1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="表单内容的获取"><a href="#表单内容的获取" class="headerlink" title="表单内容的获取"></a>表单内容的获取</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.post(&#39;&#x2F;form&#39;, app.controller.form.post);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;form.js</span><br><span class="line">exports.post &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;body: $&#123;JSON.stringify(ctx.request.body)&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟发起 post 请求。</span><br><span class="line">&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;form --data &#39;&#123;&quot;name&quot;:&quot;controller&quot;&#125;&#39; --header &#39;Content-Type:application&#x2F;json&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：</p>
</blockquote>
<blockquote>
<p>这里直接发起 POST 请求会<strong>报错</strong>：’secret is missing’。错误信息来自 <a href="https://github.com/koajs/csrf/blob/2.5.0/index.js#L69" target="_blank" rel="noopener">koa-csrf/index.js#L69</a> 。</p>
</blockquote>
<blockquote>
<p><strong>原因</strong>：框架内部针对表单 POST 请求均会验证 CSRF 的值，因此我们在表单提交时，请带上 CSRF key 进行提交，可参考<a href="https://eggjs.org/zh-cn/core/security.html#安全威胁csrf的防范" target="_blank" rel="noopener">安全威胁csrf的防范</a></p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：上面的校验是因为框架中内置了安全插件 <a href="https://github.com/eggjs/egg-security" target="_blank" rel="noopener">egg-security</a>，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可。</p>
</blockquote>
<blockquote>
<p>「除非清楚的确认后果，否则不建议擅自关闭安全插件提供的功能。」</p>
</blockquote>
<blockquote>
<p>这里在写例子的话可临时在 <code>config/config.default.js</code> 中设置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.security &#x3D; &#123;</span><br><span class="line">  csrf: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.post(&#39;&#x2F;user&#39;, app.controller.user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">const createRule &#x3D; &#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: &#39;email&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: &#39;password&#39;,</span><br><span class="line">    compare: &#39;re-password&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.create &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果校验报错，会抛出异常</span><br><span class="line">  ctx.validate(createRule);</span><br><span class="line">  ctx.body &#x3D; ctx.request.body;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user --data &#39;username&#x3D;abc@abc.com&amp;password&#x3D;111111&amp;re-password&#x3D;111111&#39;</span><br></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;index&#39;, &#39;&#x2F;home&#x2F;index&#39;, app.controller.home.index);</span><br><span class="line">  app.router.redirect(&#39;&#x2F;&#39;, &#39;&#x2F;home&#x2F;index&#39;, 302);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;home.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;hello controller&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl -L http:&#x2F;&#x2F;localhost:7001</span><br></pre></td></tr></table></figure>

<h4 id="外部重定向"><a href="#外部重定向" class="headerlink" title="外部重定向"></a>外部重定向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  const type &#x3D; ctx.query.type;</span><br><span class="line">  const q &#x3D; ctx.query.q || &#39;nodejs&#39;;</span><br><span class="line"></span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; &#39;bing&#39;) &#123;</span><br><span class="line">    ctx.redirect(&#96;http:&#x2F;&#x2F;cn.bing.com&#x2F;search?q&#x3D;$&#123;q&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ctx.redirect(&#96;https:&#x2F;&#x2F;www.google.co.kr&#x2F;search?q&#x3D;$&#123;q&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?type&#x3D;bing&amp;q&#x3D;node.js</span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?q&#x3D;node.js</span><br></pre></td></tr></table></figure>

<h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><p>如果我们想把用户某一类请求的参数都大写，可以通过中间件来实现。 这里我们只是简单说明下如何使用中间件，更多请查看 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">中间件</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;middleware&#x2F;uppercase.js</span><br><span class="line">module.exports &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return async function uppercase(ctx, next) &#123;</span><br><span class="line">    ctx.query.name &#x3D; ctx.query.name &amp;&amp; ctx.query.name.toUpperCase();</span><br><span class="line">    await next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;s&#39;, &#39;&#x2F;search&#39;, app.middleware.uppercase(), app.controller.search)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?name&#x3D;egg</span><br></pre></td></tr></table></figure>

<h3 id="太多路由映射？"><a href="#太多路由映射？" class="headerlink" title="太多路由映射？"></a>太多路由映射？</h3><p>如上所述，我们并不建议把路由规则逻辑散落在多个地方，会给排查问题带来困扰。</p>
<p>若确实有需求，可以如下拆分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  require(&#39;.&#x2F;router&#x2F;news&#39;)(app);</span><br><span class="line">  require(&#39;.&#x2F;router&#x2F;admin&#39;)(app);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router&#x2F;news.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;news&#x2F;list&#39;, app.controller.news.list);</span><br><span class="line">  app.router.get(&#39;&#x2F;news&#x2F;detail&#39;, app.controller.news.detail);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router&#x2F;admin.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;admin&#x2F;user&#39;, app.controller.admin.user);</span><br><span class="line">  app.router.get(&#39;&#x2F;admin&#x2F;log&#39;, app.controller.admin.log);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可直接使用 <a href="https://github.com/eggjs/egg-router-plus" target="_blank" rel="noopener">egg-router-plus</a>。</p>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>hexo在github上的自动化部署</title>
    <url>/2020/04/17/hexo/hexo%E5%9C%A8github%E4%B8%8A%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>这几天被GithubActions和git-lfs坑的不轻啊，在使用Actions进行自动化部署的时候，我用的百度出来的那个Actions部署库，由于不支持lfs的功能，一直就失败。经过多次尝试，我终于找到了一个能够用的库了。谢天谢地，不然真得抑郁死。</p>
</blockquote>
<a id="more"></a>

<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>我是添加了对仓库的<code>git-lfs</code>的支持，使得能够存储大文件，而且<code>.git</code>文件也会小很多。</p>
<p><code>git lfs track &quot;*.zip&quot;</code>,执行这个命令之后提交的<code>zip</code>文件才会被记录。</p>
<h3 id="原有Actions"><a href="#原有Actions" class="headerlink" title="原有Actions"></a>原有<code>Actions</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: GitHub Actions Build and Deploy Hexo</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - source</span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@master</span><br><span class="line">      with:</span><br><span class="line">        ref: source</span><br><span class="line">        lfs: true</span><br><span class="line">    - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br><span class="line">      run: |</span><br><span class="line">        npm install</span><br><span class="line">        npx gulp clean</span><br><span class="line">        npx gulp</span><br><span class="line">        npx hexo clean</span><br><span class="line">        npx hexo generate</span><br><span class="line">    - name: Build and Deploy</span><br><span class="line">      uses: JamesIves&#x2F;github-pages-deploy-action@master</span><br><span class="line">      env:</span><br><span class="line">        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">        BASE_BRANCH: source</span><br><span class="line">        BRANCH: master</span><br><span class="line">        FOLDER: public</span><br></pre></td></tr></table></figure>

<p>上面的<code>JamesIves/github-pages-deploy-action@master</code>根本不支持<code>lfs</code></p>
<p>，结果我傻傻的搞了差不多一天。</p>
<h3 id="改变之后的Action"><a href="#改变之后的Action" class="headerlink" title="改变之后的Action"></a>改变之后的<code>Action</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: GitHub Actions Build and Deploy Hexo</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - source</span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@master</span><br><span class="line">      with:</span><br><span class="line">        submodules: true</span><br><span class="line">        lfs: true</span><br><span class="line">    - name: Install and BuildA 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br><span class="line">      run: |</span><br><span class="line">        npm install</span><br><span class="line">        npx gulp clean</span><br><span class="line">        npx gulp</span><br><span class="line">        npx hexo clean</span><br><span class="line">        npx hexo generate</span><br><span class="line">    - name: Deploy</span><br><span class="line">      uses: alex-page&#x2F;blazing-fast-gh-pages-deploy@v1.1.0</span><br><span class="line">      with:</span><br><span class="line">        repo-token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">        site-directory: .&#x2F;public</span><br><span class="line">        commit-message: fuck</span><br><span class="line">        deploy-branch: master</span><br></pre></td></tr></table></figure>

<p>Fuck,齐活！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>常用效果框架</title>
    <url>/2020/04/16/%E5%89%8D%E7%AB%AF/%E5%B8%B8%E7%94%A8%E6%95%88%E6%9E%9C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="通用框架"><a href="#通用框架" class="headerlink" title="通用框架"></a>通用框架</h3><ul>
<li><p>轮播框架</p>
<p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">Swiper</a>(老牌又强大)</p>
</li>
<li><p>图表</p>
<p><a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">EChart</a></p>
</li>
<li><p>效果</p>
<p><a href="http://www.clipboardjs.cn/" target="_blank" rel="noopener">复制文本</a></p>
</li>
<li><p>全屏滚动插件</p>
<p><a href="https://www.dowebok.com/demo/2014/77/" target="_blank" rel="noopener">FullPage.js</a></p>
</li>
</ul>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><ul>
<li><p>列表滑动</p>
<p><a href="http://www.mescroll.com/reward.html?v=20200315" target="_blank" rel="noopener">mescroll</a></p>
</li>
<li><p>高性能虚拟滑动</p>
<p><a href="https://www.npmjs.com/package/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>如何给git仓库瘦身,删除大文件</title>
    <url>/2020/04/16/git/%E5%A6%82%E4%BD%95%E7%BB%99git%E4%BB%93%E5%BA%93%E7%98%A6%E8%BA%AB,%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://blog.mallol.cn/2015/8d45392.html" target="_blank" rel="noopener">http://blog.mallol.cn/2015/8d45392.html</a></p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><code>git</code>用久后,或者<code>.gitignore</code>设置不好,没有忽略掉大文件(比如:<code>zip,sql,deb,tar.gz…</code>等二进制文件)。会把git库撑的很大,有几个G。这些大文件有些是没必要放进来的,需要删除掉.下面有解决办法:</p>
<a id="more"></a>

<p>进入项目根目录下面(确保是最新文件)。这个git库有6.4G.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ cd project</span><br></pre></td></tr></table></figure>

<p>从所有提交(commit)中删除所有的zip文件(*.zip.其他的请自行修正).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ git filter-branch --force --index-filter \</span><br><span class="line">&#39;git rm --cached --ignore-unmatch *.zip&#39; \</span><br><span class="line">--prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，会删除磁盘上的文件，请注意备份</p>
</blockquote>
<p><code>Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (266/266)</code></p>
<p><code>Ref ‘refs/heads/master’ was rewritten</code></p>
<p>清除快取和回收空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ rm -rf .git&#x2F;refs&#x2F;original&#x2F; </span><br><span class="line">$ git reflog expire --expire&#x3D;now --all</span><br><span class="line">$ git gc --prune&#x3D;now</span><br><span class="line">$ git gc --aggressive --prune&#x3D;now</span><br></pre></td></tr></table></figure>

<p>强制覆盖并上传到 remote repository。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ git push origin master --force</span><br></pre></td></tr></table></figure>

<p>打完收工！现在就可以看到瘦身的效果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ du .git -lsh </span><br><span class="line">126M .</span><br></pre></td></tr></table></figure>

<p><code>du -d 1 -h</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><code>fatal :bad revision &#39;rm&#39;</code>: 这个命令是使用<strong>双引号</strong>，而不是单引号。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>gitfls大文件</title>
    <url>/2020/04/16/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>作者：amosbake<br>链接：<a href="https://www.jianshu.com/p/493b81544f80" target="_blank" rel="noopener">https://www.jianshu.com/p/493b81544f80</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<a id="more"></a>

<p>Git LFS 是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-670f795346b86292.webp" alt="img"></p>
<h3 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h3><p>在游戏开发过程中,设计资源占用了很大一部分空间. 像png,psd等文件是二进制(blob)的,体积也很庞大.<br> 但git的diff/patch等是基于文件行的.对于二进制文件来说. git需要存储每次commit的改动.<br> 每次当二进制文件修改,发生变化的时候. 都会产生额外的提交量.导致clone和pull的数据量大增.在线仓库的体积也会迅速增长.</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-c9ddfd907277e8df.webp" alt="img"></p>
<p>LFS(Large File Storage) 就是为了解决这一问题而产生的工具.</p>
<p>它将你所标记的大文件保存至另外的仓库,而在主仓库仅保留其轻量级指针.</p>
<p>那么在你检出版本时,根据指针的变化情况下更新对应的大文件.而不是在本地保存所有版本的大文件</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-7e78b1cc5ceb6c1f.webp" alt="img"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5</p>
</blockquote>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><em>Linux</em></h4><ol>
<li><p><code>curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</code></p>
</li>
<li><p><code>sudo apt-get install git-lfs</code></p>
</li>
<li><p><code>git lfs install</code></p>
</li>
</ol>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><em>Mac</em></h4><ol>
<li>安装HomeBrew <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li><code>brew install git-lfs</code></li>
<li><code>git lfs install</code></li>
</ol>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h4><ol>
<li>下载安装 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fgithub%2Fgit-lfs%2Freleases" target="_blank" rel="noopener">windows installer</a></li>
<li>运行 windows installer</li>
<li>在命令行执行 <code>git lfs install</code></li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>执行 <code>git lfs install</code> 开启lfs功能</p>
</li>
<li><p>使用 <code>git lfs track</code> 命令进行大文件追踪 例如<code>git lfs track &quot;*.png&quot;</code> 追踪所有后缀为png的文件</p>
</li>
<li><p>使用 <code>git lfs track</code> 查看现有的文件追踪模式</p>
</li>
<li><p>提交代码需要将<code>gitattributes</code>文件提交至仓库. 它保存了文件的追踪记录</p>
</li>
<li><p>提交后运行<code>git lfs ls-files</code> 可以显示当前跟踪的文件列表</p>
</li>
<li><p>将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示:</p>
</li>
<li><p>clone 时 使用’git clone’ 或 <code>git lfs clone</code>均可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>eggjs错误搜集</title>
    <url>/2020/04/15/eggjs/eggjs%E9%94%99%E8%AF%AF%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by serv</p>
<p><a href="https://blog.csdn.net/weixin_36222137/article/details/81293332" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36222137/article/details/81293332</a></p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>v2rayn的使用方式</title>
    <url>/2020/04/15/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="/static/v2ray/v2rayn的使用方式/files/v2rayN.zip">v2rayN</a></p>
<p><a href="/static/v2ray/v2rayn的使用方式/files/v2ray-windows-64.zip">v2ray-windows-64</a></p>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压上面两个文件，得到</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145453557.png" alt="image-20200415145453557"></p>
<p>接下来把<code>v2ray-window-64</code>的所有文件全都复制到v2rayN的目录下就行了</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145543025.png" alt="image-20200415145543025"></p>
<p>移动后：</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145559168.png" alt="image-20200415145559168"></p>
<p>然后百度使用教程就行了</p>
]]></content>
      <categories>
        <category>v2ray</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020/04/15/mysql/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>下载安装文件:<a href="http://cloud.poorman.top/index.php?share/folder&user=1&sid=ivbmXp3E" target="_blank" rel="noopener">MySQL</a></p>
<p><a href="https://blog.csdn.net/CWH0908/article/details/82959511" target="_blank" rel="noopener">https://blog.csdn.net/CWH0908/article/details/82959511</a></p>
</blockquote>
<p>我的服务名称为<code>MySQL80</code></p>
<p>管理员启动：<code>net start MySQL80</code></p>
<p>停止：<code>net start MySQL80</code></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>eggjs目录结构</title>
    <url>/2020/04/15/eggjs/eggjs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>在<a href="https://eggjs.org/zh-cn/intro/quickstart.html" target="_blank" rel="noopener">快速入门</a>中，大家对框架应该有了初步的印象，接下来我们简单了解下目录约定规范。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure>

<p>如上，由框架约定的目录：</p>
<ul>
<li><p><code>app/router.js</code> 用于配置 URL 路由规则，具体参见 <a href="https://eggjs.org/zh-cn/basics/router.html" target="_blank" rel="noopener">Router</a>。</p>
</li>
<li><p><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果，具体参见 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a>。</p>
</li>
<li><p><code>app/service/**</code> 用于编写业务逻辑层，可选，建议使用，具体参见 <a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="noopener">Service</a>。</p>
</li>
<li><p><code>app/middleware/**</code> 用于编写中间件，可选，具体参见 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">Middleware</a>。</p>
</li>
<li><p><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</p>
</li>
<li><p><code>app/extend/**</code> 用于框架的扩展，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" target="_blank" rel="noopener">框架扩展</a>。</p>
</li>
<li><p><code>config/config.{env}.js</code> 用于编写配置文件，具体参见<a href="https://eggjs.org/zh-cn/basics/config.html" target="_blank" rel="noopener">配置</a>。</p>
</li>
<li><p><code>config/plugin.js</code> 用于配置需要加载的插件，具体参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" target="_blank" rel="noopener">插件</a>。</p>
</li>
<li><p><code>test/**</code> 用于单元测试，具体参见<a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</p>
</li>
<li><p><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/app-start.html" target="_blank" rel="noopener">启动自定义</a>。关于<code>agent.js</code>的作用参见<a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html#agent-机制" target="_blank" rel="noopener">Agent机制</a>。</p>
</li>
</ul>
<p>由内置插件约定的目录：</p>
<ul>
<li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</li>
<li><code>app/schedule/**</code> 用于定时任务，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/schedule.html" target="_blank" rel="noopener">定时任务</a>。</li>
</ul>
<p><strong>若需自定义自己的目录规范，参见 <a href="https://eggjs.org/zh-cn/advanced/loader.html" target="_blank" rel="noopener">Loader API</a></strong></p>
<ul>
<li><code>app/view/**</code> 用于放置模板文件，可选，由模板插件约定，具体参见<a href="https://eggjs.org/zh-cn/core/view.html" target="_blank" rel="noopener">模板渲染</a>。</li>
<li><code>app/model/**</code> 用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" target="_blank" rel="noopener">egg-sequelize</a>。</li>
</ul>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>egg.js官方手动搭建</title>
    <url>/2020/04/14/eggjs/egg.js%E5%AE%98%E6%96%B9%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>先按以下步骤一步步初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir egg-example</span><br><span class="line">$ cd egg-example</span><br><span class="line">$ npm init</span><br><span class="line">$ npm i egg --save</span><br><span class="line">$ npm i egg-bin --save-dev</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>添加 <code>npm scripts</code> 到 <code>package.json</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;egg-example&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;egg-bin dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-Controller"><a href="#编写-Controller" class="headerlink" title="编写 Controller"></a>编写 Controller</h3><p>如果你熟悉 Web 开发或 MVC，肯定猜到我们第一步需要编写的是 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a> 和 <a href="https://eggjs.org/zh-cn/basics/router.html" target="_blank" rel="noopener">Router</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;home.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class HomeController extends Controller &#123;</span><br><span class="line">  async index() &#123;</span><br><span class="line">    this.ctx.body &#x3D; &#39;Hello world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; HomeController;</span><br></pre></td></tr></table></figure>

<p>配置路由映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, controller.home.index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加一个<a href="https://eggjs.org/zh-cn/basics/config.html" target="_blank" rel="noopener">配置文件</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;;</span><br></pre></td></tr></table></figure>

<p>此时目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-example</span><br><span class="line">├── app</span><br><span class="line">│   ├── controller</span><br><span class="line">│   │   └── home.js</span><br><span class="line">│   └── router.js</span><br><span class="line">├── config</span><br><span class="line">│   └── config.default.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>完整的目录结构规范参见<a href="https://eggjs.org/zh-cn/basics/structure.html" target="_blank" rel="noopener">目录结构</a>。</p>
<p>好，现在可以启动应用来体验下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run dev</span><br><span class="line">$ open http:&#x2F;&#x2F;localhost:7001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>Controller 有 <code>class</code> 和 <code>exports</code> 两种编写方式，本文示范的是前者，你可能需要参考 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a> 文档。</li>
<li>Config 也有 <code>module.exports</code> 和 <code>exports</code> 的写法，具体参考 <a href="https://nodejs.org/api/modules.html#modules_exports_shortcut" target="_blank" rel="noopener">Node.js modules 文档</a>。</li>
</ul>
</blockquote>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>Egg 内置了 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">static</a> 插件，线上环境建议部署到 CDN，无需该插件。</p>
<p>static 插件默认映射 <code>/public/* -&gt; app/public/*</code> 目录</p>
<p>此处，我们把静态资源都放到 <code>app/public</code> 目录即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app&#x2F;public</span><br><span class="line">├── css</span><br><span class="line">│   └── news.css</span><br><span class="line">└── js</span><br><span class="line">    ├── lib.js</span><br><span class="line">    └── news.js</span><br></pre></td></tr></table></figure>

<h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><p>绝大多数情况，我们都需要读取数据后渲染模板，然后呈现给用户。故我们需要引入对应的模板引擎。</p>
<p>框架并不强制你使用某种模板引擎，只是约定了 <a href="https://eggjs.org/zh-cn/advanced/view-plugin.html" target="_blank" rel="noopener">View 插件开发规范</a>，开发者可以引入不同的插件来实现差异化定制。</p>
<p>更多用法参见 <a href="https://eggjs.org/zh-cn/core/view.html" target="_blank" rel="noopener">View</a>。</p>
<p>在本例中，我们使用 <a href="https://mozilla.github.io/nunjucks/" target="_blank" rel="noopener">Nunjucks</a> 来渲染，先安装对应的插件 <a href="https://github.com/eggjs/egg-view-nunjucks" target="_blank" rel="noopener">egg-view-nunjucks</a> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i egg-view-nunjucks --save</span><br></pre></td></tr></table></figure>

<p>开启插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;plugin.js</span><br><span class="line">exports.nunjucks &#x3D; &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &#39;egg-view-nunjucks&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;;</span><br><span class="line">&#x2F;&#x2F; 添加 view 配置</span><br><span class="line">exports.view &#x3D; &#123;</span><br><span class="line">  defaultViewEngine: &#39;nunjucks&#39;,</span><br><span class="line">  mapping: &#123;</span><br><span class="line">    &#39;.tpl&#39;: &#39;nunjucks&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：是 <code>config</code> 目录，不是 <code>app/config</code>!</strong></p>
<p>为列表页编写模板文件，一般放置在 <code>app/view</code> 目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hacker News&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;public&#x2F;css&#x2F;news.css&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;news-view view&quot;&gt;</span><br><span class="line">      &#123;% for item in list %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">          &lt;a href&#x3D;&quot;&#123;&#123; item.url &#125;&#125;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>添加 Controller 和 Router</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;news.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class NewsController extends Controller &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const dataList &#x3D; &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123; id: 1, title: &#39;this is news 1&#39;, url: &#39;&#x2F;news&#x2F;1&#39; &#125;,</span><br><span class="line">        &#123; id: 2, title: &#39;this is news 2&#39;, url: &#39;&#x2F;news&#x2F;2&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    await this.ctx.render(&#39;news&#x2F;list.tpl&#39;, dataList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsController;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, controller.home.index);</span><br><span class="line">  router.get(&#39;&#x2F;news&#39;, controller.news.list);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>启动浏览器，访问 <a href="http://localhost:7001/news" target="_blank" rel="noopener">http://localhost:7001/news</a> 即可看到渲染后的页面。</p>
<p><strong>提示：开发期默认开启了 <a href="https://github.com/eggjs/egg-development" target="_blank" rel="noopener">development</a> 插件，修改后端代码后，会自动重启 Worker 进程。</strong></p>
<h3 id="编写-service"><a href="#编写-service" class="headerlink" title="编写 service"></a>编写 service</h3><p>在实际应用中，Controller 一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层 <a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="noopener">Service</a>。</p>
<p>我们来添加一个 Service 抓取 <a href="https://github.com/HackerNews/API" target="_blank" rel="noopener">Hacker News</a> 的数据 ，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;service&#x2F;news.js</span><br><span class="line">const Service &#x3D; require(&#39;egg&#39;).Service;</span><br><span class="line"></span><br><span class="line">class NewsService extends Service &#123;</span><br><span class="line">  async list(page &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; read config</span><br><span class="line">    const &#123; serverUrl, pageSize &#125; &#x3D; this.config.news;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use build-in http client to GET hacker-news api</span><br><span class="line">    const &#123; data: idList &#125; &#x3D; await this.ctx.curl(&#96;$&#123;serverUrl&#125;&#x2F;topstories.json&#96;, &#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        orderBy: &#39;&quot;$key&quot;&#39;,</span><br><span class="line">        startAt: &#96;&quot;$&#123;pageSize * (page - 1)&#125;&quot;&#96;,</span><br><span class="line">        endAt: &#96;&quot;$&#123;pageSize * page - 1&#125;&quot;&#96;,</span><br><span class="line">      &#125;,</span><br><span class="line">      dataType: &#39;json&#39;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; parallel GET detail</span><br><span class="line">    const newsList &#x3D; await Promise.all(</span><br><span class="line">      Object.keys(idList).map(key &#x3D;&gt; &#123;</span><br><span class="line">        const url &#x3D; &#96;$&#123;serverUrl&#125;&#x2F;item&#x2F;$&#123;idList[key]&#125;.json&#96;;</span><br><span class="line">        return this.ctx.curl(url, &#123; dataType: &#39;json&#39; &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    return newsList.map(res &#x3D;&gt; res.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsService;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>框架提供了内置的 <a href="https://eggjs.org/zh-cn/core/httpclient.html" target="_blank" rel="noopener">HttpClient</a> 来方便开发者使用 HTTP 请求。</p>
</blockquote>
<p>然后稍微修改下之前的 Controller：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;news.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class NewsController extends Controller &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const ctx &#x3D; this.ctx;</span><br><span class="line">    const page &#x3D; ctx.query.page || 1;</span><br><span class="line">    const newsList &#x3D; await ctx.service.news.list(page);</span><br><span class="line">    await ctx.render(&#39;news&#x2F;list.tpl&#39;, &#123; list: newsList &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsController;</span><br></pre></td></tr></table></figure>

<p>还需增加 <code>app/service/news.js</code> 中读取到的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">&#x2F;&#x2F; 添加 news 的配置项</span><br><span class="line">exports.news &#x3D; &#123;</span><br><span class="line">  pageSize: 5,</span><br><span class="line">  serverUrl: &#39;https:&#x2F;&#x2F;hacker-news.firebaseio.com&#x2F;v0&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="编写扩展"><a href="#编写扩展" class="headerlink" title="编写扩展"></a>编写扩展</h3><p>遇到一个小问题，我们的资讯时间的数据是 UnixTime 格式的，我们希望显示为便于阅读的格式。</p>
<p>框架提供了一种快速扩展的方式，只需在 <code>app/extend</code> 目录下提供扩展脚本即可，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" target="_blank" rel="noopener">扩展</a>。</p>
<p>在这里，我们可以使用 View 插件支持的 Helper 来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i moment --save</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;extend&#x2F;helper.js</span><br><span class="line">const moment &#x3D; require(&#39;moment&#39;);</span><br><span class="line">exports.relativeTime &#x3D; time &#x3D;&gt; moment(new Date(time * 1000)).fromNow();</span><br></pre></td></tr></table></figure>

<p>在模板里面使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;</span><br><span class="line">&#123;&#123; helper.relativeTime(item.time) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-Middleware"><a href="#编写-Middleware" class="headerlink" title="编写 Middleware"></a>编写 Middleware</h3><p>假设有个需求：我们的新闻站点，禁止百度爬虫访问。</p>
<p>聪明的同学们一定很快能想到可以通过 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">Middleware</a> 判断 User-Agent，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;middleware&#x2F;robot.js</span><br><span class="line">&#x2F;&#x2F; options &#x3D;&#x3D;&#x3D; app.config.robot</span><br><span class="line">module.exports &#x3D; (options, app) &#x3D;&gt; &#123;</span><br><span class="line">  return async function robotMiddleware(ctx, next) &#123;</span><br><span class="line">    const source &#x3D; ctx.get(&#39;user-agent&#39;) || &#39;&#39;;</span><br><span class="line">    const match &#x3D; options.ua.some(ua &#x3D;&gt; ua.test(source));</span><br><span class="line">    if (match) &#123;</span><br><span class="line">      ctx.status &#x3D; 403;</span><br><span class="line">      ctx.message &#x3D; &#39;Go away, robot.&#39;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      await next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">&#x2F;&#x2F; add middleware robot</span><br><span class="line">exports.middleware &#x3D; [</span><br><span class="line">  &#39;robot&#39;</span><br><span class="line">];</span><br><span class="line">&#x2F;&#x2F; robot&#39;s configurations</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在可以使用 <code>curl http://localhost:7001/news -A &quot;Baiduspider&quot;</code> 看看效果。</p>
<p>更多参见<a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">中间件</a>文档。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>写业务的时候，不可避免的需要有配置文件，框架提供了强大的配置合并管理功能：</p>
<ul>
<li>支持按环境变量加载不同的配置文件，如 <code>config.local.js</code>， <code>config.prod.js</code> 等等。</li>
<li>应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载。</li>
<li>具体合并逻辑可参见<a href="https://eggjs.org/zh-cn/basics/config.html#配置加载顺序" target="_blank" rel="noopener">配置文件</a>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;curl&#x2F;i,</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; config&#x2F;config.local.js</span><br><span class="line">&#x2F;&#x2F; only read at development mode, will override default</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;service&#x2F;some.js</span><br><span class="line">const Service &#x3D; require(&#39;egg&#39;).Service;</span><br><span class="line"></span><br><span class="line">class SomeService extends Service &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const rule &#x3D; this.config.robot.ua;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; SomeService;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试非常重要，框架也提供了 <a href="https://github.com/eggjs/egg-bin" target="_blank" rel="noopener">egg-bin</a> 来帮开发者无痛的编写测试。</p>
<p>测试文件应该放在项目根目录下的 test 目录下，并以 <code>test.js</code> 为后缀名，即 <code>{app_root}/test/**/*.test.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test&#x2F;app&#x2F;middleware&#x2F;robot.test.js</span><br><span class="line">const &#123; app, mock, assert &#125; &#x3D; require(&#39;egg-mock&#x2F;bootstrap&#39;);</span><br><span class="line"></span><br><span class="line">describe(&#39;test&#x2F;app&#x2F;middleware&#x2F;robot.test.js&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  it(&#39;should block robot&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    return app.httpRequest()</span><br><span class="line">      .get(&#39;&#x2F;&#39;)</span><br><span class="line">      .set(&#39;User-Agent&#39;, &quot;Baiduspider&quot;)</span><br><span class="line">      .expect(403);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后配置依赖和 <code>npm scripts</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;egg-bin test&quot;,</span><br><span class="line">    &quot;cov&quot;: &quot;egg-bin cov&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i egg-mock --save-dev</span><br></pre></td></tr></table></figure>

<p>执行测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm test</span><br></pre></td></tr></table></figure>

<p>就这么简单，更多请参见 <a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>短短几章内容，只能讲 Egg 的冰山一角，我们建议开发者继续阅读其他章节：</p>
<ul>
<li>关于骨架类型，参见<a href="https://eggjs.org/zh-cn/tutorials/index.html" target="_blank" rel="noopener">骨架说明</a></li>
<li>提供了强大的扩展机制，参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" target="_blank" rel="noopener">插件</a>。</li>
<li>一个大规模的团队需要遵循一定的约束和约定，在 Egg 里我们建议封装适合自己团队的上层框架，参见 <a href="https://eggjs.org/zh-cn/advanced/framework.html" target="_blank" rel="noopener">框架开发</a>。</li>
<li>这是一个渐进式的框架，代码的共建，复用和下沉，竟然可以这么的无痛，建议阅读 <a href="https://eggjs.org/zh-cn/tutorials/progressive.html" target="_blank" rel="noopener">渐进式开发</a>。</li>
<li>写单元测试其实很简单的事，Egg 也提供了非常多的配套辅助，我们强烈建议大家测试驱动开发，具体参见 <a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</li>
</ul>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>cocos动态龙骨</title>
    <url>/2020/04/14/cocos/cocos%E5%8A%A8%E6%80%81%E9%BE%99%E9%AA%A8/</url>
    <content><![CDATA[<blockquote>
<p>在cocos中有关动态的，都离不开<code>resources</code>这个目录，同时，这个目录使用的是<code>loader</code>模块加载。在游戏的开发过程中，对于一些节点有着十分多的动画资源的时候，比如换装之类的，这样的话全部挂载在一个节点上的话会造成游戏加载时间过长，玩家的耐心会消磨完。因此就有了动态的需求，主要的目的就是使得用户能够尽快的进去。</p>
</blockquote>
<a id="more"></a>

<h3 id="资源位置"><a href="#资源位置" class="headerlink" title="资源位置"></a>资源位置</h3><p>在<code>cocos</code>中，动态资源都是放在<code>resources</code>中的，</p>
<p>示例目录如下：</p>
<p><img src="/static/cocos/cocos%E5%8A%A8%E6%80%81%E9%BE%99%E9%AA%A8/images/image-20200414112831540.png" alt="image-20200414112831540"></p>
<p>然后我们采用<code>loadResDir</code>的方式加载<code>eatting</code>下的三个龙骨资源，因为这三个都是必须的，必须同时加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadDragonBones(</span><br><span class="line">    path: string,</span><br><span class="line">    cb?: (bone: IDragonAssets) &#x3D;&gt; void</span><br><span class="line">): Promise&lt;IDragonAssets&gt; &#123;</span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    let allAssets: IDragonAssets &#x3D; &#123;</span><br><span class="line">        dragonAsset: null,</span><br><span class="line">        dragonAtlasAsset: null</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;动态加载龙骨</span><br><span class="line"></span><br><span class="line">        if (this.cacheAssets[path]) &#123;</span><br><span class="line">            allAssets &#x3D; this.cacheAssets[path]</span><br><span class="line">            cb &amp;&amp; cb(allAssets);</span><br><span class="line">            resolve(allAssets);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let ac &#x3D; cc.loader.loadResDir(path, function (err, assets) &#123;</span><br><span class="line">            if (err || assets.length &lt;&#x3D; 0) &#123;</span><br><span class="line">                err &amp;&amp; console.error(err)</span><br><span class="line">                assets.length &lt;&#x3D; 0 &amp;&amp; console.error(&quot;该目录下没有资源:&quot; + path)</span><br><span class="line">                &#x2F;&#x2F; reject();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            assets.forEach(asset &#x3D;&gt; &#123;</span><br><span class="line">                if (asset instanceof dragonBones.DragonBonesAsset) &#123;</span><br><span class="line">                    allAssets.dragonAsset &#x3D; asset;</span><br><span class="line">                &#125;</span><br><span class="line">                if (asset instanceof dragonBones.DragonBonesAtlasAsset) &#123;</span><br><span class="line">                    allAssets.dragonAtlasAsset &#x3D; asset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            cb &amp;&amp; cb(allAssets);</span><br><span class="line">            resolve(allAssets);</span><br><span class="line">            that.cacheAssets[path] &#x3D; allAssets</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导出<code>DragonBonesAsset</code>和<code>DragonBonesAtlasAsset</code>后，动态赋值到节点的龙骨组件上就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadingNodeDragon(</span><br><span class="line">    node: cc.Node,</span><br><span class="line">    bones: IDragonAssets,</span><br><span class="line">    armatureName?: string</span><br><span class="line">) &#123;</span><br><span class="line">    let animationDisplay &#x3D; node.getComponent(dragonBones.ArmatureDisplay);</span><br><span class="line">    if (!animationDisplay) &#123;</span><br><span class="line">        animationDisplay &#x3D; node.addComponent(dragonBones.ArmatureDisplay);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bones.dragonAsset instanceof dragonBones.DragonBonesAsset) &#123;</span><br><span class="line">        animationDisplay.dragonAsset &#x3D; bones.dragonAsset;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bones.dragonAtlasAsset instanceof dragonBones.DragonBonesAtlasAsset) &#123;</span><br><span class="line">        animationDisplay.dragonAtlasAsset &#x3D; bones.dragonAtlasAsset;</span><br><span class="line">    &#125;</span><br><span class="line">    if (armatureName) &#123;</span><br><span class="line">        animationDisplay.armatureName &#x3D; armatureName;</span><br><span class="line">    &#125;</span><br><span class="line">    return animationDisplay</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来只要正常播放就行了。</p>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos适配心得</title>
    <url>/2020/04/14/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<blockquote>
<p>在cocos的适配方案中，默认提供的就是<code>fit height</code>和<code>fit width</code>.</p>
<ul>
<li><code>fit height</code>表示根据高度来适配，高度一定是与设备高度一直，宽度可以随意变化，这个时候，在宽度很宽的情况下可能会有两边截断的情况。</li>
<li><code>fit width</code>同理</li>
<li>当两个一起钩选的时候，会保证界面一定完整的显示界面，但是不可避免的，会产生黑边。</li>
</ul>
<p>在做cocos的适配的时候，我们不能直接钩选两个，而是只控制一边，另一部分可结合<code>Widget</code>组件来实现</p>
</blockquote>
<a id="more"></a>

<h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><p><img src="/static/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/images/image-20200428134427268.png" alt="image-20200428134427268"></p>
<p>场景的适配策略只需要钩选适配高度就行了。再结合<code>Widget</code>就能够实现不留黑边的全屏</p>
<p><img src="/static/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/images/image-20200428134542763.png" alt="image-20200428134542763"></p>
<p>但这还是不够的，因为你的子元素也得加上这个<code>Widget</code>才行，保证不是绝对布局，而是相对于上下左右四个边界的距离，灵活调整<code>top,right,bottom,left</code>的值，就能实现全屏与布局的流动化。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>你要实现某部分的流动布局，必须将其所有的父元素也先<code>widget</code>化.或者直接绑定根元素</p>
<p>屏幕太小的话元素会重叠。</p>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>cocos的几种动画方式</title>
    <url>/2020/04/14/cocos/%E5%8A%A8%E7%94%BB/cocos%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8A%A8%E7%94%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>github-actions详解</title>
    <url>/2020/04/14/github/github-actions%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.v2ex.com/t/609744" target="_blank" rel="noopener">https://www.v2ex.com/t/609744</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
  </entry>
  <entry>
    <title>webpack的几种导入导出方式</title>
    <url>/2020/04/13/webpack/webpack%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/04/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式</p>
<a id="more"></a>

<h3 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>{<em>n</em>}</td>
<td><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{<em>n</em>,}</td>
<td><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{<em>n</em>,<em>m</em>}</td>
<td><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（<em>,+,?，{*n</em>}，{<em>n</em>,}，{<em>n</em>,<em>m</em>}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除“*n<em>”之外的任何单个字符。要匹配包括“\</em>n*”在内的任何字符，请使用像“(.|\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td>(?&lt;=pattern)</td>
<td>反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\x<em>n</em></td>
<td>匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td>*num*</td>
<td>匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>*n*</td>
<td>标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td>*nm*</td>
<td>标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果\</em>nm<em>之前至少有</em>n<em>个获取，则</em>n<em>为一个后跟文字</em>m<em>的向后引用。如果前面的条件都不满足，若</em>n<em>和</em>m<em>均为八进制数字（0-7），则\</em>nm<em>将匹配八进制转义值</em>nm*。</td>
</tr>
<tr>
<td>*nml*</td>
<td>如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
<tr>
<td>\u<em>n</em></td>
<td>匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody></table>
<h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><table>
<thead>
<tr>
<th>用户名</th>
<th>/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody><tr>
<td>密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td>十六进制值</td>
<td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td>
</tr>
<tr>
<td>电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$//^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td>URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]<em>)</em>/?$/</td>
</tr>
<tr>
<td>IP 地址</td>
<td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td>HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td>
</tr>
<tr>
<td>删除代码\注释</td>
<td>(?&lt;!http:|\S)//.*$</td>
</tr>
<tr>
<td>Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator常用api</title>
    <url>/2020/04/07/cocos/cocos-creator%E5%B8%B8%E7%94%A8api/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/sotmwhat/article/details/93884076" target="_blank" rel="noopener">https://blog.csdn.net/sotmwhat/article/details/93884076</a></p>
</blockquote>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cc.director.loadScene(<span class="string">'场景名称'</span>);<span class="comment">//场景跳转</span></span><br><span class="line">cc.director.preloadScene(<span class="string">'场景名称'</span>);<span class="comment">//预加载场景</span></span><br><span class="line">cc.director.getScene();<span class="comment">//获取当前场景</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = cc.find(<span class="string">"Canvas/bg"</span>);<span class="comment">//通过访问路径来获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByName(<span class="string">'name'</span>);<span class="comment">//通过名字获取子节点</span></span><br><span class="line">node.getComponent(cc.Label).string = <span class="string">'abc'</span>;<span class="comment">//获取节点上的组件值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"Canvas/bg"</span>).getComponent(cc.Sprite);<span class="comment">//通过访问路径来获取节点，及获取该节点的指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node .getChildByName(<span class="string">'节点名称'</span>).getComponent(cc.Label)<span class="comment">//通过节点名获取子节点，获取该节点指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node;<span class="comment">//获取当前脚本所在的节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.parent;<span class="comment">//获取父节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签获取子节点</span></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"bg/score"</span>,<span class="keyword">this</span>.node);<span class="comment">//通过指定节点下的路径获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.children;<span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.childrenCount;<span class="comment">//获取子节点数量</span></span><br><span class="line"><span class="keyword">var</span> a = cc.director.getScene();<span class="comment">//获取场景主节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.instantiate(node);<span class="comment">//克隆节点</span></span><br><span class="line"><span class="keyword">this</span>.node.parent = cc.find(<span class="string">'Canvas'</span>);<span class="comment">//绑定父节点</span></span><br><span class="line"><span class="keyword">this</span>.node.addChild(nodeName,zIndex,tag);<span class="comment">//添加子节点,可设置层级和标签</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(nodeName);<span class="comment">//通过名字移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag (nodeTag);<span class="comment">//通过标签移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroy();<span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.node.isValid;<span class="comment">//判定节点是否可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(newNode);<span class="comment">//移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeAllChildren();<span class="comment">//移除所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroyAllChildren();<span class="comment">//销毁所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.cleanup();<span class="comment">//停止所有正在播放的动作和计时器</span></span><br><span class="line"><span class="keyword">var</span> sprites = <span class="keyword">this</span>.node.getComponentsInChildren(cc.Label);<span class="comment">//递归查找自身及所有子节点中指定类型的组件</span></span><br></pre></td></tr></table></figure>

<h2 id="获取节点位置，设置节点"><a href="#获取节点位置，设置节点" class="headerlink" title="获取节点位置，设置节点"></a>获取节点位置，设置节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = node.getPositionX();或 getPositionY() <span class="comment">//获取节点的X轴或Y轴坐标</span></span><br><span class="line"><span class="keyword">var</span> a = node.getScaleX(); 或getScaleY() <span class="comment">//获取节点的X轴或Y轴缩放比例</span></span><br><span class="line">node.x = <span class="number">100</span>;<span class="comment">//设置节点x轴坐标</span></span><br><span class="line">node.y = <span class="number">100</span>;<span class="comment">//设置节点y轴坐标</span></span><br><span class="line">node.setPosition(x,y); <span class="comment">//设置节点坐标</span></span><br><span class="line">node.rotation = <span class="number">90</span>; <span class="comment">//设置节点旋转角度</span></span><br><span class="line">node.scaleX = <span class="number">2</span>; <span class="comment">//设置节点x轴缩放倍数</span></span><br><span class="line">node.scaleY = <span class="number">2</span>; <span class="comment">//设置节点y轴缩放倍数</span></span><br><span class="line">node.setScale(<span class="number">2</span>); <span class="comment">//设置节点整体缩放倍数</span></span><br><span class="line">node.width = <span class="number">100</span>; <span class="comment">//设置节点宽度大小</span></span><br><span class="line">node.height = <span class="number">100</span>;  <span class="comment">//设置节点高度大小</span></span><br><span class="line">node.setContentSize(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置节点宽高尺寸大小</span></span><br><span class="line">node.anchorX = <span class="number">1</span>; <span class="comment">//设置节点x轴锚点坐标</span></span><br><span class="line">node.anchorY = <span class="number">0</span>; <span class="comment">//设置节点y轴锚点坐标</span></span><br><span class="line">node.setAnchorPoint(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//设置节点锚点坐标</span></span><br><span class="line">node.opacity = <span class="number">128</span>; <span class="comment">//设置节点透明度大小（0-255）</span></span><br><span class="line">node.setOpacity(<span class="number">20</span>); <span class="comment">//设置节点透明度（0~255）</span></span><br><span class="line">node.color = <span class="keyword">new</span> cc.color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>); <span class="comment">//设置节点颜色（R,G,B,透明度）</span></span><br><span class="line"><span class="keyword">if</span> (cc.isValid(<span class="keyword">this</span>.label.node) ) <span class="comment">//判定节点是否存在</span></span><br><span class="line">node.destroy(); <span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = [];</span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildren(); <span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildrenCount(); <span class="comment">//获取子节点数量</span></span><br><span class="line">node.active = <span class="literal">false</span>; <span class="comment">//关闭节点(隐藏节点)</span></span><br><span class="line">cc.game.addPersistRootNode(myNode); <span class="comment">//常驻节点（全局变量）</span></span><br><span class="line">cc.game.removePersistRootNode(myNode); <span class="comment">//取消常驻节点</span></span><br></pre></td></tr></table></figure>

<h2 id="动作操作"><a href="#动作操作" class="headerlink" title="动作操作"></a>动作操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.show()&#x2F;&#x2F;立即显示</span><br><span class="line">cc.hide ()&#x2F;&#x2F;立即隐藏</span><br><span class="line">cc.toggleVisibility()&#x2F;&#x2F;显隐切换</span><br><span class="line">cc.fadeIn(1)&#x2F;&#x2F;渐显效果</span><br><span class="line">cc.fadeOut(1)&#x2F;&#x2F;渐隐效果</span><br><span class="line">cc.delayTime(1)&#x2F;&#x2F;等待1秒</span><br><span class="line">node.runAction(cc.moveTo(1,0,0)); &#x2F;&#x2F;移动到当前节点（时间（s），X轴坐标，Y 轴坐标）</span><br><span class="line">node.runAction(cc.scaleTo(1,0.7,0.8));&#x2F;&#x2F;缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）</span><br><span class="line">node.runAction(cc.rotateTo(1,160,160));&#x2F;&#x2F;旋转到指定角度（时间（s），X轴角度，Y 轴角度）</span><br><span class="line">node.runAction(cc.skewTo(1,5,-5));&#x2F;&#x2F;变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.fadeTo(2,0));&#x2F;&#x2F;变化当前节点的透明度（时间（s），透明度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.tintTo(2,255,255,0));&#x2F;&#x2F;变化当前节点颜色（时间，R,G,B）</span><br><span class="line">node.stopAllActions();&#x2F;&#x2F;停止所有动作</span><br><span class="line">&#x2F;&#x2F;自定义动作</span><br><span class="line">var action &#x3D; cc.moveTo(2, 100, 100);&#x2F;&#x2F; 创建一个移动动作</span><br><span class="line">node.runAction(action);&#x2F;&#x2F; 执行动作</span><br><span class="line">node.stopAction(action);&#x2F;&#x2F; 停止一个动作</span><br><span class="line"></span><br><span class="line">cc.sequence(action1,action2); &#x2F;&#x2F;按顺序连续执行，先action1，后action2</span><br><span class="line"></span><br><span class="line">cc.spawn(action1，action2); &#x2F;&#x2F;同时执行，action1和action2一起执行</span><br><span class="line"></span><br><span class="line">cc.repeatForever(cc.sequence(action1,action2)); &#x2F;&#x2F;一直重复括号里的动作</span><br></pre></td></tr></table></figure>

<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只用1次的计时器,2秒后执行</span><br><span class="line">        this.scheduleOnce(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,2); &#x2F;&#x2F;(function()&#123;&#125;,时间（s）)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每隔5秒执行1次</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次）</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句</span><br><span class="line"></span><br><span class="line">        &#125;,0.1,10,1); &#x2F;&#x2F;(function()&#123;&#125;,间隔时间，次数，多久后开始)</span><br><span class="line"></span><br><span class="line">this.unscheduleAllCallbacks(this);&#x2F;&#x2F;停止某组件的所有计时器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）</span><br><span class="line">var cb&#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;;</span><br><span class="line">this.schedule(cb,1);&#x2F;&#x2F;启动定时器</span><br><span class="line">this.unschedule(cb);&#x2F;&#x2F;取消定时器</span><br></pre></td></tr></table></figure>

<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(开始：&#39;touchstart&#39;，移动：&#39;touchmove&#39;，结束：&#39;touchend&#39;，取消：&#39;touchcancel&#39;)</span><br><span class="line">node.on(&#39;touchstart&#39;,function(event)&#123;</span><br><span class="line">    this.doSomething();</span><br><span class="line">&#125;,this);  </span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line">var a &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的坐标X</span><br><span class="line">var b &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的坐标Y</span><br><span class="line"></span><br><span class="line">cc.eventManager.addListener(&#123;</span><br><span class="line">            event: cc.EventListener.KEYBOARD&#x2F;TOUCH_ONE_BY_ONE,myfunction&#125;,self.node);</span><br></pre></td></tr></table></figure>

<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获得设备分辨率</span><br><span class="line">var b &#x3D; cc.director.getWinSizeInPixels()</span><br><span class="line">var bx &#x3D; b.width</span><br><span class="line">var by &#x3D; b.height</span><br><span class="line"></span><br><span class="line">cc.view.getCanvasSize().width;&#x2F;&#x2F;获得设备分辨率的宽度</span><br><span class="line">cc.view.getCanvasSize().height;&#x2F;&#x2F;获得设备分辨率的高度</span><br><span class="line">cc.director.setDisplayStats(true);&#x2F;&#x2F;显示帧数信息</span><br></pre></td></tr></table></figure>

<h2 id="音频控制"><a href="#音频控制" class="headerlink" title="音频控制"></a>音频控制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.audioEngine.playMusic(this.BGAudio,true);&#x2F;&#x2F;播放音乐（true代表循环）</span><br><span class="line">cc.audioEngine.stopMusic()&#x2F;&#x2F;停止播放背景音乐</span><br><span class="line">cc.audioEngine.playEffect(this.ClickAudio,false);&#x2F;&#x2F;播放音效（false代表只播放一次）</span><br><span class="line">cc.audioEngine.stopEffect(音效变量名);&#x2F;&#x2F;停止指定音效（需要先把音效赋值给变量）</span><br><span class="line">cc.audioEngine.AllEffects();&#x2F;&#x2F;停止所有音效</span><br><span class="line">cc.audioEngine.setMusicVolume(参数);  &#x2F;&#x2F;设置背景音乐的音量（该参数范围是0到1）</span><br><span class="line">cc.audioEngine.setEffectsVolume(参数);  &#x2F;&#x2F;设置音效的音量（该参数范围是0到1）</span><br></pre></td></tr></table></figure>

<h2 id="存档操作"><a href="#存档操作" class="headerlink" title="存档操作"></a>存档操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.localStorage.setItem(&#39;存储标识名&#39;,变量名);&#x2F;&#x2F;存储存档数据</span><br><span class="line">var a &#x3D; cc.sys.localStorage.getItem(&#39;存储标识名&#39;);&#x2F;&#x2F;读取存档数据</span><br><span class="line">cc.sys.localStorage.removeItem(&#39;存储标识名&#39;);&#x2F;&#x2F;擦除存档数据</span><br><span class="line">userData &#x3D; &#123;</span><br><span class="line">    name: &#39;Tracer&#39;,</span><br><span class="line">    level: 1,</span><br><span class="line">    gold: 100</span><br><span class="line">&#125;;</span><br><span class="line">cc.sys.localStorage.setItem(&#39;userData&#39;, JSON.stringify(userData));&#x2F;&#x2F;存取复杂对象数据</span><br><span class="line">var userData &#x3D; JSON.parse(cc.sys.localStorage.getItem(&#39;userData&#39;));&#x2F;&#x2F;读取复杂对象数据</span><br></pre></td></tr></table></figure>

<h2 id="判断平台"><a href="#判断平台" class="headerlink" title="判断平台"></a>判断平台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.isNative  &#x2F;&#x2F;是否是本地</span><br><span class="line">cc.sys.isBrowser  &#x2F;&#x2F;是否是网页</span><br><span class="line">cc.sys.isMobile  &#x2F;&#x2F;是否是移动系统</span><br><span class="line">cc.sys.platform  &#x2F;&#x2F;正在运行的平台</span><br><span class="line">cc.sys.language  &#x2F;&#x2F;当前运行系统的语言</span><br><span class="line">cc.sys.os  &#x2F;&#x2F;当前正在运行的系统</span><br><span class="line">cc.sys.OS_IOS  &#x2F;&#x2F;是否是IOS系统</span><br><span class="line">cc.sys.OS_ANDROID  &#x2F;&#x2F;是否是android系统</span><br><span class="line">cc.sys.OS_WINDOWS  &#x2F;&#x2F;是否是windows系统</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);  &#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>

<h2 id="监听和发射事件"><a href="#监听和发射事件" class="headerlink" title="监听和发射事件"></a>监听和发射事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.node.pauseSystemEvents(true);&#x2F;&#x2F;暂停节点系统事件</span><br><span class="line">this.node.resumeSystemEvents(true);&#x2F;&#x2F;恢复节点系统事件</span><br><span class="line">this.node.targetOff(this);&#x2F;&#x2F;移除所有注册事件</span><br><span class="line"></span><br><span class="line">触摸监听：开始&#39;touchstart&#39;,移动&#39;touchmove&#39;,结束&#39;touchend&#39;,取消&#39;touchcancel&#39;</span><br><span class="line">var pos &#x3D; event.getLocation();&#x2F;&#x2F;获取触摸点的坐标(包含X和Y)</span><br><span class="line">var x &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的X坐标</span><br><span class="line">var y &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的Y坐标</span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line"></span><br><span class="line">鼠标监听：鼠标按下&#39;mousedown&#39;,移入节点&#39;mouseenter&#39;,节点中移动&#39;mousemove&#39;,移出节点&#39;mouseleave,&#39;松开鼠标&#39;mouseup&#39;</span><br><span class="line">var a &#x3D; event.getScrollY();&#x2F;&#x2F;获取滚轮滚动的 Y 轴距离，只有滚动时才有效</span><br><span class="line">var a &#x3D; event.getLocation();&#x2F;&#x2F;获取鼠标位置对象，对象包含 x 和 y 属性</span><br><span class="line"></span><br><span class="line">输入框监听：获得焦点&#39;editing-did-began&#39;,文字变化&#39;text-changed&#39;,失去焦点&#39;editing-did-ended&#39;,按下回车&#39;editing-return&#39;</span><br><span class="line"></span><br><span class="line">属性变化监听：位置&#39;position-changed&#39;,宽高 &#39;size-changed&#39;,旋转&#39;rotation-changed&#39;,缩放&#39;scale-changed&#39;</span><br><span class="line"></span><br><span class="line">ScrollView控件监听：滚动中&#39;scrolling&#39;,停止滚动&#39;scroll-ended&#39;</span><br><span class="line"></span><br><span class="line">用户自定义事件:</span><br><span class="line">this.node.on(&#39;事件名&#39;,function,this);&#x2F;&#x2F;注册监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;);&#x2F;&#x2F;发送监听广播</span><br><span class="line">this.node.off(&#39;事件名&#39;,function,this);&#x2F;&#x2F;关闭监听</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册带参数监听</span><br><span class="line">this.node.on(&#39;事件名&#39;,function(event)&#123;</span><br><span class="line"></span><br><span class="line">“具体方法函数内容”</span><br><span class="line"></span><br><span class="line">&#125;,this);</span><br><span class="line">&#x2F;&#x2F;发送带参数的监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;,&#123;id:1001&#125;);</span><br><span class="line">cc.eventManager.addListener(listener, node);&#x2F;&#x2F;添加事件</span><br><span class="line">cc.eventManager.removeListener((listener);&#x2F;&#x2F;移除事件</span><br></pre></td></tr></table></figure>

<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.director.pause();&#x2F;&#x2F;暂停</span><br><span class="line">cc.director.resume();&#x2F;&#x2F;继续</span><br><span class="line">cc.director.end();&#x2F;&#x2F;退出整个应用</span><br><span class="line">cc.log(变量)  或 console.log(something);&#x2F;&#x2F;输出想要的信息</span><br><span class="line">let self &#x3D; this;&#x2F;&#x2F;锁定当前使用的this指向</span><br><span class="line">node.getLocalZOrder();&#x2F;&#x2F;层级获取</span><br><span class="line">node.setLocalZOrder(1);&#x2F;&#x2F;层级改变</span><br><span class="line">cc.find(&#39;canvas&#x2F;map&#39; + num)&#x2F;&#x2F;读取带变量的路径</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);&#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>spriteAltas精灵图集使用方式</title>
    <url>/2020/04/07/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>之前，对于扑克牌的加载一直是散装加载，用<code>loadRes</code>动态的添加到游戏中，这样的缺陷是在动画的时候会闪一下，在网慢的情况下也许扑克牌不会加载出来而动画就执行了。因此，改用图集加载方式，将整幅扑克牌一起加载出来，用那种加载哪张就行了。</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>新加一个属性:</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407114816545.png" alt="image-20200407114816545"></p>
</li>
<li><p>我们用图集打包出来的是这样的文件：</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407114923862.png" alt="image-20200407114923862"></p>
</li>
<li><p>在<code>cocos</code>上将<code>plist</code>拖进属性中。</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407115004375.png" alt="image-20200407115004375"></p>
</li>
<li><p>编写代码动态修改精灵图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setAtlasImg(node,spAtlas,spriteName)&#123;</span><br><span class="line">  <span class="keyword">let</span> sprite = node.getComponent(cc.Sprite);</span><br><span class="line">  <span class="keyword">if</span> (!sprite) &#123;</span><br><span class="line">    sprite = node.addComponent(cc.Sprite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mySprite =  spAtlas.getSpriteFrame(spriteName)</span><br><span class="line">  sprite.spriteFrame = mySprite;</span><br><span class="line">  <span class="keyword">return</span> mySprite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节点，图集组件，图集中文件名字</span></span><br><span class="line">setAtlasImg(<span class="keyword">this</span>.node, <span class="keyword">this</span>.spAtlas, <span class="string">"11"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>有关用node开发websocket多人聊天程序的后台</title>
    <url>/2020/04/06/node/%E6%9C%89%E5%85%B3%E7%94%A8node%E5%BC%80%E5%8F%91websocket%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8E%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>（开发过程中积累）</p>
<ul>
<li><code>ws</code>库的使用方法</li>
<li><code>node</code>的语言熟悉度</li>
<li>数据库增删改查的基础语法</li>
<li>明确的流程分析与功能</li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>node生成文件模板</title>
    <url>/2020/04/06/node/node%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<blockquote>
<p>主要用作生成文件模板，方便之后的一系列开发，能够快速的制作类似结构的复杂页面。</p>
<p><a href="https://www.npmjs.com/package/plop" target="_blank" rel="noopener">plop npm</a></p>
</blockquote>
<a id="more"></a>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i plop -D</span><br></pre></td></tr></table></figure>

<p>源码下载: <a href="/static/node/node生成文件模板/files/plop.zip">Hexo文章页面模板下载</a></p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>支付宝免签支付</title>
    <url>/2020/04/06/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%8D%E7%AD%BE%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<blockquote>
<p> 源码下载：<a href="/static/前端/业务相关/支付宝免签支付/files/支付宝免签支付.zip">点击下载</a></p>
<p>在最近的公司业务中，需要用到灰色地带的支付，因此不能使用正规的支付宝流程，经过一段事件的调查与研究，发现了有关支付宝的免签支付，不过也存在着几种方式，有些方式并不适用，都存在着一些无法避免的限制。</p>
</blockquote>
<a id="more"></a>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加看板娘</title>
    <url>/2020/04/05/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
    <content><![CDATA[<blockquote>
<p>源码下载：<a href="http://cloud.poorman.top/index.php?share/folder&user=1&sid=NgEfhW2k#" target="_blank" rel="noopener">点击下载</a> 源码地址：<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">live2d-widget</a></p>
<p>这是首先感谢原作者的插件，我根据Github上的项目克隆下载自定义的看板娘，在他的基础上添加了拖动效果，同时根据自己的博客自定义了不同的对话。</p>
</blockquote>
<a id="more"></a>

<h2 id="用法-Usage"><a href="#用法-Usage" class="headerlink" title="用法 Usage"></a>用法 Usage</h2><ol>
<li>首先下载上面的源码，这个<code>hexo-bolg</code>表示是我的博客根目录，然后再<code>source\js</code>目录下解压，得到以下的文件。</li>
</ol>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112453987.png" alt="image-20200405112453987"></p>
<ol start="2">
<li><p>如果是<code>next</code>主题，请根据目录打开以下文件:</p>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112653619.png" alt="image-20200405112653619"></p>
<p>将代码添加到如图所示的位置：</p>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112737704.png" alt="image-20200405112737704"></p>
</li>
<li><p>大功告成，将页面启动起来就能看见效果了。不过最好自己去改一下源码的<code>waifu-tips.json</code>的匹配条件，根据自己的博客做出对应的对话效果。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现全站变灰</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/css%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99%E5%8F%98%E7%81%B0/</url>
    <content><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">     <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-moz-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-ms-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-o-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">filter</span>: progid:DXImageTransfrom.Microsoft.<span class="built_in">BasicImage</span>(grayscale=<span class="number">1</span>);</span><br><span class="line">     <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack零散知识点</title>
    <url>/2020/04/04/webpack/webpack%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><ul>
<li><p><code>mode</code></p>
<p>主要区分为：<code>development</code>和<code>production</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>development</code></td>
<td>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>。启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</td>
</tr>
<tr>
<td><code>production</code></td>
<td>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>。启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code></td>
</tr>
</tbody></table>
<blockquote>
<p><em>记住，只设置</em> <code>NODE_ENV</code><em>，则不会自动设置</em> <code>mode</code>。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>entry</code></p>
<p>可以是数组或者对象</p>
<ul>
<li><p>数组</p>
<p>数组中表示的所有文件都将打包成一个文件，对应的是对象中键的<code>main</code>。也就是说</p>
<p>如果值是<code>[&#39;src/index.js&#39;]</code>的话，跟<code>{main:&#39;src/index.js&#39;}</code>效果是一样的。</p>
</li>
<li><p>对象</p>
<p>如果存在多个键值的话表示的就是多个入口，<code>webpack</code>将会从多个入口进入开始打包。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"entry"</span>:&#123;</span><br><span class="line">   <span class="string">"main"</span>:[<span class="string">"src/index.js"</span>],</span><br><span class="line">   <span class="string">"react"</span>:<span class="string">"react"</span>,</span><br><span class="line">   <span class="string">"vue"</span>:[<span class="string">"vue"</span>,<span class="string">"vue-router"</span>,<span class="string">"vuex"</span>]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如上的话就会打包出三个文件出来，分别是<code>main</code>,<code>react</code>,<code>vue</code>名字可以再输出的时候自定义。</p>
</li>
</ul>
</li>
<li><p><code>output</code></p>
<p>对象。作为此配置的最低要求，我们需要提供两个参数：1. <code>filename</code>表示将要输出的文件名字。2. <code>path</code>将要输出的路径</p>
<ul>
<li><p>单入口文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

<p>此配置将一个单独的 <code>bundle.js</code> 文件输出到 <code>/home/proj/public/assets</code> 目录中。</p>
</li>
<li><p>多入口文件</p>
<p>多入口不能单独的指定一个具体的文件名，而是需要提供一个占位符，由<code>webpack</code>提供各个文件的一些参数，但是具体的名字仍旧可以自己定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.webpackjs.com/concepts/output/" target="_blank" rel="noopener">publicPath</a>  (这个参数尚未用过)</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识漫游</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>前端大部分的知识流程梳理（2019）</p>
</blockquote>
<a id="more"></a>



<p><img src="/static/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%BC%AB%E6%B8%B8/images/image-20200405183952644.png" alt="image-20200405183952644"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>各种标签说明</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p><strong>New</strong> : HTML5 中的新标签。</p>
<table>
<thead>
<tr>
<th><strong>标签</strong></th>
<th><strong>描述</strong></th>
<th>效果</th>
<th>浏览器支持情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!--...--&gt;</code></td>
<td>定义注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;!DOCTYPE&gt;</code></td>
<td>定义文档类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>定义锚点</td>
<td><a href="#">锚点</a></td>
<td></td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>定义缩写</td>
<td><abbr title="People's Republic of China">PRC</abbr></td>
<td></td>
</tr>
<tr>
<td><code>&lt;acronym&gt;</code></td>
<td>定义只取首字母的缩写</td>
<td><acronym title="World Wide Web">WWW</acronym></td>
<td></td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>定义文档作者或拥有者的联系信息。</td>
<td><address> Donald USA</address></td>
<td></td>
</tr>
<tr>
<td><code>&lt;area&gt;</code></td>
<td>定义图像映射内部的区域。</td>
<td><a href="https://www.w3school.com.cn/tags/tag_area.asp" target="_blank" rel="noopener">area说明</a></td>
<td></td>
</tr>
<tr>
<td><code>&lt;article&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义文章。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义页面内容之外的内容。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;audio&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义声音内容</td>
<td><audio></audio></td>
<td>基本都可以用</td>
</tr>
<tr>
<td><code>&lt;b&gt;</code></td>
<td>定义粗体字</td>
<td><b>粗体字</b></td>
<td>基本都可以用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+typora 博客中插入图片</title>
    <url>/2020/04/04/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>在使用了hexo搭建了博客后，最大的问题便是如何使用一款markdown工具来编辑博客了，我采取的就是Typora，这工具免费简单易用没广告，而且把图片保存到本地还是很方便的，因此大家只要稍微了解点markdown语法就可以上手使用了。</p>
</blockquote>
<a id="more"></a>

<p>关于图片和图片路径的设置，有以下教程。</p>
<blockquote>
<p> 所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p>
</blockquote>
<ol>
<li><p><code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p>
</li>
<li><p>打开<code>Typora</code>的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p>
<p><img src="/static/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/images/image-20200411092155916.png" alt="image-20200411092155916"></p>
<p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p>
<p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p>
</li>
<li><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。<strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p>
<p>之后再该<code>md</code>文件头部会出现:<code>typora-root-url: ..\..\source</code>这样的代码，我们将这行代码复制进模板文件中</p>
</li>
<li><p>以下这三个都可以添加</p>
<p><img src="/static/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/images/image-20200411092141854.png" alt="image-20200411092141854"></p>
<p>只要在第一个<code>---</code>下添加<code>typora-root-url: ..\..\source</code>就行了，这样<code>Typora</code>就能识别而不用每次都自己手动设置了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2020/04/03/hexo/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code>#生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务预览<br><code>hexo d</code> == <code>hexo deploy</code>#部署</p>
<a id="more"></a>

<h2 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上是文章摘要 &lt;!--more--&gt; 以下是余下全文</span><br></pre></td></tr></table></figure>

<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><code>hexo new page</code><br><code>hexo new post</code></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题</td>
</tr>
<tr>
<td>:year</td>
<td>建立的年份（4 位数）</td>
</tr>
<tr>
<td>:month</td>
<td>建立的月份（2 位数）</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立的月份（去掉开头的零）</td>
</tr>
<tr>
<td>:day</td>
<td>建立的日期（2 位数）</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立的日期（去掉开头的零）</td>
</tr>
</tbody></table>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p><code>hexo publish [layout] &lt;title&gt;</code></p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p><code>hexo new &quot;postName&quot;</code> #新建文章<br><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #将.deploy目录部署到GitHub</p>
<p><code>hexo new [layout]</code><br><code>hexo new photo &quot;My Gallery&quot;</code><br><code>hexo new &quot;Hello World&quot; --lang tw</code></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>文件建立日期</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">comments: true</span><br><span class="line">categories: Blog</span><br><span class="line">tags: [Hexo]</span><br><span class="line">keywords: Hexo, Blog</span><br><span class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</span><br></pre></td></tr></table></figure>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p>
<p><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令<br><code>hexo g</code> #生成静态网页<br><code>hexo d</code> #开始部署</p>
<h2 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h2><p><code>hexo generate</code> #使用 Hexo 生成静态文件快速而且简单<br><code>hexo generate --watch</code> #监视文件变动</p>
<h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><blockquote>
<p>两个命令的作用是相同的<br><code>hexo generate --deploy</code><br>hexo deploy –generate</p>
</blockquote>
<p><code>hexo deploy -g</code></p>
<p><code>hexo server -g</code></p>
<h2 id="新建Hexo项目"><a href="#新建Hexo项目" class="headerlink" title="新建Hexo项目"></a>新建Hexo项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure>



<!-- more -->

<p>飒飒</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>npm库个人常用整合</title>
    <url>/2020/04/01/npm/npm%E5%BA%93%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h3 id="数学计算库"><a href="#数学计算库" class="headerlink" title="数学计算库"></a>数学计算库</h3><ul>
<li><a href="https://www.npmjs.com/package/mathjs" target="_blank" rel="noopener">math.js</a></li>
</ul>
<h3 id="生成文件模板"><a href="#生成文件模板" class="headerlink" title="生成文件模板"></a>生成文件模板</h3><ul>
<li><a href="https://www.npmjs.com/package/plop" target="_blank" rel="noopener">plop</a> （用于快速生成模板文件，可提供变量定制化输出）</li>
</ul>
<h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ul>
<li><code>webpack</code> (大名鼎鼎的模块打包工具)</li>
</ul>
<h3 id="发布订阅库"><a href="#发布订阅库" class="headerlink" title="发布订阅库"></a>发布订阅库</h3><p><a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="noopener">PubSubJS</a>，<a href="https://www.npmjs.com/package/@types/pubsub-js" target="_blank" rel="noopener">@types/pubsub-js</a>，<a href="https://github.com/Gozala/events" target="_blank" rel="noopener">events</a></p>
<h2 id="Webpack常用库"><a href="#Webpack常用库" class="headerlink" title="Webpack常用库"></a>Webpack常用库</h2><ul>
<li><code>html-webpack-plugin</code> 打包<code>html</code>，提供脚本样式注入等功能</li>
</ul>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>lerna使用方法</title>
    <url>/2020/03/31/lerna/lerna%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><code>lerna</code>主要用于分模块管理<code>js</code>的依赖库，对于库项目开发者非常有友好，它可以将一个大的库项目分离成一个个独立的项目，但又不是完全独立的，而是全部由<code>lerna</code>进行管理。它的类似目录结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">my-lerna-repo/</span><br><span class="line">  package.json</span><br><span class="line">  packages/</span><br><span class="line">    package<span class="number">-1</span>/</span><br><span class="line">      package.json</span><br><span class="line">    package<span class="number">-2</span>/</span><br><span class="line">      package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装</span><br><span class="line">npm i -g lerna</span><br><span class="line">&#x2F;&#x2F; 局部安装</span><br><span class="line">npm i -D lerna</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 你的项目根目录</span><br><span class="line">&#x2F;&#x2F;全局安装的话执行下面这个</span><br><span class="line">lerna init</span><br><span class="line">&#x2F;&#x2F;局部安装的话执行下面这个</span><br><span class="line">npx lerna init</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>lerna</category>
      </categories>
  </entry>
</search>
