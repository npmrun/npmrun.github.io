<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网址</title>
    <url>/2020/05/07/%E6%94%B6%E9%9B%86/%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p><a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">中文文档</a></p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><a href="http://css.cuishifeng.cn/index.html" target="_blank" rel="noopener">参考手册</a></p>
<a id="more"></a>

<h3 id="Vue生态链"><a href="#Vue生态链" class="headerlink" title="Vue生态链"></a>Vue生态链</h3><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官网</a>，<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex(状态管理)</a>，<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vuerouter(路由管理)</a></p>
<h3 id="个人旗下网站"><a href="#个人旗下网站" class="headerlink" title="个人旗下网站"></a>个人旗下网站</h3><p><a href="http://wiki.poorman.top/" target="_blank" rel="noopener">Wiki</a>，</p>
<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><p><a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">官网</a></p>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
  </entry>
  <entry>
    <title>cocos中getLocation以左下角为坐标原点问题</title>
    <url>/2020/05/27/cocos/cocos%E4%B8%ADgetLocation%E4%BB%A5%E5%B7%A6%E4%B8%8B%E8%A7%92%E4%B8%BA%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>参考链接</p>
<p><a href="https://forum.cocos.org/t/creator/85600" target="_blank" rel="noopener">https://forum.cocos.org/t/creator/85600</a></p>
</blockquote>
<p>按下面这样从世界坐标转化为本地节点坐标就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">this</span>.map.on(cc.Node.EventType.MOUSE_DOWN,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> pos = <span class="keyword">this</span>.map.convertToNodeSpaceAR(event.getLocation());</span><br><span class="line">     <span class="keyword">this</span>.graphics.fillColor = <span class="keyword">new</span> cc.Color().fromHEX(<span class="string">'#0000ff'</span>);</span><br><span class="line">     <span class="keyword">this</span>.graphics.circle(pos.x,pos.y,<span class="number">10</span>)</span><br><span class="line">     <span class="keyword">this</span>.graphics.fill();</span><br><span class="line">&#125;,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>animation动画结束后css样式怎么保留最后状态</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/animation%E5%8A%A8%E7%94%BB%E7%BB%93%E6%9D%9F%E5%90%8Ecss%E6%A0%B7%E5%BC%8F%E6%80%8E%E4%B9%88%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-fill-mode:forwards</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>样式统一化</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/%E6%A0%B7%E5%BC%8F%E7%BB%9F%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li><a href="http://necolas.gihub.io/normalize.css/" target="_blank" rel="noopener">Normalize.css</a></li>
<li><a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">reset.css</a></li>
</ol>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>css权重简述</title>
    <url>/2020/05/25/css/%E7%9F%A5%E8%AF%86/css%E6%9D%83%E9%87%8D%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>CSS权重指的是样式的优先级，有两条或者多条元素作用于同一个元素，权重高的样式会起作用，而权重相同的话，后面的权重会覆盖前面的。</p>
<h3 id="权重的等级"><a href="#权重的等级" class="headerlink" title="权重的等级"></a>权重的等级</h3><p>可以把样式的应用方式分为几个等级，按照等级来计算权重</p>
<ol>
<li><code>!important</code>，加在样式属性值后，权重值为 10000</li>
<li>内联样式，如：<code>style=&quot;&quot;</code>，权重值为1000</li>
<li>ID选择器，如：<code>#content</code>，权重值为100</li>
<li>类，伪类和属性选择器，如： <code>content</code>、<code>:hover</code> 权重值为10</li>
<li>标签选择器和伪元素选择器，如：<code>div</code>、<code>p</code>、<code>:before</code> 权重值为1</li>
<li>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</li>
</ol>
<p>有需要计算权重的时候只需要将以上规则套入然后计算就行了</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>cocos Web构建模板</title>
    <url>/2020/05/25/cocos/cocos%20Web%E6%9E%84%E5%BB%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<blockquote>
<p>V1.9.0模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(1.9.0).zip)</p>
<p>V2.2.2模板 [build-templates.zip](/static/cocos/cocos Web构建模板/files/build-templates(2.2.2).zip)</p>
<p>其实两个都一样，有报错的话自己解决一下就好了</p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>cocos两点之间的距离</title>
    <url>/2020/05/21/cocos/cocos%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startPos = cc.v2(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//开始位置</span></span><br><span class="line"><span class="keyword">let</span> endPos = cc.v2(<span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//结束位置</span></span><br><span class="line"><span class="keyword">let</span> distance = startPos.sub(endPos).mag();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>cocos龙骨局部换装</title>
    <url>/2020/05/16/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>在cocos中，动画是必不可少的，一个细腻的动画可能就是决定一款游戏的成败。对于一些没钱的开发者来说，龙骨动画是一个不错的选择，但是cocos对其的支持并不是十分的友好。这次我们需要解决的是换装的问题。</p>
<p>案例：v2.2.2编辑器，<a href="/static/cocos/cocos龙骨局部换装/files/龙骨插槽替换.zip">龙骨插槽替换.zip</a></p>
</blockquote>
<a id="more"></a>

<h2 id="需要实现的效果"><a href="#需要实现的效果" class="headerlink" title="需要实现的效果"></a>需要实现的效果</h2><p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143013713.png" alt="image-20200517143013713"></p>
<p>上面是原始效果，可以看到有两个插槽,一个是<code>fish</code>,一个是<code>number</code>。这个时候cocos并不能替换，因为是空的，因此就需要随便添加两个资源。</p>
<p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143122750.png" alt="image-20200517143122750"></p>
<p>这里我就添加<code>fish</code>插槽，那个<code>number</code>感觉太麻烦了，是一个滚动的数字。这样的话就能够使用cocos官方提供的方式进行换装替换 了。</p>
<h3 id="制作龙骨模型替换资源"><a href="#制作龙骨模型替换资源" class="headerlink" title="制作龙骨模型替换资源"></a>制作龙骨模型替换资源</h3><p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143330120.png" alt="image-20200517143330120"></p>
<blockquote>
<ul>
<li><code>Armature</code>表示 部件名称</li>
<li><code>killboss_bx</code>表示 插槽名称</li>
<li><code>kypy_killboss_hjcts</code>表示 插槽中的显示资源名称</li>
</ul>
</blockquote>
<p>接下来对两个资源进行导出，根据论坛中引擎开发人员的建议，将<code>_tex.json</code>后缀的改成了<code>_atlas.json</code>的。类似于</p>
<p><img src="/static/cocos/cocos%E9%BE%99%E9%AA%A8%E5%B1%80%E9%83%A8%E6%8D%A2%E8%A3%85/images/image-20200517143824254.png" alt="image-20200517143824254"></p>
<p>这样的话准备条件就做好了。不过仍有两种方式。</p>
<h3 id="挂载节点替换"><a href="#挂载节点替换" class="headerlink" title="挂载节点替换"></a>挂载节点替换</h3><p>总代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;,</span><br><span class="line">        c: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    start () &#123;</span><br><span class="line">    	&#x2F;&#x2F; 需要被替换的fish插槽</span><br><span class="line">        let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;);</span><br><span class="line">        let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">        factory.replaceSlotDisplay(</span><br><span class="line">            this.c.getArmatureKey(), </span><br><span class="line">            &quot;Armature&quot;, &#x2F;&#x2F;  部件名称</span><br><span class="line">            &quot;killboss_bx&quot;, &#x2F;&#x2F; 插槽名称</span><br><span class="line">            &quot;kypy_killboss_mgy&quot;,  &#x2F;&#x2F; 显示资源名称</span><br><span class="line">            robotSlot</span><br><span class="line">        );</span><br><span class="line">        this.b.playAnimation(&quot;animation&quot;, 500);  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的<code>b</code>表示需要被替换资源的龙骨动画节点组件,<code>c</code>表示将要拿去替换的龙骨节点组件。</p>
<p>这里要保证<code>c</code>中的资源已经加载完毕，在我测试的时候，c节点必须处于激活状态，这样才保证了c节点中龙骨资源的加载。</p>
<h3 id="loader动态加载（推荐）"><a href="#loader动态加载（推荐）" class="headerlink" title="loader动态加载（推荐）"></a>loader动态加载（推荐）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;,</span><br><span class="line">        c: &#123;</span><br><span class="line">            type: dragonBones.ArmatureDisplay,</span><br><span class="line">            default: null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    loadBones(cb) &#123;</span><br><span class="line">        let name &#x3D; &quot;NewProject&quot;</span><br><span class="line">        const resources &#x3D; [</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_ske.json&#96;),</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_atlas.json&#96;),</span><br><span class="line">            cc.url.raw(&#96;resources&#x2F;$&#123;name&#125;_tex.png&#96;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        cc.loader.load(resources, (err, assets) &#x3D;&gt; &#123;</span><br><span class="line">            let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">            let data &#x3D; JSON.parse(cc.loader.getRes(resources[0])._dragonBonesJson);</span><br><span class="line">            factory.parseDragonBonesData(data);</span><br><span class="line"></span><br><span class="line">            let atlasData &#x3D; JSON.parse(cc.loader.getRes(resources[1])._atlasJson);</span><br><span class="line">            factory.parseTextureAtlasData(atlasData, cc.loader.getRes(resources[2]));</span><br><span class="line">            console.log(cc.loader.getRes(resources[1])._atlasJson);</span><br><span class="line">            </span><br><span class="line">            cb&amp;&amp;cb()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    start () &#123;</span><br><span class="line">        this.loadBones(()&#x3D;&gt;&#123;</span><br><span class="line">            let robotSlot &#x3D; this.b.armature().getSlot(&quot;fish&quot;);</span><br><span class="line">            let factory &#x3D; dragonBones.CCFactory.getInstance();</span><br><span class="line">            factory.replaceSlotDisplay(</span><br><span class="line">                &quot;NewProject&quot;,  &#x2F;&#x2F; 跟上面的一样就行了。</span><br><span class="line">                &quot;Armature&quot;, </span><br><span class="line">                &quot;killboss_bx&quot;, </span><br><span class="line">                &quot;kypy_killboss_mgy&quot;, </span><br><span class="line">                robotSlot</span><br><span class="line">            );</span><br><span class="line">            this.b.playAnimation(&quot;animation&quot;, 500); </span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; this.b.playAnimation(&quot;animation&quot;, 500);   </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我用的是<code>cc.loader.load</code>方式，这样就能保证资源已经加载完毕了。同时也减少了节点的创建。推荐使用这种方式。</p>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ol>
<li>被换装的插槽里必须有资源才行，空的一个插槽并不能替换。</li>
<li>换装的资源必须加载。如果挂载在节点上必须保证这个节点是激活状态而证明资源是加载过的。</li>
</ol>
<blockquote>
<p>参考资料</p>
<p><a href="https://forum.cocos.org/t/topic/89037" target="_blank" rel="noopener">https://forum.cocos.org/t/topic/89037</a></p>
<p><a href="https://docs.cocos.com/creator/manual/zh/components/dragonbones.html?h=插槽" target="_blank" rel="noopener">https://docs.cocos.com/creator/manual/zh/components/dragonbones.html?h=%E6%8F%92%E6%A7%BD</a></p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>一镜到底</title>
    <url>/2020/05/09/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E6%88%98/%E4%B8%80%E9%95%9C%E5%88%B0%E5%BA%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Widget</title>
    <url>/2020/05/06/cocos/Widget/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.cocos.com/creator/api/zh/classes/Widget.html#updatealignment" target="_blank" rel="noopener">https://docs.cocos.com/creator/api/zh/classes/Widget.html#updatealignment</a></p>
</blockquote>
<h5 id="updateAlignment"><a href="#updateAlignment" class="headerlink" title="updateAlignment"></a>updateAlignment</h5><p>立刻执行 widget 对齐操作。这个接口一般不需要手工调用。 只有当你需要在当前帧结束前获得 widget 对齐后的最新结果时才需要手动调用这个方法。</p>
<a id="more"></a>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">widget.top = <span class="number">10</span>;       <span class="comment">// change top margin</span></span><br><span class="line">cc.log(widget.node.y); <span class="comment">// not yet changed</span></span><br><span class="line">widget.updateAlignment();</span><br><span class="line">cc.log(widget.node.y); <span class="comment">// changed</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能会遇见的问题</p>
<p><a href="https://blog.csdn.net/u013654125/article/details/83379765" target="_blank" rel="noopener">https://blog.csdn.net/u013654125/article/details/83379765</a></p>
</blockquote>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>苹果录像有关hevc格式视频的网页播放</title>
    <url>/2020/05/01/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E8%8B%B9%E6%9E%9C%E5%BD%95%E5%83%8F%E6%9C%89%E5%85%B3hevc%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>格式可以使用window上的potplayer播放，右键看属性</p>
<p><a href="http://get.ftqq.com/9132.get" target="_blank" rel="noopener">http://get.ftqq.com/9132.get</a></p>
<p><a href="https://blog.csdn.net/keji_123/article/details/77717849?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">https://blog.csdn.net/keji_123/article/details/77717849?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50655841" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50655841</a></p>
<p><a href="https://tieba.baidu.com/p/5882990363?red_tag=1551058192" target="_blank" rel="noopener">https://tieba.baidu.com/p/5882990363?red_tag=1551058192</a></p>
<a id="more"></a>

<p><img src="/static/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E8%8B%B9%E6%9E%9C%E5%BD%95%E5%83%8F%E6%9C%89%E5%85%B3hevc%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE/images/image-20200501114203764.png" alt="image-20200501114203764"></p>
<p>改成兼容性最佳可以直接播放</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>代码笔记本推荐</title>
    <url>/2020/04/29/%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="Cacher"><a href="#Cacher" class="headerlink" title="Cacher"></a>Cacher</h1><p>其实GitHub上是有提供代码片段管理功能的, 名字叫gist<br>Cacher是它的一个桌面版Interface, 分为免费版, 个人专业版和协作版</p>
<p>官网地址: <a href="https://www.cacher.io/" target="_blank" rel="noopener">https://www.cacher.io/</a></p>
<h1 id="Lepton"><a href="#Lepton" class="headerlink" title="Lepton"></a>Lepton</h1><p>GitHub地址: <a href="https://github.com/hackjutsu/Lepton" target="_blank" rel="noopener">https://github.com/hackjutsu/Lepton</a></p>
<h1 id="Snippet-Store"><a href="#Snippet-Store" class="headerlink" title="Snippet Store"></a>Snippet Store</h1><p>官网地址: <a href="https://zerox-dg.github.io/SnippetStoreWeb/" target="_blank" rel="noopener">https://zerox-dg.github.io/SnippetStoreWeb/</a><br>GitHub地址: <a href="https://github.com/ZeroX-DG/SnippetStore" target="_blank" rel="noopener">https://github.com/ZeroX-DG/SnippetStore</a></p>
<h1 id="VNote"><a href="#VNote" class="headerlink" title="VNote"></a>VNote</h1><p>官网地址: <a href="https://tamlok.github.io/vnote/en_us/#!index.md" target="_blank" rel="noopener">https://tamlok.github.io/vnote/en_us/#!index.md</a><br>GitHub地址: <a href="https://github.com/tamlok/vnote" target="_blank" rel="noopener">https://github.com/tamlok/vnote</a></p>
<p><a href="https://boostnote.io/" target="_blank" rel="noopener">https://boostnote.io/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>vue响应式原理</title>
    <url>/2020/04/29/vue/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="观察器"><a href="#观察器" class="headerlink" title="观察器"></a>观察器</h3><blockquote>
<p>主要是对值变化的观察，针对该值对象的元素能够监听到其设置值与获取值才行。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Observer &#123;</span><br><span class="line">    constructor(data) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果传入的值不是对象或者不存在，就直接退出</span><br><span class="line">        if (!data || typeof data !&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绑定单一的值</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        &#x2F;&#x2F; 遍历所有可遍历属性</span><br><span class="line">        this.walk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk() &#123;</span><br><span class="line">        for (const key in this.data) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 对每一个元素进行可监测处理</span><br><span class="line">            this.defineReactive(this.data, key, this.data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj, key, val) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果传入的又是一个对象，那么需要对其子元素继续进行监测处理</span><br><span class="line">        new Observer(val);</span><br><span class="line">        &#x2F;&#x2F; 定义可监测代码的主要函数</span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">            	&#x2F;&#x2F; 针对值获取的拦截处理，如console.log(obj.a)</span><br><span class="line">                console.log(&#39;1&#39;);</span><br><span class="line">                return val;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVaule) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 针对赋值的拦截处理，如obj.a &#x3D; 100</span><br><span class="line">                if (val &#x3D;&#x3D;&#x3D; newVaule) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(&#39;2&#39;);</span><br><span class="line">                val &#x3D; newVaule;</span><br><span class="line">                &#x2F;&#x2F; 对新改变的值继续进行可监测处理</span><br><span class="line">                new Observer(newVaule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &quot; cjg&quot;,</span><br><span class="line">    obj: &#123;</span><br><span class="line">        name: &quot;zht&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ob &#x3D; new Observer(data);</span><br><span class="line">ob.defineReactive(data,&#39;aa&#39;,5)</span><br><span class="line">data.aa&#x3D;4</span><br><span class="line">data.aa</span><br><span class="line">&#x2F;&#x2F;---&gt;</span><br><span class="line">&#x2F;&#x2F;2 &#x2F;&#x2F; 先是赋值</span><br><span class="line">&#x2F;&#x2F;1 &#x2F;&#x2F; 然后值获取</span><br></pre></td></tr></table></figure>

<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 观察器</span><br><span class="line">***</span><br><span class="line">  defineReactive(obj, key, val) &#123;</span><br><span class="line">    const dep &#x3D; new Dep(); &#x2F;&#x2F; 每一个值定义一个依赖管理</span><br><span class="line">    new Observer(val);</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        console.log(&#39;1&#39;);</span><br><span class="line">        if (Dep.target) &#123; &#x2F;&#x2F; 如果管理器绑定了一个监听器，那么就将可监测值推入管理队列中</span><br><span class="line">          dep.addSub(Dep.target); &#x2F;&#x2F; 推入操作</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVaule) &#123;</span><br><span class="line">        if (val &#x3D;&#x3D;&#x3D; newVaule) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        val &#x3D; newVaule;</span><br><span class="line">        new Observer(newVaule);</span><br><span class="line">        dep.notify(); &#x2F;&#x2F; 依赖刷新</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 依赖管理器</span><br><span class="line">class Dep &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    if (this.subs.indexOf(sub) &lt; 0) &#123;</span><br><span class="line">      this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    this.subs.forEach((sub) &#x3D;&gt; &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 用户绑定Watcher</span><br><span class="line">Dep.target &#x3D; null;</span><br></pre></td></tr></table></figure>

<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  &#x2F;&#x2F; vm: 响应式对象</span><br><span class="line">  &#x2F;&#x2F; keys: 响应式对象的属性</span><br><span class="line">  &#x2F;&#x2F; updateCb: 数值更新时的回调</span><br><span class="line">  constructor(vm, keys, updateCb) &#123;</span><br><span class="line">    this.vm &#x3D; vm;</span><br><span class="line">    this.keys &#x3D; keys;</span><br><span class="line">    this.updateCb &#x3D; updateCb;</span><br><span class="line">    this.value &#x3D; null;</span><br><span class="line">    this.get();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 监听器绑定</span><br><span class="line">  get() &#123;</span><br><span class="line">  	&#x2F;&#x2F; 依赖管理器设置该监听器</span><br><span class="line">    Dep.target &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 对属性的拆分，例如obj.a.a</span><br><span class="line">    const keys &#x3D; this.keys.split(&#39;.&#39;);</span><br><span class="line">    &#x2F;&#x2F; 获取响应式对象</span><br><span class="line">    let value &#x3D; this.vm;</span><br><span class="line">    &#x2F;&#x2F; 对属性进行值的获取，直到最终值</span><br><span class="line">    keys.forEach(_key &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里由于value[_key]获取了值，会执行上面监听器中defineProperty的get属性函数,这样get函数中的依赖收集变会启动并收集该属性.</span><br><span class="line">      value &#x3D; value[_key];</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 旧值的临时存储</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">    &#x2F;&#x2F; 因为上边依赖已经收集完毕,所有可以去掉了,方便下一个响应式对象的设置</span><br><span class="line">    Dep.target &#x3D; null;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">  	&#x2F;&#x2F; 依赖更新,值在被更新的时候执行的函数</span><br><span class="line">    const oldValue &#x3D; this.value;</span><br><span class="line">    const newValue &#x3D; this.get(); &#x2F;&#x2F;获取最新值</span><br><span class="line">    if (oldValue !&#x3D; newValue) &#123;</span><br><span class="line">      this.updateCb(oldValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>commander使用方法</title>
    <url>/2020/04/27/npm/commander%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md#parse-%e5%92%8c-parseasync" target="_blank" rel="noopener">npm commander</a></p>
<h2 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h2><p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i commander --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>Hello World</strong></p>
<p><code>main.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">const &#123; Command &#125; &#x3D; require(&#39;commander&#39;);</span><br><span class="line"></span><br><span class="line">const program &#x3D; new Command();</span><br><span class="line">program</span><br><span class="line">  .version(&#39;0.1.0&#39;)</span><br><span class="line">  .command(&#39;rmdir &lt;dir&gt; [otherDirs...]&#39;)</span><br><span class="line">  .action(function (dir, otherDirs) &#123;</span><br><span class="line">    console.log(&#39;rmdir %s&#39;, dir);</span><br><span class="line">    if (otherDirs) &#123;</span><br><span class="line">      otherDirs.forEach(function (oDir) &#123;</span><br><span class="line">        console.log(&#39;rmdir %s&#39;, oDir);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>

<p><strong>可执行文件</strong></p>
<p>在<code>package.json</code>中添加以下字段，确保<code>dist/main.js</code>是一个可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	***</span><br><span class="line">	&quot;bin&quot;: &#123;</span><br><span class="line">       &quot;gamecli&quot;: &quot;dist&#x2F;main.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的根路径下执行：<code>npm link</code>,会自动添加可执行文件,等待完成之后，执行<code>gamecli -V</code>就能看到效果了。</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>docker启蒙</title>
    <url>/2020/04/26/docker/docker%E5%90%AF%E8%92%99/</url>
    <content><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>Docker</code>允许你在容器内运行应用程序，使用<code>docker run</code>命令在容器中运行一个应用程序。如下：将会输出一个<code>Hello world</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br><span class="line">$ Hello world</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>docker`: Docker的二进制执行文件</li>
<li><code>run</code>：与前面的docker组合来运行一个容器</li>
<li><code>ubuntu:15.10</code> 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker就会从镜像仓库DockerHub下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器中执行的命令</li>
</ul>
<p>以上的代码大概意思是：Docker以ubuntu15.10镜像创建一个新容器，然后再容器里执行<code>/bin/echo &quot;Hello world&quot;</code>,输出结果</p>
<h2 id="运行交互式容器"><a href="#运行交互式容器" class="headerlink" title="运行交互式容器"></a>运行交互式容器</h2><p>有时我们需要自己进入容器的命令行来执行一些操作，这种情况显然是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这样的话，就会进入容器<code>ubuntu:15.10</code>内的命令行。</p>
<ul>
<li><code>-t</code>:再新容器中指定一个伪终端或终端</li>
<li><code>-i</code>:允许你在容器内的标77bd8交互</li>
</ul>
<p>当出现类似于<code>root@0123ce188bd8:/#</code>,表示我们已经进入一个``ubuntu15.10<code>系统的容器了，我们可以运行下</code>ls`查看当前目录的文件。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>在可交互式容器中输入<code>exit</code>,或者Ctrl+D来退出容器。</p>
<h2 id="以进程方式启动容器"><a href="#以进程方式启动容器" class="headerlink" title="以进程方式启动容器"></a>以进程方式启动容器</h2><p>使用以下命令创建一个进程式容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello world;sleep 1;done&quot;</span><br><span class="line">一长串的字符</span><br></pre></td></tr></table></figure>

<p>上面一长串的字符叫做容器ID，对于容器来说，这是唯一的。我们可以通过容器ID来查看容器发生了什么。当然，我们需要确认是否有容器在运行：<code>docker ps</code></p>
<p><img src="/static/docker/docker%E5%90%AF%E8%92%99/images/image-20200426220150273.png" alt="image-20200426220150273"></p>
<p>如果，我们可以看到有一个容器。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONTAINER ID</td>
<td>容器ID</td>
</tr>
<tr>
<td>IMAGE</td>
<td>使用的镜像</td>
</tr>
<tr>
<td>COMMAND</td>
<td>启动容器时运行的命令</td>
</tr>
<tr>
<td>STATUS</td>
<td>容器状态(7种)<br />create(已创建)     restarting(重启中)     running(运行中)<br />removing(迁移种)     paused(暂停)     exited(停止)    dead(死亡)</td>
</tr>
<tr>
<td>PORT</td>
<td>容器的端口细腻些和使用的链接类型（tcp\udp）</td>
</tr>
<tr>
<td>NAME</td>
<td>启动分配的容器名称</td>
</tr>
</tbody></table>
<p>为了查看宿主主机内的输出，我们可以运行<code>docker logs ***</code>，后面表示ID或者容器名称</p>
<p><img src="/static/docker/docker%E5%90%AF%E8%92%99/images/image-20200426220812571.png" alt="image-20200426220812571"></p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps  # 查看容器的信息</span><br><span class="line">docker stop *** # 后面接ID或者容器名称</span><br><span class="line">docker ps # 看到容器已经不在了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli3跨域代理配置</title>
    <url>/2020/04/25/vue/vue/vue-cli3%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>配置只能作用于本地，开发模式下，axios请不要设置默认服务器网址，这个在<code>vue.config.js</code>中设置。<img src="/static/vue/vue/vue-cli3%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/images/image-20200425141012188.png" alt="image-20200425141012188"></p>
</blockquote>
<p><code>vue.config.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	***</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		port: port, &#x2F;&#x2F; 本地服务的端口</span><br><span class="line">		open: true, &#x2F;&#x2F; 启动之后是否自动打开浏览器</span><br><span class="line">		proxy: &#123;</span><br><span class="line">          &#39;&#x2F;member&#39;: &#123;	&#x2F;&#x2F;配置&#96;&#x2F;member&#96;开头的网址</span><br><span class="line">            target: &#39;http:&#x2F;&#x2F;0000000:9002&#39;, &#x2F;&#x2F;请替换成你自己的服务器地址</span><br><span class="line">            ws: false, &#x2F;&#x2F; 是否代理websockets</span><br><span class="line">            changeOrigin: true, &#x2F;&#x2F; 默认是false：请求头中host仍然是浏览器发送过来的host</span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">              &#x2F;&#x2F; &#39;^&#x2F;member&#39;: &#39;&#39; &#x2F;&#x2F; 重写路径，这个的意思是去掉了&#x2F;member</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue+iframe通信于判断是否被引用</title>
    <url>/2020/04/25/vue/vue/vue+ifram%E9%80%9A%E4%BF%A1%E4%BA%8E%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #framePage&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        width: 100vw;</span><br><span class="line">        height: 100vh;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      window.onload &#x3D; function() &#123;</span><br><span class="line">        var frame &#x3D; document.getElementById(&#39;framePage&#39;);</span><br><span class="line">        &#x2F;&#x2F; 发送消息</span><br><span class="line">        frame.contentWindow.postMessage(&#123;hide:true&#125;,&#39;*&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;iframe id&#x3D;&quot;framePage&quot; src&#x3D;&quot;http:&#x2F;&#x2F;localhost:9528&#x2F;#&#x2F;dashboard&quot; frameborder&#x3D;&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h2><p>我用的vue，因此用vue做示例，我的写在了main.js里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function(event) &#123;</span><br><span class="line">  if (event.data.hide) &#123;</span><br><span class="line">    store.state.isHideAll &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false)</span><br><span class="line">&#x2F;&#x2F;判断是不是被iframe引用了</span><br><span class="line">if (window.self !&#x3D;&#x3D; window.top) &#123;</span><br><span class="line">  store.state.isHideAll &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就被store管理了，在vue里也能够实时更新</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>node后端解决跨域</title>
    <url>/2020/04/25/%E8%B7%A8%E5%9F%9F/node%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>注意这个Access-Control-Allow-Headers,当然也可以设置为*</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app&#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置允许跨域访问该服务.</span><br><span class="line">app.all(&#39;*&#39;, function (req, res, next) &#123;</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);</span><br><span class="line">&#x2F;&#x2F;   Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type,token&#39;);</span><br><span class="line">  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;);</span><br><span class="line">  res.header(&#39;Content-Type&#39;, &#39;application&#x2F;json;charset&#x3D;utf-8&#39;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里虽说省略也可以，但是改成404就不行，因为会自动返回200</span><br><span class="line">app.options(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123;</span><br><span class="line">    res.sendStatus(200);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(&#39;&#x2F;member&#x2F;api&#x2F;game&#x2F;authorization&#39;, (req, res)&#x3D;&gt;&#123;</span><br><span class="line">    res.send(&#123;aa:123&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, ()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Server is running at http:&#x2F;&#x2F;localhost:8083&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端针对跨域的两个条件：</p>
<ul>
<li><p>options请求返回200 （复杂请求会有预检请求）</p>
</li>
<li><p>响应携带允许跨域的请求头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line">Access-Control-Allow-Methods</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>跨域</category>
      </categories>
  </entry>
  <entry>
    <title>git-rebase详解</title>
    <url>/2020/04/24/git/git-rebase%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase" target="_blank" rel="noopener">https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase</a></p>
</blockquote>
<h1 id="Rebase-代替合并"><a href="#Rebase-代替合并" class="headerlink" title="Rebase 代替合并"></a>Rebase 代替合并</h1><p>虽然<code>合并（merge）</code>操作可以用来简单和方便地整合改动，但是它却不是唯一的方法。<code>“Rebase”</code> 就是另一种替代手段。</p>
<blockquote>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>虽然 rebase 相对于我们已知的整合操作来说有着比较显著的优点，但是这也是在很大程度上取决于个人的喜好。一些团队喜欢使用 rebase，而另一些可能倾向于使用合并。</p>
<p>Rebase 相对于合并来说是比较复杂的。我建议你可以跳过这一章，除非你和你的团队确定会用到 rebase 操作。当你积累了 Git 的一些基本使用流程的实践经验后，你也可以在以后的时间再回来学习本章的内容。</p>
</blockquote>
<a id="more"></a>

<h2 id="深入了解合并操作"><a href="#深入了解合并操作" class="headerlink" title="深入了解合并操作"></a>深入了解合并操作</h2><p>在你进入<code>rebase</code> 这个主题前，我们有必要来再次探讨一下更多关于合并操作的细节。当 Git 执行一个合并时，它实际上会查找三个提交：</p>
<p>(1)共同的原始提交<br>如果你在项目中查看两个分支的历史，它们总是会出自于一次共同的提交，那么在当时的时间点上，这两个分支还是拥有相同的内容。之后它们就开始有了差别。</p>
<p>(2) + (3) 两个分支的最终点<br>合并操作的目的就是把两个分支的最新状态结合起来。因此他们各自的最新版本是有特殊含义的。</p>
<p>结合这三个提交后得到的结果就是我们整合的目标。</p>
<h2 id="快进或合并提交"><a href="#快进或合并提交" class="headerlink" title="快进或合并提交"></a>快进或合并提交</h2><p>一种最简单的情况是，在其中的一个分支上没有任何一个新的改动提交发生。那么在它之前的最后一次提交就仍然还是那个共同的原始提交。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-fast-forward.gif" alt="img"></p>
<p>在这种情况下，执行整合操作就非常简单了。 Git 仅仅需要添加所有那些在另外一个分支上的新提交就可以了。在 Git 中，这种最简单的整合操作我们称之为 <code>“快进（fast-forward）”</code>合并。之后两个分支就拥有了完全相同的历史。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-fast-forward.gif" alt="img"></p>
<p>但是在大多数情况下，两个分支都会有自己不同的发展轨迹。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-merge-commit.gif" alt="img"></p>
<p>为了完成整合，Git 会需要创建一个新的提交来含括它们之间的差异，这就是整合提交（merge commit）。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-merge-commit.gif" alt="img"></p>
<h2 id="手工提交与合并提交"><a href="#手工提交与合并提交" class="headerlink" title="手工提交与合并提交"></a>手工提交与合并提交</h2><p>通常情况下，提交都是由手工精心创建的。这样也就能更好地保证一次提交只涉及一个关联改动，并且能更好地注释这个提交。</p>
<p>一个合并提交就不同了，它不是由开发人员手动创建的，而是由 Git 自动生成的。它也不涉及一个关联改动，其目的只是连接两个分支，就像节点一样。如果之后想要了解某个合并操作，你只需要查看这两个分支的历史记录和它们相应的提交树（version tree）。</p>
<h2 id="Rebase-整合"><a href="#Rebase-整合" class="headerlink" title="Rebase 整合"></a>Rebase 整合</h2><p>有些人并不喜欢使用这种自动合并提交。相反，他们希望项目拥有一个单一的历史发展轨迹。比如一条直线。在历史纪录上没有迹象表明在某些时间它被分成过多个分支。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/end-situation-rebase.gif" alt="img"></p>
<p>现在就让我们一步一步地了解一下 <code>rebase</code> 操作吧！仍然来使用前面的例子：我们想合并分支 B 到 分支 A 中，但是这次使用 <code>rebase</code> 操作。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/starting-situation-rebase.gif" alt="img"></p>
<p>使用下面这个非常的简单的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase branch-B</span><br></pre></td></tr></table></figure>

<p>首先，Git 会 <code>“撤销”</code> 所有在分支 A 上的那些在与分支 B 的共同提交之后发生的提交。当然，Git 不会真的放弃这些提交，其实你可以把这些撤销的提交想像成 “<em>被暂时地存储</em>” 到另外的一个地方去了。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-1.gif" alt="img"></p>
<p>接下来它会整合那些在分支 B（这个我们想要整合的分支）上的还未整合的提交到分支 A 中。在这个时间点，这两个分支看起来会是一模一样的。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-2.gif" alt="img"></p>
<p>最后，那些在分支 A 的新的提交（也就是第一步中自动撤销掉的那些提交）会被重新应用到这个分支上，但是在不同的位置上，在那些从分支 B 被整合过来的提交之后，它们就被 <em>re-based</em> 了。<br>整个项目开发轨迹看起来就像发生在一条直线上。相对于一个合并提交，rebase 包括了所有的组合变化，最原始的提交结构会被保留下来。</p>
<p><img src="/static/git/git-rebase%E8%AF%A6%E8%A7%A3/images/rebase-step-3.gif" alt="img"></p>
<h2 id="Rebase-存在的陷阱"><a href="#Rebase-存在的陷阱" class="headerlink" title="Rebase 存在的陷阱"></a>Rebase 存在的陷阱</h2><p>当然，使用 <strong>rebase</strong> 操作不会是永远一帆风顺的。很有可能会搬起石头砸自己的脚，因此你不能忽视一个重要的事实：<strong>rebase 会改写历史记录</strong>。</p>
<p>你有可能已经注意到了，在被 rebase 操作之后的版本中，提交 “C3*” 存在一个新添加的星号。这是因为，尽管这个提交的内容和 “C3” 完全一样，但是它实际上是一个不同的提交。这样做的原因是，它现在有一个新的源提交 C4（在最初创建 C3 时的源提交是 C1）。</p>
<p>一个提交仅仅包括很少的属性，比如作者，日期，变动和谁是它的父提交。如果改变其中任何一个信息，就必须创建一个全新的提交。当然，新的提交也会拥有一个新的 <code>hash ID</code> 。</p>
<p>如果还仅仅只是操作那些尚未发布的提交，重写历史记录本身也没有什么很大的问题。但是如果你重写了已经发布到公共服务器上的提交历史，这样做就非常危险了。其他的开发人员可能这时已经在最原始的提交 C3 上开始工作，并使它成为了一些新提交中不可或缺的部分，而现在你却把 C3 的改动设置到了另一个时间点（就是那个新的 C3*）。除此之外，通过rebase 操作，这个原始的 C3 还被删除掉了，这将是非常可怕的……</p>
<blockquote>
<p> 因此你应该只使用 rebase 来清理你的本地工作，千万不要尝试着对那些已经被发布的提交进行这个操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>ts使用paths配置路径别名</title>
    <url>/2020/04/24/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    ***</span><br><span class="line">    &#x2F;&#x2F; 配置基础路径</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">    	&#x2F;&#x2F; &#39;@&#x2F;*&#39; 表示中的@表示路径别名，*代表匹配所有声明的所有路径</span><br><span class="line">    	&#x2F;&#x2F; &#39;.&#x2F;app&#x2F;*&#39; 表示在baseUrl的相对目录下的app的所有文件都在paths的范围内</span><br><span class="line">        &quot;@&#x2F;*&quot;: [&quot;.&#x2F;app&#x2F;*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    ***</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;app&#x2F;public&quot;,</span><br><span class="line">    &quot;app&#x2F;views&quot;,</span><br><span class="line">    &quot;node_modules*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>webstrom的一些配置：</p>
<p><img src="/static/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/images/image-20200424105018577.png" alt="image-20200424105018577"></p>
<p><img src="/static/ts/ts%E4%BD%BF%E7%94%A8paths%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/images/image-20200424105035089.png" alt="image-20200424105035089"></p>
<blockquote>
<p>不一定要一样，只是我这样是可以用的。</p>
<p>那个Recompile on changes不推荐钩选，不然会把你的所有ts文件的同级目录下编译出一个js文件</p>
</blockquote>
]]></content>
      <categories>
        <category>ts</category>
      </categories>
  </entry>
  <entry>
    <title>frp内网穿透</title>
    <url>/2020/04/23/%E5%B7%A5%E5%85%B7/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">frp</a>国人开发的免费开源工具</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>公网服务器 IP 140.140.192.192</p>
</li>
<li><p>域名 <a href="http://www.good.com" target="_blank" rel="noopener">www.good.com</a> 解析至上面的服务器</p>
</li>
<li><p>本地运行的服务</p>
</li>
</ul>
<a id="more"></a>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>利用<code>frp</code>，可以实现任何人都可以通过配置的端口如 <code>www.good.com:7001</code> 访问我本机的<code>hbuilder</code>网页应用</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>服务器和内网本机分别<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">下载</a>对应系统平台的frp，<br>这里ubuntu服务器需要下载linux_arm_64， mac本机是frp_0.32.1_windows_amd64.zip</p>
<ul>
<li><p>先配服务端</p>
<p>linux_arm_64文件包在服务器上下载解压，编辑 <code>frps.ini</code>， 然后启动 <code>./frps -c ./frps.ini</code>，放后台启动命令 <code>nohup ./frps -c ./frps.ini &amp;</code>，配置修改如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line"><span class="meta"># 客户端定义的端口</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置客户端</p>
<p>frp_0.32.1_windows_amd64.zip文件包解压，编辑 <code>frpc.ini</code>,然后启动 <code>./frpc -c ./frpsc.ini</code>,可以自己放在后台执行，配置如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">server_addr = <span class="number">140.140</span><span class="number">.192</span><span class="number">.192</span>   <span class="meta">#公网服务器ip</span></span><br><span class="line">server_port = <span class="number">7001</span>                       <span class="meta">#与服务端bind_port一致</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#公网访问内部web服务器以http方式</span></span><br><span class="line">[<span class="meta">web</span>]</span><br><span class="line">type = http         <span class="meta">#访问协议</span></span><br><span class="line">local_port = <span class="number">4200</span>   <span class="meta">#内网web服务的端口号</span></span><br><span class="line">custom_domains = www.good.com   <span class="meta">#所绑定的公网服务器域名，一级、二级域名都可以</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="配置服务端面板"><a href="#配置服务端面板" class="headerlink" title="配置服务端面板"></a>配置服务端面板</h4><p>修改服务端的 <code>frps.ini</code>， 添加 dashboard 信息，重启启动后可以通过<code>140.140.192.192:7500</code>打开控制面板</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">common</span>]</span><br><span class="line">bind_port = <span class="number">7000</span></span><br><span class="line"><span class="meta"># 客户端定义的端口</span></span><br><span class="line">vhost_http_port = <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">dashboard_port = <span class="number">7500</span></span><br><span class="line"><span class="meta"># dashboard 用户名密码，默认都为 admin</span></span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p> Invalid Host header</p>
</blockquote>
<p>如果本机的web项目用了webpack server(目前vue cli, react cli, angular 本地开发用的都是这个) , 这个是webpack server的安全策略，如果是angular项目，需要在启动配置中加上 <code>--disable-host-check</code> 类似 <code>ng serve --open --host $IP --port $PORT --disable-host-check</code>。</p>
<p>如果是<code>uniapp</code>项目，进行如下配置：</p>
<p><img src="/static/%E5%B7%A5%E5%85%B7/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/images/image-20200423140150925.png" alt="image-20200423140150925"></p>
<blockquote>
<p>参考文档</p>
<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md#%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81</a></p>
<p><a href="https://www.jianshu.com/p/d579c2156311" target="_blank" rel="noopener">https://www.jianshu.com/p/d579c2156311</a></p>
<p><a href="https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/" target="_blank" rel="noopener">https://www.kuke365.com/2019/09/19/uniapp%E4%B8%8Bh5%E7%AB%AF%E5%92%8Cvuejs%E4%B8%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Finvalid-host-header/</a></p>
<p><a href="https://www.it72.com/12580-1.htm" target="_blank" rel="noopener">https://www.it72.com/12580-1.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>3D前置知识</title>
    <url>/2020/04/23/3D/3D%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.场景(Scene)：是物体、光源等元素的容器，可以配合 chrome 插件使用，抛出 window.scene即可实时调整 obj 的信息和材质信息。</span><br><span class="line">2.相机（Camera）：场景中的相机，代替人眼去观察，场景中只能添加一个，一般常用的是透视相机（PerspectiveCamera）</span><br><span class="line">3.物体对象（Mesh）：包括二维物体（点、线、面）、三维物体，模型等等   </span><br><span class="line">4.光源（Light）：场景中的光照，如果不添加光照场景将会是一片漆黑，包括全局光、平行光、点光源等 </span><br><span class="line">5.渲染器（Renderer）:场景的渲染方式，如webGL\canvas2D\Css3D。 </span><br><span class="line">6.控制器(Control): 可通过键盘、鼠标控制相机的移动</span><br></pre></td></tr></table></figure>

<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>Three.js中我们常用到的又两种类型的相机：正交相机，透视相机。一般情况下为了模拟人眼我们都是使用透视相机。</p>
<p>正交镜头的特点是：物品的渲染尺寸与距离镜头的远近无关。也就是说在场景中移动一个物体，其大小不会变化。正交镜头适合2D游戏。</p>
<p>透视镜头则是模拟人眼的视觉特点，距离远的物体显得更小。透视镜头通常更适合3D渲染。</p>
<p><strong>PerspectiveCamera透视相机</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fov</td>
<td>视野角度，从镜头可以看到的场景的部分。通常3D游戏的FOV取值在60-90度之间较好的默认值为60</td>
</tr>
<tr>
<td>aspect</td>
<td>渲染区域的纵横比。较好的默认值为window.innerWidth/window.innerHeight</td>
</tr>
<tr>
<td>near</td>
<td>最近离镜头的距离</td>
</tr>
<tr>
<td>far</td>
<td>远离镜头的距离</td>
</tr>
</tbody></table>
<p><strong>透视相机示意图</strong></p>
<p><img src="/static/3D/3D%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/201809271025363f22144e-553d-4de9-af31-4ab884924e84.png" alt="img"></p>
<p>创建摄像机以后还要对其进行移动、然后对准物体积聚的场景中心位置，分别是设置其 <code>position</code>和调用 <code>lookAt</code> 方法，参数均是一个 xyz向量<code>(new THREE.Vector3(x,y,z))</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）</span><br><span class="line">camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)）</span><br></pre></td></tr></table></figure>

<h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><p>在<code>Three.js</code>中光源是必须的，如果一个场景你不设置灯光那么世界将会是一片漆黑。<code>Three.js</code>内置了多种光源以满足特定场景的需要。大家可以根据自己的项目需要来选择何种灯光</p>
<h3 id="光源分类"><a href="#光源分类" class="headerlink" title="光源分类"></a>光源分类</h3><table>
<thead>
<tr>
<th>光源</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AmbientLight</td>
<td>环境光，其颜色均匀的应用到场景及其所有对象上,这种光源为场景添加全局的环境光。 这种光没有特定的方向，不会产生阴影。通常不会把AmbientLight作为唯一的光源， 而是和SpotLight、DirectionalLight等光源结合使用，从而达到柔化阴影、添加全局色调的效果。 指定颜色时要相对保守，例如#0c0c0c。设置太亮的颜色会导致整个画面过度饱和，什么都看不清：</td>
</tr>
<tr>
<td>PointLight</td>
<td>3D空间中的一个点光源，向所有方向发出光线</td>
</tr>
<tr>
<td>SpotLight</td>
<td>产生圆锥形光柱的聚光灯，台灯、天花板射灯通常都属于这类光源,这种光源的使用场景最多 ，特别是在你需要阴影效果的时候。</td>
</tr>
<tr>
<td>DirectionalLight</td>
<td>也就无限光，光线是平行的。典型的例子是日光,用于模拟遥远的，类似太阳那样的光源。 该光源与SpotLight的主要区别是，它不会随着距离而变暗，所有被照耀的地方获得相同的光照强度。</td>
</tr>
<tr>
<td>HemisphereLight</td>
<td>特殊光源，用于创建户外自然的光线效果， 此光源模拟物体表面反光效果、微弱发光的天空,模拟穹顶（半球）的微弱发光效果， 让户外场景更加逼真。使用DirectionalLight + AmbientLight可以在某种程度上来模拟户外光线， 但是不够真实，因为无法体现大气层的散射效果、地面或物体的反射效果</td>
</tr>
<tr>
<td>AreaLight</td>
<td>面光源，指定一个发光的区域</td>
</tr>
<tr>
<td>LensFlare</td>
<td>不是光源，用于给光源添加镜头光晕效果</td>
</tr>
</tbody></table>
<p>关于光源的详细 API 大家可以参考 threejs 官网，很详细，demo 也很完整 <a href="https://threejs.org/examples/?q=light#webgl_lights_physical" target="_blank" rel="noopener">传送门</a></p>
<h2 id="Mesh-网格"><a href="#Mesh-网格" class="headerlink" title="Mesh(网格)"></a>Mesh(网格)</h2><p>在计算机的世界中，一条弧线是由有限个点构成的有限条段链接得到的。当线段数量越多，长度就越短，当达到你无法察觉这是线段时，一条平滑的弧线就出现了。计算机三位模型也是类似的。只不过是线段变成了平面，普遍用三角形组成的网格来描述。我们把这种模型称之为Mesh模型。在ThreeJs的世界中，材质（Mterial）+几何体（Geomtry） 及时一个<code>mesh</code>。设置其name属性可以通过scene.getObjectByName(name)获取改物体对象。Geomtry就好像是故交，材质则类似于皮肤，对于材质和几何体的分类见下表格：</p>
<h3 id="材质分类"><a href="#材质分类" class="headerlink" title="材质分类"></a>材质分类</h3><table>
<thead>
<tr>
<th>材质</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MeshBasicMaterial</td>
<td>基本的材质，显示为简单的颜色或者显示为线框。不考虑光线的影响</td>
</tr>
<tr>
<td>MeshDepthMaterial</td>
<td>使用简单的颜色，但是颜色深度和距离相机的远近有关</td>
</tr>
<tr>
<td>MeshNormalMaterial</td>
<td>基于面Geometry的法线（normals）数组来给面着色</td>
</tr>
<tr>
<td>MeshFacematerial</td>
<td>容器，允许为Geometry的每一个面指定一个材质</td>
</tr>
<tr>
<td>MeshLambertMaterial</td>
<td>考虑光线的影响，哑光材质</td>
</tr>
<tr>
<td>MeshPhongMaterial</td>
<td>考虑光线的影响，光泽材质</td>
</tr>
<tr>
<td>ShaderMaterial</td>
<td>允许使用自己的着色器来控制顶点如何被放置、像素如何被着色</td>
</tr>
<tr>
<td>LineBasicMaterial</td>
<td>用于THREE.Line对象，创建彩色线条</td>
</tr>
<tr>
<td>LineDashMaterial</td>
<td>用于THREE.Line对象，创建虚线条</td>
</tr>
<tr>
<td>RawShaderMaterial</td>
<td>仅和THREE.BufferedGeometry联用，优化静态Geometry（顶点、面不变）的渲染</td>
</tr>
<tr>
<td>SpriteCanvasMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
<tr>
<td>SpriteMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
<tr>
<td>PointCloudMaterial</td>
<td>在针对单独的点进行渲染时用到</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>3D</category>
      </categories>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>node创建文件</title>
    <url>/2020/04/22/node/node%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="NodeJS-10"><a href="#NodeJS-10" class="headerlink" title="NodeJS 10+"></a>NodeJS 10+</h3><blockquote>
<p>fs.mkdir已经增加递归选项</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.mkdir(&#39;&#x2F;tmp&#x2F;test&#x2F;www.inull.cn&#39;, &#123; recursive: true &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">    if (err) throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="NodeJS-9以前版本"><a href="#NodeJS-9以前版本" class="headerlink" title="NodeJS 9以前版本"></a>NodeJS 9以前版本</h3><p>同步方案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步递归创建路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;string&#125;</span> </span>dir   处理的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> </span>cb  回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> $$mkdir = <span class="function"><span class="keyword">function</span>(<span class="params">dir, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathinfo = path.parse(dir)</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(pathinfo.dir)) &#123;</span><br><span class="line">        $$mkdir(pathinfo.dir,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fs.mkdirSync(pathinfo.dir)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    cb &amp;&amp; cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$$mkdir(path.join(__dirname, <span class="string">'demo/test/123/'</span>))</span><br></pre></td></tr></table></figure>

<p>异步方案</p>
<p>暂缓</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>html5plus分享模板</title>
    <url>/2020/04/21/uniapp/html5plus%E5%88%86%E4%BA%AB%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>微信公众号的分享链接在vue，hash模式下不要带/#/，会有问题</p>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
  </entry>
  <entry>
    <title>git本地多账号配置</title>
    <url>/2020/04/20/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li><code>git环境</code></li>
</ul>
<a id="more"></a>

<h3 id="生成第一个账号的密钥"><a href="#生成第一个账号的密钥" class="headerlink" title="生成第一个账号的密钥"></a>生成第一个账号的密钥</h3><p>先确保你已经有多个git账号（如：一个github的账号、一个码云的账号、…）。</p>
<p>在Git Bash Here的控制台里输入：</p>
<p><code>git config --global user.name &quot;你的名称&quot;</code></p>
<p><code>git config --global user.email &quot;你的邮箱&quot;</code></p>
<p>这里的邮箱是你申请git账号时的邮箱，不报错就是正确的，继续往下走</p>
<p>输入 <code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>  回车，再连续3次回车见下图：</p>
<p>此时看下图中有一行提示：<code>Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub</code></p>
<p>到该路径（<code>C/Users/xxx/.ssh</code>）可以看见两个文件：id_rsa、id_rsa.pub 。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110415002.png" alt="image-20200420110415002"></p>
<p>把密钥添加进git账号中：</p>
<p>用编辑器打开<code>id_rsa.pub</code>，推荐使用Notepad++，不要使用记事本打开，因为记事本的默认编码不是utf-8，拷贝里面的全部内容，登录你其中一个git 账号，例如:我登录github平台，后添加公钥里把它添加进去，公钥名称可以随便写。提交保存，输入你的github登录密码并提示添加成功。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110453118.png" alt="image-20200420110453118"></p>
<p>测试刚才添加的github密钥是否成功：</p>
<p>在Git Bash Here中输入 ssh <a href="mailto:git@github.com">git@github.com</a>  回车</p>
<p>会出现一个提示，输入 yes 回车，可以看见一个successfully的提示信息，说明添加成功，可以使用了。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110505960.png" alt="image-20200420110505960"></p>
<h3 id="生成第二个账号的密钥"><a href="#生成第二个账号的密钥" class="headerlink" title="生成第二个账号的密钥"></a>生成第二个账号的密钥</h3><p>重复上面的步骤，那用户名和邮箱改成另一个账号的</p>
<blockquote>
<p>注：在输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>的第一个选择存储路径的时候请自行改成自己的自定义名字，例如输入：smalldemons，这个时候一般是在<code>C/Users/xxx/.ssh</code>目录下就会又增加两个文件：smalldemons、smalldemons.pub,如果没看到的话，一般是在命令行打开的当前目录下，把这两个文件复制过去就行了</p>
</blockquote>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110803461.png" alt="image-20200420110803461"></p>
<p>添加多账号配置文件config（<code>C/Users/xxx/.ssh</code>）：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420110903542.png" alt="image-20200420110903542"></p>
<p>里面的代码 如下：</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111043623.png" alt="image-20200420111043623"></p>
<blockquote>
<p>Host 配置的别名</p>
<p>HostName  填写改git账号的官网地址</p>
<p>IdentityFile：是对应的密钥文件</p>
<p>如此就可以在多个账号间切换使用了</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这样的话只能使用<code>git@github.com:xxxx/xxxx.git</code>的方式拉取或推送代码，另一种我试的是失效的，得再看一下。</p>
<p><img src="/static/git/git%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/images/image-20200420111258450.png" alt="image-20200420111258450"></p>
<p>切换<code>npmrun</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line">git@npmrun.github.com:npmrun&#x2F;npmrun.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@npmrun.github.com,我加了npmrun,对应的是config里面的Host</span><br></pre></td></tr></table></figure>

<p>切换<code>1549469775</code>账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的名称&quot; </span><br><span class="line">git config --global user.email &quot;你的邮箱&quot; </span><br><span class="line">git@1549469775.github.com:npmrun&#x2F;1549469775.github.io.git</span><br><span class="line">&#x2F;&#x2F; 注意前面的 git@1549469775.github.com,我加了1549469775,对应的是config里面的Host</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>eggJS路由</title>
    <url>/2020/04/19/eggjs/eggJS%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h1><p>Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 <code>app/router.js</code> 文件用于统一所有路由规则。</p>
<p>通过统一的配置，我们可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。</p>
<a id="more"></a>

<h2 id="如何定义-Router"><a href="#如何定义-Router" class="headerlink" title="如何定义 Router"></a>如何定义 Router</h2><ul>
<li><p><code>app/router.js</code> 里面定义 URL 路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>app/controller</code> 目录下面实现 Controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">class UserController extends Controller &#123;</span><br><span class="line">  async info() &#123;</span><br><span class="line">    const &#123; ctx &#125; &#x3D; this;</span><br><span class="line">    ctx.body &#x3D; &#123;</span><br><span class="line">      name: &#96;hello $&#123;ctx.params.id&#125;&#96;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样就完成了一个最简单的 Router 定义，当用户执行 <code>GET /user/123</code>，<code>user.js</code> 这个里面的 info 方法就会执行。</p>
<h2 id="Router-详细定义说明"><a href="#Router-详细定义说明" class="headerlink" title="Router 详细定义说明"></a>Router 详细定义说明</h2><p>下面是路由的完整定义，参数可以根据场景的不同，自由选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.verb(&#39;path-match&#39;, app.controller.action);</span><br><span class="line">router.verb(&#39;router-name&#39;, &#39;path-match&#39;, app.controller.action);</span><br><span class="line">router.verb(&#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action);</span><br><span class="line">router.verb(&#39;router-name&#39;, &#39;path-match&#39;, middleware1, ..., middlewareN, app.controller.action);</span><br></pre></td></tr></table></figure>

<p>路由完整定义主要包括5个主要部分:</p>
<ul>
<li><p>verb - 用户触发动作，支持 get，post 等所有 HTTP 方法，后面会通过示例详细说明。</p>
<ul>
<li>router.head - HEAD</li>
<li>router.options - OPTIONS</li>
<li>router.get - GET</li>
<li>router.put - PUT</li>
<li>router.post - POST</li>
<li>router.patch - PATCH</li>
<li>router.delete - DELETE</li>
<li>router.del - 由于 delete 是一个保留字，所以提供了一个 delete 方法的别名。</li>
<li>router.redirect - 可以对 URL 进行重定向处理，比如我们最经常使用的可以把用户访问的根目录路由到某个主页。</li>
</ul>
<p>router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 <code>pathFor</code> 和 <code>urlFor</code> 来生成 URL。(可选)</p>
</li>
<li><p>router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 <code>pathFor</code> 和 <code>urlFor</code> 来生成 URL。(可选)</p>
</li>
<li><p>path-match - 路由 URL 路径。</p>
</li>
<li><p>middleware1 - 在 Router 里面可以配置多个 Middleware。(可选)</p>
</li>
<li><p>controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法：</p>
<ul>
<li><code>app.controller.user.fetch</code> - 直接指定一个具体的 controller</li>
<li><code>&#39;user.fetch&#39;</code> - 可以简写为字符串形式</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在 Router 定义中， 可以支持多个 Middleware 串联执行</li>
<li>Controller 必须定义在 <code>app/controller</code> 目录中。</li>
<li>一个文件里面也可以包含多个 Controller 定义，在定义路由的时候，可以通过 <code>${fileName}.${functionName}</code> 的方式指定对应的 Controller。</li>
<li>Controller 支持子目录，在定义路由的时候，可以通过 <code>${directoryName}.${fileName}.${functionName}</code> 的方式制定对应的 Controller。</li>
</ul>
<p>下面是一些路由定义的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;home&#39;, controller.home);</span><br><span class="line">  router.get(&#39;&#x2F;user&#x2F;:id&#39;, controller.user.page);</span><br><span class="line">  router.post(&#39;&#x2F;admin&#39;, isAdmin, controller.admin);</span><br><span class="line">  router.post(&#39;&#x2F;user&#39;, isLoginUser, hasAdminPermission, controller.user.create);</span><br><span class="line">  router.post(&#39;&#x2F;api&#x2F;v1&#x2F;comments&#39;, controller.v1.comments.create); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;comments.js</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="RESTful-风格的-URL-定义"><a href="#RESTful-风格的-URL-定义" class="headerlink" title="RESTful 风格的 URL 定义"></a>RESTful 风格的 URL 定义</h3><p>如果想通过 RESTful 的方式来定义路由， 我们提供了 <code>app.router.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller)</code> 快速在一个路径上生成 <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank" rel="noopener">CRUD</a> 路由结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.resources(&#39;posts&#39;, &#39;&#x2F;api&#x2F;posts&#39;, controller.posts);</span><br><span class="line">  router.resources(&#39;users&#39;, &#39;&#x2F;api&#x2F;v1&#x2F;users&#39;, controller.v1.users); &#x2F;&#x2F; app&#x2F;controller&#x2F;v1&#x2F;users.js</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码就在 <code>/posts</code> 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 <code>app/controller/posts.js</code> 接下来， 你只需要在 <code>posts.js</code> 里面实现对应的函数就可以了。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Path</th>
<th>Route Name</th>
<th>Controller.Action</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.index</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/new</td>
<td>new_post</td>
<td>app.controllers.posts.new</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.show</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id/edit</td>
<td>edit_post</td>
<td>app.controllers.posts.edit</td>
</tr>
<tr>
<td>POST</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.create</td>
</tr>
<tr>
<td>PUT</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.update</td>
</tr>
<tr>
<td>DELETE</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.destroy</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;posts.js</span><br><span class="line">exports.index &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.new &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.create &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.show &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.edit &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.update &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.destroy &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们不需要其中的某几个方法，可以不用在 <code>posts.js</code> 里面实现，这样对应 URL 路径也不会注册到 Router。</p>
<h2 id="router-实战"><a href="#router-实战" class="headerlink" title="router 实战"></a>router 实战</h2><p>下面通过更多实际的例子，来说明 router 的用法。</p>
<h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><h4 id="Query-String-方式"><a href="#Query-String-方式" class="headerlink" title="Query String 方式"></a>Query String 方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;search?name&#x3D;egg</span><br></pre></td></tr></table></figure>

<h4 id="参数命名方式"><a href="#参数命名方式" class="headerlink" title="参数命名方式"></a>参数命名方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;user&#x2F;:id&#x2F;:name&#39;, app.controller.user.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">exports.info &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;user: $&#123;ctx.params.id&#125;, $&#123;ctx.params.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user&#x2F;123&#x2F;xiaoming</span><br></pre></td></tr></table></figure>

<h4 id="复杂参数的获取"><a href="#复杂参数的获取" class="headerlink" title="复杂参数的获取"></a>复杂参数的获取</h4><p>路由里面也支持定义正则，可以更加灵活的获取参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#x2F;^\&#x2F;package\&#x2F;([\w-.]+\&#x2F;[\w-.]+)$&#x2F;, app.controller.package.detail);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;package.js</span><br><span class="line">exports.detail &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果请求 URL 被正则匹配， 可以按照捕获分组的顺序，从 ctx.params 中获取。</span><br><span class="line">  &#x2F;&#x2F; 按照下面的用户请求，&#96;ctx.params[0]&#96; 的 内容就是 &#96;egg&#x2F;1.0.0&#96;</span><br><span class="line">  ctx.body &#x3D; &#96;package:$&#123;ctx.params[0]&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;package&#x2F;egg&#x2F;1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="表单内容的获取"><a href="#表单内容的获取" class="headerlink" title="表单内容的获取"></a>表单内容的获取</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.post(&#39;&#x2F;form&#39;, app.controller.form.post);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;form.js</span><br><span class="line">exports.post &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;body: $&#123;JSON.stringify(ctx.request.body)&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟发起 post 请求。</span><br><span class="line">&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;form --data &#39;&#123;&quot;name&quot;:&quot;controller&quot;&#125;&#39; --header &#39;Content-Type:application&#x2F;json&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：</p>
</blockquote>
<blockquote>
<p>这里直接发起 POST 请求会<strong>报错</strong>：’secret is missing’。错误信息来自 <a href="https://github.com/koajs/csrf/blob/2.5.0/index.js#L69" target="_blank" rel="noopener">koa-csrf/index.js#L69</a> 。</p>
</blockquote>
<blockquote>
<p><strong>原因</strong>：框架内部针对表单 POST 请求均会验证 CSRF 的值，因此我们在表单提交时，请带上 CSRF key 进行提交，可参考<a href="https://eggjs.org/zh-cn/core/security.html#安全威胁csrf的防范" target="_blank" rel="noopener">安全威胁csrf的防范</a></p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：上面的校验是因为框架中内置了安全插件 <a href="https://github.com/eggjs/egg-security" target="_blank" rel="noopener">egg-security</a>，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可。</p>
</blockquote>
<blockquote>
<p>「除非清楚的确认后果，否则不建议擅自关闭安全插件提供的功能。」</p>
</blockquote>
<blockquote>
<p>这里在写例子的话可临时在 <code>config/config.default.js</code> 中设置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.security &#x3D; &#123;</span><br><span class="line">  csrf: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.post(&#39;&#x2F;user&#39;, app.controller.user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js</span><br><span class="line">const createRule &#x3D; &#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: &#39;email&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: &#39;password&#39;,</span><br><span class="line">    compare: &#39;re-password&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.create &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果校验报错，会抛出异常</span><br><span class="line">  ctx.validate(createRule);</span><br><span class="line">  ctx.body &#x3D; ctx.request.body;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;user --data &#39;username&#x3D;abc@abc.com&amp;password&#x3D;111111&amp;re-password&#x3D;111111&#39;</span><br></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;index&#39;, &#39;&#x2F;home&#x2F;index&#39;, app.controller.home.index);</span><br><span class="line">  app.router.redirect(&#39;&#x2F;&#39;, &#39;&#x2F;home&#x2F;index&#39;, 302);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;home.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;hello controller&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl -L http:&#x2F;&#x2F;localhost:7001</span><br></pre></td></tr></table></figure>

<h4 id="外部重定向"><a href="#外部重定向" class="headerlink" title="外部重定向"></a>外部重定向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;search&#39;, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  const type &#x3D; ctx.query.type;</span><br><span class="line">  const q &#x3D; ctx.query.q || &#39;nodejs&#39;;</span><br><span class="line"></span><br><span class="line">  if (type &#x3D;&#x3D;&#x3D; &#39;bing&#39;) &#123;</span><br><span class="line">    ctx.redirect(&#96;http:&#x2F;&#x2F;cn.bing.com&#x2F;search?q&#x3D;$&#123;q&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ctx.redirect(&#96;https:&#x2F;&#x2F;www.google.co.kr&#x2F;search?q&#x3D;$&#123;q&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?type&#x3D;bing&amp;q&#x3D;node.js</span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?q&#x3D;node.js</span><br></pre></td></tr></table></figure>

<h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><p>如果我们想把用户某一类请求的参数都大写，可以通过中间件来实现。 这里我们只是简单说明下如何使用中间件，更多请查看 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">中间件</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;search.js</span><br><span class="line">exports.index &#x3D; async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#96;search: $&#123;ctx.query.name&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;middleware&#x2F;uppercase.js</span><br><span class="line">module.exports &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return async function uppercase(ctx, next) &#123;</span><br><span class="line">    ctx.query.name &#x3D; ctx.query.name &amp;&amp; ctx.query.name.toUpperCase();</span><br><span class="line">    await next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;s&#39;, &#39;&#x2F;search&#39;, app.middleware.uppercase(), app.controller.search)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; curl http:&#x2F;&#x2F;localhost:7001&#x2F;search?name&#x3D;egg</span><br></pre></td></tr></table></figure>

<h3 id="太多路由映射？"><a href="#太多路由映射？" class="headerlink" title="太多路由映射？"></a>太多路由映射？</h3><p>如上所述，我们并不建议把路由规则逻辑散落在多个地方，会给排查问题带来困扰。</p>
<p>若确实有需求，可以如下拆分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  require(&#39;.&#x2F;router&#x2F;news&#39;)(app);</span><br><span class="line">  require(&#39;.&#x2F;router&#x2F;admin&#39;)(app);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router&#x2F;news.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;news&#x2F;list&#39;, app.controller.news.list);</span><br><span class="line">  app.router.get(&#39;&#x2F;news&#x2F;detail&#39;, app.controller.news.detail);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router&#x2F;admin.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  app.router.get(&#39;&#x2F;admin&#x2F;user&#39;, app.controller.admin.user);</span><br><span class="line">  app.router.get(&#39;&#x2F;admin&#x2F;log&#39;, app.controller.admin.log);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可直接使用 <a href="https://github.com/eggjs/egg-router-plus" target="_blank" rel="noopener">egg-router-plus</a>。</p>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>hexo在github上的自动化部署</title>
    <url>/2020/04/17/hexo/hexo%E5%9C%A8github%E4%B8%8A%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>这几天被GithubActions和git-lfs坑的不轻啊，在使用Actions进行自动化部署的时候，我用的百度出来的那个Actions部署库，由于不支持lfs的功能，一直就失败。经过多次尝试，我终于找到了一个能够用的库了。谢天谢地，不然真得抑郁死。</p>
</blockquote>
<a id="more"></a>

<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>我是添加了对仓库的<code>git-lfs</code>的支持，使得能够存储大文件，而且<code>.git</code>文件也会小很多。</p>
<p><code>git lfs track &quot;*.zip&quot;</code>,执行这个命令之后提交的<code>zip</code>文件才会被记录。</p>
<h3 id="原有Actions"><a href="#原有Actions" class="headerlink" title="原有Actions"></a>原有<code>Actions</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: GitHub Actions Build and Deploy Hexo</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - source</span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@master</span><br><span class="line">      with:</span><br><span class="line">        ref: source</span><br><span class="line">        lfs: true</span><br><span class="line">    - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br><span class="line">      run: |</span><br><span class="line">        npm install</span><br><span class="line">        npx gulp clean</span><br><span class="line">        npx gulp</span><br><span class="line">        npx hexo clean</span><br><span class="line">        npx hexo generate</span><br><span class="line">    - name: Build and Deploy</span><br><span class="line">      uses: JamesIves&#x2F;github-pages-deploy-action@master</span><br><span class="line">      env:</span><br><span class="line">        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">        BASE_BRANCH: source</span><br><span class="line">        BRANCH: master</span><br><span class="line">        FOLDER: public</span><br></pre></td></tr></table></figure>

<p>上面的<code>JamesIves/github-pages-deploy-action@master</code>根本不支持<code>lfs</code></p>
<p>，结果我傻傻的搞了差不多一天。</p>
<h3 id="改变之后的Action"><a href="#改变之后的Action" class="headerlink" title="改变之后的Action"></a>改变之后的<code>Action</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: GitHub Actions Build and Deploy Hexo</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - source</span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions&#x2F;checkout@master</span><br><span class="line">      with:</span><br><span class="line">        submodules: true</span><br><span class="line">        lfs: true</span><br><span class="line">    - name: Install and BuildA 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br><span class="line">      run: |</span><br><span class="line">        npm install</span><br><span class="line">        npx gulp clean</span><br><span class="line">        npx gulp</span><br><span class="line">        npx hexo clean</span><br><span class="line">        npx hexo generate</span><br><span class="line">    - name: Deploy</span><br><span class="line">      uses: alex-page&#x2F;blazing-fast-gh-pages-deploy@v1.1.0</span><br><span class="line">      with:</span><br><span class="line">        repo-token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">        site-directory: .&#x2F;public</span><br><span class="line">        commit-message: fuck</span><br><span class="line">        deploy-branch: master</span><br></pre></td></tr></table></figure>

<p>Fuck,齐活！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>常用效果框架</title>
    <url>/2020/04/16/%E5%89%8D%E7%AB%AF/%E5%B8%B8%E7%94%A8%E6%95%88%E6%9E%9C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="通用框架"><a href="#通用框架" class="headerlink" title="通用框架"></a>通用框架</h3><ul>
<li><p>轮播框架</p>
<p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">Swiper</a>(老牌又强大)</p>
</li>
<li><p>图表</p>
<p><a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">EChart</a></p>
</li>
<li><p>效果</p>
<p><a href="http://www.clipboardjs.cn/" target="_blank" rel="noopener">复制文本</a></p>
</li>
<li><p>全屏滚动插件</p>
<p><a href="https://www.dowebok.com/demo/2014/77/" target="_blank" rel="noopener">FullPage.js</a></p>
</li>
</ul>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><ul>
<li><p>列表滑动</p>
<p><a href="http://www.mescroll.com/reward.html?v=20200315" target="_blank" rel="noopener">mescroll</a></p>
</li>
<li><p>高性能虚拟滑动</p>
<p><a href="https://www.npmjs.com/package/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>如何给git仓库瘦身,删除大文件</title>
    <url>/2020/04/16/git/%E5%A6%82%E4%BD%95%E7%BB%99git%E4%BB%93%E5%BA%93%E7%98%A6%E8%BA%AB,%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://blog.mallol.cn/2015/8d45392.html" target="_blank" rel="noopener">http://blog.mallol.cn/2015/8d45392.html</a></p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><code>git</code>用久后,或者<code>.gitignore</code>设置不好,没有忽略掉大文件(比如:<code>zip,sql,deb,tar.gz…</code>等二进制文件)。会把git库撑的很大,有几个G。这些大文件有些是没必要放进来的,需要删除掉.下面有解决办法:</p>
<a id="more"></a>

<p>进入项目根目录下面(确保是最新文件)。这个git库有6.4G.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ cd project</span><br></pre></td></tr></table></figure>

<p>从所有提交(commit)中删除所有的zip文件(*.zip.其他的请自行修正).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ git filter-branch --force --index-filter \</span><br><span class="line">&#39;git rm --cached --ignore-unmatch *.zip&#39; \</span><br><span class="line">--prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，会删除磁盘上的文件，请注意备份</p>
</blockquote>
<p><code>Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (266/266)</code></p>
<p><code>Ref ‘refs/heads/master’ was rewritten</code></p>
<p>清除快取和回收空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ rm -rf .git&#x2F;refs&#x2F;original&#x2F; </span><br><span class="line">$ git reflog expire --expire&#x3D;now --all</span><br><span class="line">$ git gc --prune&#x3D;now</span><br><span class="line">$ git gc --aggressive --prune&#x3D;now</span><br></pre></td></tr></table></figure>

<p>强制覆盖并上传到 remote repository。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ git push origin master --force</span><br></pre></td></tr></table></figure>

<p>打完收工！现在就可以看到瘦身的效果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ jonny@wheezy ~ ]</span><br><span class="line">$ du .git -lsh </span><br><span class="line">126M .</span><br></pre></td></tr></table></figure>

<p><code>du -d 1 -h</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><code>fatal :bad revision &#39;rm&#39;</code>: 这个命令是使用<strong>双引号</strong>，而不是单引号。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>gitfls大文件</title>
    <url>/2020/04/16/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>作者：amosbake<br>链接：<a href="https://www.jianshu.com/p/493b81544f80" target="_blank" rel="noopener">https://www.jianshu.com/p/493b81544f80</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<a id="more"></a>

<p>Git LFS 是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-670f795346b86292.webp" alt="img"></p>
<h3 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h3><p>在游戏开发过程中,设计资源占用了很大一部分空间. 像png,psd等文件是二进制(blob)的,体积也很庞大.<br> 但git的diff/patch等是基于文件行的.对于二进制文件来说. git需要存储每次commit的改动.<br> 每次当二进制文件修改,发生变化的时候. 都会产生额外的提交量.导致clone和pull的数据量大增.在线仓库的体积也会迅速增长.</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-c9ddfd907277e8df.webp" alt="img"></p>
<p>LFS(Large File Storage) 就是为了解决这一问题而产生的工具.</p>
<p>它将你所标记的大文件保存至另外的仓库,而在主仓库仅保留其轻量级指针.</p>
<p>那么在你检出版本时,根据指针的变化情况下更新对应的大文件.而不是在本地保存所有版本的大文件</p>
<p><img src="/static/git/gitfls%E5%A4%A7%E6%96%87%E4%BB%B6/images/1059995-7e78b1cc5ceb6c1f.webp" alt="img"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5</p>
</blockquote>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><em>Linux</em></h4><ol>
<li><p><code>curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</code></p>
</li>
<li><p><code>sudo apt-get install git-lfs</code></p>
</li>
<li><p><code>git lfs install</code></p>
</li>
</ol>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><em>Mac</em></h4><ol>
<li>安装HomeBrew <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li><code>brew install git-lfs</code></li>
<li><code>git lfs install</code></li>
</ol>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h4><ol>
<li>下载安装 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fgithub%2Fgit-lfs%2Freleases" target="_blank" rel="noopener">windows installer</a></li>
<li>运行 windows installer</li>
<li>在命令行执行 <code>git lfs install</code></li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>执行 <code>git lfs install</code> 开启lfs功能</p>
</li>
<li><p>使用 <code>git lfs track</code> 命令进行大文件追踪 例如<code>git lfs track &quot;*.png&quot;</code> 追踪所有后缀为png的文件</p>
</li>
<li><p>使用 <code>git lfs track</code> 查看现有的文件追踪模式</p>
</li>
<li><p>提交代码需要将<code>gitattributes</code>文件提交至仓库. 它保存了文件的追踪记录</p>
</li>
<li><p>提交后运行<code>git lfs ls-files</code> 可以显示当前跟踪的文件列表</p>
</li>
<li><p>将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示:</p>
</li>
<li><p>clone 时 使用’git clone’ 或 <code>git lfs clone</code>均可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>eggjs错误搜集</title>
    <url>/2020/04/15/eggjs/eggjs%E9%94%99%E8%AF%AF%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by serv</p>
<p><a href="https://blog.csdn.net/weixin_36222137/article/details/81293332" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36222137/article/details/81293332</a></p>
</blockquote>
<a id="more"></a>]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>v2rayn的使用方式</title>
    <url>/2020/04/15/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="/static/v2ray/v2rayn的使用方式/files/v2rayN.zip">v2rayN</a></p>
<p><a href="/static/v2ray/v2rayn的使用方式/files/v2ray-windows-64.zip">v2ray-windows-64</a></p>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压上面两个文件，得到</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145453557.png" alt="image-20200415145453557"></p>
<p>接下来把<code>v2ray-window-64</code>的所有文件全都复制到v2rayN的目录下就行了</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145543025.png" alt="image-20200415145543025"></p>
<p>移动后：</p>
<p><img src="/static/v2ray/v2rayn%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200415145559168.png" alt="image-20200415145559168"></p>
<p>然后百度使用教程就行了</p>
]]></content>
      <categories>
        <category>v2ray</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020/04/15/mysql/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>下载安装文件:<a href="http://cloud.poorman.top/index.php?share/folder&user=1&sid=ivbmXp3E" target="_blank" rel="noopener">MySQL</a></p>
<p><a href="https://blog.csdn.net/CWH0908/article/details/82959511" target="_blank" rel="noopener">https://blog.csdn.net/CWH0908/article/details/82959511</a></p>
</blockquote>
<p>我的服务名称为<code>MySQL80</code></p>
<p>管理员启动：<code>net start MySQL80</code></p>
<p>停止：<code>net start MySQL80</code></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>eggjs目录结构</title>
    <url>/2020/04/15/eggjs/eggjs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>在<a href="https://eggjs.org/zh-cn/intro/quickstart.html" target="_blank" rel="noopener">快速入门</a>中，大家对框架应该有了初步的印象，接下来我们简单了解下目录约定规范。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure>

<p>如上，由框架约定的目录：</p>
<ul>
<li><p><code>app/router.js</code> 用于配置 URL 路由规则，具体参见 <a href="https://eggjs.org/zh-cn/basics/router.html" target="_blank" rel="noopener">Router</a>。</p>
</li>
<li><p><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果，具体参见 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a>。</p>
</li>
<li><p><code>app/service/**</code> 用于编写业务逻辑层，可选，建议使用，具体参见 <a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="noopener">Service</a>。</p>
</li>
<li><p><code>app/middleware/**</code> 用于编写中间件，可选，具体参见 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">Middleware</a>。</p>
</li>
<li><p><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</p>
</li>
<li><p><code>app/extend/**</code> 用于框架的扩展，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" target="_blank" rel="noopener">框架扩展</a>。</p>
</li>
<li><p><code>config/config.{env}.js</code> 用于编写配置文件，具体参见<a href="https://eggjs.org/zh-cn/basics/config.html" target="_blank" rel="noopener">配置</a>。</p>
</li>
<li><p><code>config/plugin.js</code> 用于配置需要加载的插件，具体参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" target="_blank" rel="noopener">插件</a>。</p>
</li>
<li><p><code>test/**</code> 用于单元测试，具体参见<a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</p>
</li>
<li><p><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/app-start.html" target="_blank" rel="noopener">启动自定义</a>。关于<code>agent.js</code>的作用参见<a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html#agent-机制" target="_blank" rel="noopener">Agent机制</a>。</p>
</li>
</ul>
<p>由内置插件约定的目录：</p>
<ul>
<li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</li>
<li><code>app/schedule/**</code> 用于定时任务，可选，具体参见<a href="https://eggjs.org/zh-cn/basics/schedule.html" target="_blank" rel="noopener">定时任务</a>。</li>
</ul>
<p><strong>若需自定义自己的目录规范，参见 <a href="https://eggjs.org/zh-cn/advanced/loader.html" target="_blank" rel="noopener">Loader API</a></strong></p>
<ul>
<li><code>app/view/**</code> 用于放置模板文件，可选，由模板插件约定，具体参见<a href="https://eggjs.org/zh-cn/core/view.html" target="_blank" rel="noopener">模板渲染</a>。</li>
<li><code>app/model/**</code> 用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" target="_blank" rel="noopener">egg-sequelize</a>。</li>
</ul>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>egg.js官方手动搭建</title>
    <url>/2020/04/14/eggjs/egg.js%E5%AE%98%E6%96%B9%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>先按以下步骤一步步初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir egg-example</span><br><span class="line">$ cd egg-example</span><br><span class="line">$ npm init</span><br><span class="line">$ npm i egg --save</span><br><span class="line">$ npm i egg-bin --save-dev</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>添加 <code>npm scripts</code> 到 <code>package.json</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;egg-example&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;egg-bin dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-Controller"><a href="#编写-Controller" class="headerlink" title="编写 Controller"></a>编写 Controller</h3><p>如果你熟悉 Web 开发或 MVC，肯定猜到我们第一步需要编写的是 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a> 和 <a href="https://eggjs.org/zh-cn/basics/router.html" target="_blank" rel="noopener">Router</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;home.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class HomeController extends Controller &#123;</span><br><span class="line">  async index() &#123;</span><br><span class="line">    this.ctx.body &#x3D; &#39;Hello world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; HomeController;</span><br></pre></td></tr></table></figure>

<p>配置路由映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, controller.home.index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加一个<a href="https://eggjs.org/zh-cn/basics/config.html" target="_blank" rel="noopener">配置文件</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;;</span><br></pre></td></tr></table></figure>

<p>此时目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-example</span><br><span class="line">├── app</span><br><span class="line">│   ├── controller</span><br><span class="line">│   │   └── home.js</span><br><span class="line">│   └── router.js</span><br><span class="line">├── config</span><br><span class="line">│   └── config.default.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>完整的目录结构规范参见<a href="https://eggjs.org/zh-cn/basics/structure.html" target="_blank" rel="noopener">目录结构</a>。</p>
<p>好，现在可以启动应用来体验下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm run dev</span><br><span class="line">$ open http:&#x2F;&#x2F;localhost:7001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>Controller 有 <code>class</code> 和 <code>exports</code> 两种编写方式，本文示范的是前者，你可能需要参考 <a href="https://eggjs.org/zh-cn/basics/controller.html" target="_blank" rel="noopener">Controller</a> 文档。</li>
<li>Config 也有 <code>module.exports</code> 和 <code>exports</code> 的写法，具体参考 <a href="https://nodejs.org/api/modules.html#modules_exports_shortcut" target="_blank" rel="noopener">Node.js modules 文档</a>。</li>
</ul>
</blockquote>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>Egg 内置了 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">static</a> 插件，线上环境建议部署到 CDN，无需该插件。</p>
<p>static 插件默认映射 <code>/public/* -&gt; app/public/*</code> 目录</p>
<p>此处，我们把静态资源都放到 <code>app/public</code> 目录即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app&#x2F;public</span><br><span class="line">├── css</span><br><span class="line">│   └── news.css</span><br><span class="line">└── js</span><br><span class="line">    ├── lib.js</span><br><span class="line">    └── news.js</span><br></pre></td></tr></table></figure>

<h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><p>绝大多数情况，我们都需要读取数据后渲染模板，然后呈现给用户。故我们需要引入对应的模板引擎。</p>
<p>框架并不强制你使用某种模板引擎，只是约定了 <a href="https://eggjs.org/zh-cn/advanced/view-plugin.html" target="_blank" rel="noopener">View 插件开发规范</a>，开发者可以引入不同的插件来实现差异化定制。</p>
<p>更多用法参见 <a href="https://eggjs.org/zh-cn/core/view.html" target="_blank" rel="noopener">View</a>。</p>
<p>在本例中，我们使用 <a href="https://mozilla.github.io/nunjucks/" target="_blank" rel="noopener">Nunjucks</a> 来渲染，先安装对应的插件 <a href="https://github.com/eggjs/egg-view-nunjucks" target="_blank" rel="noopener">egg-view-nunjucks</a> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i egg-view-nunjucks --save</span><br></pre></td></tr></table></figure>

<p>开启插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;plugin.js</span><br><span class="line">exports.nunjucks &#x3D; &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &#39;egg-view-nunjucks&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.keys &#x3D; &lt;此处改为你自己的 Cookie 安全字符串&gt;;</span><br><span class="line">&#x2F;&#x2F; 添加 view 配置</span><br><span class="line">exports.view &#x3D; &#123;</span><br><span class="line">  defaultViewEngine: &#39;nunjucks&#39;,</span><br><span class="line">  mapping: &#123;</span><br><span class="line">    &#39;.tpl&#39;: &#39;nunjucks&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：是 <code>config</code> 目录，不是 <code>app/config</code>!</strong></p>
<p>为列表页编写模板文件，一般放置在 <code>app/view</code> 目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hacker News&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;public&#x2F;css&#x2F;news.css&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;news-view view&quot;&gt;</span><br><span class="line">      &#123;% for item in list %&#125;</span><br><span class="line">        &lt;li class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">          &lt;a href&#x3D;&quot;&#123;&#123; item.url &#125;&#125;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>添加 Controller 和 Router</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;news.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class NewsController extends Controller &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const dataList &#x3D; &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123; id: 1, title: &#39;this is news 1&#39;, url: &#39;&#x2F;news&#x2F;1&#39; &#125;,</span><br><span class="line">        &#123; id: 2, title: &#39;this is news 2&#39;, url: &#39;&#x2F;news&#x2F;2&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    await this.ctx.render(&#39;news&#x2F;list.tpl&#39;, dataList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsController;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;router.js</span><br><span class="line">module.exports &#x3D; app &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; &#x3D; app;</span><br><span class="line">  router.get(&#39;&#x2F;&#39;, controller.home.index);</span><br><span class="line">  router.get(&#39;&#x2F;news&#39;, controller.news.list);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>启动浏览器，访问 <a href="http://localhost:7001/news" target="_blank" rel="noopener">http://localhost:7001/news</a> 即可看到渲染后的页面。</p>
<p><strong>提示：开发期默认开启了 <a href="https://github.com/eggjs/egg-development" target="_blank" rel="noopener">development</a> 插件，修改后端代码后，会自动重启 Worker 进程。</strong></p>
<h3 id="编写-service"><a href="#编写-service" class="headerlink" title="编写 service"></a>编写 service</h3><p>在实际应用中，Controller 一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层 <a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="noopener">Service</a>。</p>
<p>我们来添加一个 Service 抓取 <a href="https://github.com/HackerNews/API" target="_blank" rel="noopener">Hacker News</a> 的数据 ，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;service&#x2F;news.js</span><br><span class="line">const Service &#x3D; require(&#39;egg&#39;).Service;</span><br><span class="line"></span><br><span class="line">class NewsService extends Service &#123;</span><br><span class="line">  async list(page &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; read config</span><br><span class="line">    const &#123; serverUrl, pageSize &#125; &#x3D; this.config.news;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use build-in http client to GET hacker-news api</span><br><span class="line">    const &#123; data: idList &#125; &#x3D; await this.ctx.curl(&#96;$&#123;serverUrl&#125;&#x2F;topstories.json&#96;, &#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        orderBy: &#39;&quot;$key&quot;&#39;,</span><br><span class="line">        startAt: &#96;&quot;$&#123;pageSize * (page - 1)&#125;&quot;&#96;,</span><br><span class="line">        endAt: &#96;&quot;$&#123;pageSize * page - 1&#125;&quot;&#96;,</span><br><span class="line">      &#125;,</span><br><span class="line">      dataType: &#39;json&#39;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; parallel GET detail</span><br><span class="line">    const newsList &#x3D; await Promise.all(</span><br><span class="line">      Object.keys(idList).map(key &#x3D;&gt; &#123;</span><br><span class="line">        const url &#x3D; &#96;$&#123;serverUrl&#125;&#x2F;item&#x2F;$&#123;idList[key]&#125;.json&#96;;</span><br><span class="line">        return this.ctx.curl(url, &#123; dataType: &#39;json&#39; &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    return newsList.map(res &#x3D;&gt; res.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsService;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>框架提供了内置的 <a href="https://eggjs.org/zh-cn/core/httpclient.html" target="_blank" rel="noopener">HttpClient</a> 来方便开发者使用 HTTP 请求。</p>
</blockquote>
<p>然后稍微修改下之前的 Controller：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;controller&#x2F;news.js</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line"></span><br><span class="line">class NewsController extends Controller &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const ctx &#x3D; this.ctx;</span><br><span class="line">    const page &#x3D; ctx.query.page || 1;</span><br><span class="line">    const newsList &#x3D; await ctx.service.news.list(page);</span><br><span class="line">    await ctx.render(&#39;news&#x2F;list.tpl&#39;, &#123; list: newsList &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; NewsController;</span><br></pre></td></tr></table></figure>

<p>还需增加 <code>app/service/news.js</code> 中读取到的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">&#x2F;&#x2F; 添加 news 的配置项</span><br><span class="line">exports.news &#x3D; &#123;</span><br><span class="line">  pageSize: 5,</span><br><span class="line">  serverUrl: &#39;https:&#x2F;&#x2F;hacker-news.firebaseio.com&#x2F;v0&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="编写扩展"><a href="#编写扩展" class="headerlink" title="编写扩展"></a>编写扩展</h3><p>遇到一个小问题，我们的资讯时间的数据是 UnixTime 格式的，我们希望显示为便于阅读的格式。</p>
<p>框架提供了一种快速扩展的方式，只需在 <code>app/extend</code> 目录下提供扩展脚本即可，具体参见<a href="https://eggjs.org/zh-cn/basics/extend.html" target="_blank" rel="noopener">扩展</a>。</p>
<p>在这里，我们可以使用 View 插件支持的 Helper 来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i moment --save</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;extend&#x2F;helper.js</span><br><span class="line">const moment &#x3D; require(&#39;moment&#39;);</span><br><span class="line">exports.relativeTime &#x3D; time &#x3D;&gt; moment(new Date(time * 1000)).fromNow();</span><br></pre></td></tr></table></figure>

<p>在模板里面使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- app&#x2F;view&#x2F;news&#x2F;list.tpl --&gt;</span><br><span class="line">&#123;&#123; helper.relativeTime(item.time) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-Middleware"><a href="#编写-Middleware" class="headerlink" title="编写 Middleware"></a>编写 Middleware</h3><p>假设有个需求：我们的新闻站点，禁止百度爬虫访问。</p>
<p>聪明的同学们一定很快能想到可以通过 <a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">Middleware</a> 判断 User-Agent，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;middleware&#x2F;robot.js</span><br><span class="line">&#x2F;&#x2F; options &#x3D;&#x3D;&#x3D; app.config.robot</span><br><span class="line">module.exports &#x3D; (options, app) &#x3D;&gt; &#123;</span><br><span class="line">  return async function robotMiddleware(ctx, next) &#123;</span><br><span class="line">    const source &#x3D; ctx.get(&#39;user-agent&#39;) || &#39;&#39;;</span><br><span class="line">    const match &#x3D; options.ua.some(ua &#x3D;&gt; ua.test(source));</span><br><span class="line">    if (match) &#123;</span><br><span class="line">      ctx.status &#x3D; 403;</span><br><span class="line">      ctx.message &#x3D; &#39;Go away, robot.&#39;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      await next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">&#x2F;&#x2F; add middleware robot</span><br><span class="line">exports.middleware &#x3D; [</span><br><span class="line">  &#39;robot&#39;</span><br><span class="line">];</span><br><span class="line">&#x2F;&#x2F; robot&#39;s configurations</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在可以使用 <code>curl http://localhost:7001/news -A &quot;Baiduspider&quot;</code> 看看效果。</p>
<p>更多参见<a href="https://eggjs.org/zh-cn/basics/middleware.html" target="_blank" rel="noopener">中间件</a>文档。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>写业务的时候，不可避免的需要有配置文件，框架提供了强大的配置合并管理功能：</p>
<ul>
<li>支持按环境变量加载不同的配置文件，如 <code>config.local.js</code>， <code>config.prod.js</code> 等等。</li>
<li>应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载。</li>
<li>具体合并逻辑可参见<a href="https://eggjs.org/zh-cn/basics/config.html#配置加载顺序" target="_blank" rel="noopener">配置文件</a>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; config&#x2F;config.default.js</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;curl&#x2F;i,</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; config&#x2F;config.local.js</span><br><span class="line">&#x2F;&#x2F; only read at development mode, will override default</span><br><span class="line">exports.robot &#x3D; &#123;</span><br><span class="line">  ua: [</span><br><span class="line">    &#x2F;Baiduspider&#x2F;i,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app&#x2F;service&#x2F;some.js</span><br><span class="line">const Service &#x3D; require(&#39;egg&#39;).Service;</span><br><span class="line"></span><br><span class="line">class SomeService extends Service &#123;</span><br><span class="line">  async list() &#123;</span><br><span class="line">    const rule &#x3D; this.config.robot.ua;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; SomeService;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试非常重要，框架也提供了 <a href="https://github.com/eggjs/egg-bin" target="_blank" rel="noopener">egg-bin</a> 来帮开发者无痛的编写测试。</p>
<p>测试文件应该放在项目根目录下的 test 目录下，并以 <code>test.js</code> 为后缀名，即 <code>{app_root}/test/**/*.test.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test&#x2F;app&#x2F;middleware&#x2F;robot.test.js</span><br><span class="line">const &#123; app, mock, assert &#125; &#x3D; require(&#39;egg-mock&#x2F;bootstrap&#39;);</span><br><span class="line"></span><br><span class="line">describe(&#39;test&#x2F;app&#x2F;middleware&#x2F;robot.test.js&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  it(&#39;should block robot&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    return app.httpRequest()</span><br><span class="line">      .get(&#39;&#x2F;&#39;)</span><br><span class="line">      .set(&#39;User-Agent&#39;, &quot;Baiduspider&quot;)</span><br><span class="line">      .expect(403);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后配置依赖和 <code>npm scripts</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;egg-bin test&quot;,</span><br><span class="line">    &quot;cov&quot;: &quot;egg-bin cov&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i egg-mock --save-dev</span><br></pre></td></tr></table></figure>

<p>执行测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm test</span><br></pre></td></tr></table></figure>

<p>就这么简单，更多请参见 <a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>短短几章内容，只能讲 Egg 的冰山一角，我们建议开发者继续阅读其他章节：</p>
<ul>
<li>关于骨架类型，参见<a href="https://eggjs.org/zh-cn/tutorials/index.html" target="_blank" rel="noopener">骨架说明</a></li>
<li>提供了强大的扩展机制，参见<a href="https://eggjs.org/zh-cn/basics/plugin.html" target="_blank" rel="noopener">插件</a>。</li>
<li>一个大规模的团队需要遵循一定的约束和约定，在 Egg 里我们建议封装适合自己团队的上层框架，参见 <a href="https://eggjs.org/zh-cn/advanced/framework.html" target="_blank" rel="noopener">框架开发</a>。</li>
<li>这是一个渐进式的框架，代码的共建，复用和下沉，竟然可以这么的无痛，建议阅读 <a href="https://eggjs.org/zh-cn/tutorials/progressive.html" target="_blank" rel="noopener">渐进式开发</a>。</li>
<li>写单元测试其实很简单的事，Egg 也提供了非常多的配套辅助，我们强烈建议大家测试驱动开发，具体参见 <a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a>。</li>
</ul>
]]></content>
      <categories>
        <category>eggjs</category>
      </categories>
  </entry>
  <entry>
    <title>cocos动态龙骨</title>
    <url>/2020/04/14/cocos/cocos%E5%8A%A8%E6%80%81%E9%BE%99%E9%AA%A8/</url>
    <content><![CDATA[<blockquote>
<p>在cocos中有关动态的，都离不开<code>resources</code>这个目录，同时，这个目录使用的是<code>loader</code>模块加载。在游戏的开发过程中，对于一些节点有着十分多的动画资源的时候，比如换装之类的，这样的话全部挂载在一个节点上的话会造成游戏加载时间过长，玩家的耐心会消磨完。因此就有了动态的需求，主要的目的就是使得用户能够尽快的进去。</p>
</blockquote>
<a id="more"></a>

<h3 id="资源位置"><a href="#资源位置" class="headerlink" title="资源位置"></a>资源位置</h3><p>在<code>cocos</code>中，动态资源都是放在<code>resources</code>中的，</p>
<p>示例目录如下：</p>
<p><img src="/static/cocos/cocos%E5%8A%A8%E6%80%81%E9%BE%99%E9%AA%A8/images/image-20200414112831540.png" alt="image-20200414112831540"></p>
<p>然后我们采用<code>loadResDir</code>的方式加载<code>eatting</code>下的三个龙骨资源，因为这三个都是必须的，必须同时加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadDragonBones(</span><br><span class="line">    path: string,</span><br><span class="line">    cb?: (bone: IDragonAssets) &#x3D;&gt; void</span><br><span class="line">): Promise&lt;IDragonAssets&gt; &#123;</span><br><span class="line">    let that &#x3D; this;</span><br><span class="line">    let allAssets: IDragonAssets &#x3D; &#123;</span><br><span class="line">        dragonAsset: null,</span><br><span class="line">        dragonAtlasAsset: null</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;动态加载龙骨</span><br><span class="line"></span><br><span class="line">        if (this.cacheAssets[path]) &#123;</span><br><span class="line">            allAssets &#x3D; this.cacheAssets[path]</span><br><span class="line">            cb &amp;&amp; cb(allAssets);</span><br><span class="line">            resolve(allAssets);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let ac &#x3D; cc.loader.loadResDir(path, function (err, assets) &#123;</span><br><span class="line">            if (err || assets.length &lt;&#x3D; 0) &#123;</span><br><span class="line">                err &amp;&amp; console.error(err)</span><br><span class="line">                assets.length &lt;&#x3D; 0 &amp;&amp; console.error(&quot;该目录下没有资源:&quot; + path)</span><br><span class="line">                &#x2F;&#x2F; reject();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            assets.forEach(asset &#x3D;&gt; &#123;</span><br><span class="line">                if (asset instanceof dragonBones.DragonBonesAsset) &#123;</span><br><span class="line">                    allAssets.dragonAsset &#x3D; asset;</span><br><span class="line">                &#125;</span><br><span class="line">                if (asset instanceof dragonBones.DragonBonesAtlasAsset) &#123;</span><br><span class="line">                    allAssets.dragonAtlasAsset &#x3D; asset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            cb &amp;&amp; cb(allAssets);</span><br><span class="line">            resolve(allAssets);</span><br><span class="line">            that.cacheAssets[path] &#x3D; allAssets</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导出<code>DragonBonesAsset</code>和<code>DragonBonesAtlasAsset</code>后，动态赋值到节点的龙骨组件上就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadingNodeDragon(</span><br><span class="line">    node: cc.Node,</span><br><span class="line">    bones: IDragonAssets,</span><br><span class="line">    armatureName?: string</span><br><span class="line">) &#123;</span><br><span class="line">    let animationDisplay &#x3D; node.getComponent(dragonBones.ArmatureDisplay);</span><br><span class="line">    if (!animationDisplay) &#123;</span><br><span class="line">        animationDisplay &#x3D; node.addComponent(dragonBones.ArmatureDisplay);</span><br><span class="line">    &#125;</span><br><span class="line">    if (bones.dragonAsset instanceof dragonBones.DragonBonesAsset) &#123;</span><br><span class="line">        animationDisplay.dragonAsset &#x3D; bones.dragonAsset;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bones.dragonAtlasAsset instanceof dragonBones.DragonBonesAtlasAsset) &#123;</span><br><span class="line">        animationDisplay.dragonAtlasAsset &#x3D; bones.dragonAtlasAsset;</span><br><span class="line">    &#125;</span><br><span class="line">    if (armatureName) &#123;</span><br><span class="line">        animationDisplay.armatureName &#x3D; armatureName;</span><br><span class="line">    &#125;</span><br><span class="line">    return animationDisplay</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来只要正常播放就行了。</p>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos适配心得</title>
    <url>/2020/04/14/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<blockquote>
<p>在cocos的适配方案中，默认提供的就是<code>fit height</code>和<code>fit width</code>.</p>
<ul>
<li><code>fit height</code>表示根据高度来适配，高度一定是与设备高度一直，宽度可以随意变化，这个时候，在宽度很宽的情况下可能会有两边截断的情况。</li>
<li><code>fit width</code>同理</li>
<li>当两个一起钩选的时候，会保证界面一定完整的显示界面，但是不可避免的，会产生黑边。</li>
</ul>
<p>在做cocos的适配的时候，我们不能直接钩选两个，而是只控制一边，另一部分可结合<code>Widget</code>组件来实现</p>
</blockquote>
<a id="more"></a>

<h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><p><img src="/static/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/images/image-20200428134427268.png" alt="image-20200428134427268"></p>
<p>场景的适配策略只需要钩选适配高度就行了。再结合<code>Widget</code>就能够实现不留黑边的全屏</p>
<p><img src="/static/cocos/cocos%E9%80%82%E9%85%8D%E5%BF%83%E5%BE%97/images/image-20200428134542763.png" alt="image-20200428134542763"></p>
<p>但这还是不够的，因为你的子元素也得加上这个<code>Widget</code>才行，保证不是绝对布局，而是相对于上下左右四个边界的距离，灵活调整<code>top,right,bottom,left</code>的值，就能实现全屏与布局的流动化。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>你要实现某部分的流动布局，必须将其所有的父元素也先<code>widget</code>化.或者直接绑定根元素</p>
<p>屏幕太小的话元素会重叠。</p>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
  </entry>
  <entry>
    <title>cocos的几种动画方式</title>
    <url>/2020/04/14/cocos/%E5%8A%A8%E7%94%BB/cocos%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8A%A8%E7%94%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>github-actions详解</title>
    <url>/2020/04/14/github/github-actions%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.v2ex.com/t/609744" target="_blank" rel="noopener">https://www.v2ex.com/t/609744</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
  </entry>
  <entry>
    <title>webpack的几种导入导出方式</title>
    <url>/2020/04/13/webpack/webpack%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/04/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式</p>
<a id="more"></a>

<h3 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>{<em>n</em>}</td>
<td><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{<em>n</em>,}</td>
<td><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{<em>n</em>,<em>m</em>}</td>
<td><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（<em>,+,?，{*n</em>}，{<em>n</em>,}，{<em>n</em>,<em>m</em>}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除“*n<em>”之外的任何单个字符。要匹配包括“\</em>n*”在内的任何字符，请使用像“(.|\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td>(?&lt;=pattern)</td>
<td>反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td>
</tr>
<tr>
<td>(?&lt;!pattern)</td>
<td>反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td>\x<em>n</em></td>
<td>匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td>*num*</td>
<td>匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>*n*</td>
<td>标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td>*nm*</td>
<td>标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果\</em>nm<em>之前至少有</em>n<em>个获取，则</em>n<em>为一个后跟文字</em>m<em>的向后引用。如果前面的条件都不满足，若</em>n<em>和</em>m<em>均为八进制数字（0-7），则\</em>nm<em>将匹配八进制转义值</em>nm*。</td>
</tr>
<tr>
<td>*nml*</td>
<td>如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
<tr>
<td>\u<em>n</em></td>
<td>匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody></table>
<h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3><table>
<thead>
<tr>
<th>用户名</th>
<th>/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody><tr>
<td>密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td>十六进制值</td>
<td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td>
</tr>
<tr>
<td>电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$//^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td>URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]<em>)</em>/?$/</td>
</tr>
<tr>
<td>IP 地址</td>
<td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td>HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td>
</tr>
<tr>
<td>删除代码\注释</td>
<td>(?&lt;!http:|\S)//.*$</td>
</tr>
<tr>
<td>Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator常用api</title>
    <url>/2020/04/07/cocos/cocos-creator%E5%B8%B8%E7%94%A8api/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/sotmwhat/article/details/93884076" target="_blank" rel="noopener">https://blog.csdn.net/sotmwhat/article/details/93884076</a></p>
</blockquote>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cc.director.loadScene(<span class="string">'场景名称'</span>);<span class="comment">//场景跳转</span></span><br><span class="line">cc.director.preloadScene(<span class="string">'场景名称'</span>);<span class="comment">//预加载场景</span></span><br><span class="line">cc.director.getScene();<span class="comment">//获取当前场景</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = cc.find(<span class="string">"Canvas/bg"</span>);<span class="comment">//通过访问路径来获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByName(<span class="string">'name'</span>);<span class="comment">//通过名字获取子节点</span></span><br><span class="line">node.getComponent(cc.Label).string = <span class="string">'abc'</span>;<span class="comment">//获取节点上的组件值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"Canvas/bg"</span>).getComponent(cc.Sprite);<span class="comment">//通过访问路径来获取节点，及获取该节点的指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node .getChildByName(<span class="string">'节点名称'</span>).getComponent(cc.Label)<span class="comment">//通过节点名获取子节点，获取该节点指定组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node;<span class="comment">//获取当前脚本所在的节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.parent;<span class="comment">//获取父节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.getChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签获取子节点</span></span><br><span class="line"><span class="keyword">var</span> a = cc.find(<span class="string">"bg/score"</span>,<span class="keyword">this</span>.node);<span class="comment">//通过指定节点下的路径获取节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.children;<span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">this</span>.node.childrenCount;<span class="comment">//获取子节点数量</span></span><br><span class="line"><span class="keyword">var</span> a = cc.director.getScene();<span class="comment">//获取场景主节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = cc.instantiate(node);<span class="comment">//克隆节点</span></span><br><span class="line"><span class="keyword">this</span>.node.parent = cc.find(<span class="string">'Canvas'</span>);<span class="comment">//绑定父节点</span></span><br><span class="line"><span class="keyword">this</span>.node.addChild(nodeName,zIndex,tag);<span class="comment">//添加子节点,可设置层级和标签</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(nodeName);<span class="comment">//通过名字移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag (nodeTag);<span class="comment">//通过标签移除子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroy();<span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.node.isValid;<span class="comment">//判定节点是否可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.node.removeChild(newNode);<span class="comment">//移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeChildByTag(<span class="number">1001</span>);<span class="comment">//通过标签移除节点中指定的子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.removeAllChildren();<span class="comment">//移除所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.destroyAllChildren();<span class="comment">//销毁所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.cleanup();<span class="comment">//停止所有正在播放的动作和计时器</span></span><br><span class="line"><span class="keyword">var</span> sprites = <span class="keyword">this</span>.node.getComponentsInChildren(cc.Label);<span class="comment">//递归查找自身及所有子节点中指定类型的组件</span></span><br></pre></td></tr></table></figure>

<h2 id="获取节点位置，设置节点"><a href="#获取节点位置，设置节点" class="headerlink" title="获取节点位置，设置节点"></a>获取节点位置，设置节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = node.getPositionX();或 getPositionY() <span class="comment">//获取节点的X轴或Y轴坐标</span></span><br><span class="line"><span class="keyword">var</span> a = node.getScaleX(); 或getScaleY() <span class="comment">//获取节点的X轴或Y轴缩放比例</span></span><br><span class="line">node.x = <span class="number">100</span>;<span class="comment">//设置节点x轴坐标</span></span><br><span class="line">node.y = <span class="number">100</span>;<span class="comment">//设置节点y轴坐标</span></span><br><span class="line">node.setPosition(x,y); <span class="comment">//设置节点坐标</span></span><br><span class="line">node.rotation = <span class="number">90</span>; <span class="comment">//设置节点旋转角度</span></span><br><span class="line">node.scaleX = <span class="number">2</span>; <span class="comment">//设置节点x轴缩放倍数</span></span><br><span class="line">node.scaleY = <span class="number">2</span>; <span class="comment">//设置节点y轴缩放倍数</span></span><br><span class="line">node.setScale(<span class="number">2</span>); <span class="comment">//设置节点整体缩放倍数</span></span><br><span class="line">node.width = <span class="number">100</span>; <span class="comment">//设置节点宽度大小</span></span><br><span class="line">node.height = <span class="number">100</span>;  <span class="comment">//设置节点高度大小</span></span><br><span class="line">node.setContentSize(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置节点宽高尺寸大小</span></span><br><span class="line">node.anchorX = <span class="number">1</span>; <span class="comment">//设置节点x轴锚点坐标</span></span><br><span class="line">node.anchorY = <span class="number">0</span>; <span class="comment">//设置节点y轴锚点坐标</span></span><br><span class="line">node.setAnchorPoint(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//设置节点锚点坐标</span></span><br><span class="line">node.opacity = <span class="number">128</span>; <span class="comment">//设置节点透明度大小（0-255）</span></span><br><span class="line">node.setOpacity(<span class="number">20</span>); <span class="comment">//设置节点透明度（0~255）</span></span><br><span class="line">node.color = <span class="keyword">new</span> cc.color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>); <span class="comment">//设置节点颜色（R,G,B,透明度）</span></span><br><span class="line"><span class="keyword">if</span> (cc.isValid(<span class="keyword">this</span>.label.node) ) <span class="comment">//判定节点是否存在</span></span><br><span class="line">node.destroy(); <span class="comment">//销毁节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = [];</span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildren(); <span class="comment">//获取所有子节点</span></span><br><span class="line"><span class="keyword">this</span>.cannons = node.getChildrenCount(); <span class="comment">//获取子节点数量</span></span><br><span class="line">node.active = <span class="literal">false</span>; <span class="comment">//关闭节点(隐藏节点)</span></span><br><span class="line">cc.game.addPersistRootNode(myNode); <span class="comment">//常驻节点（全局变量）</span></span><br><span class="line">cc.game.removePersistRootNode(myNode); <span class="comment">//取消常驻节点</span></span><br></pre></td></tr></table></figure>

<h2 id="动作操作"><a href="#动作操作" class="headerlink" title="动作操作"></a>动作操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.show()&#x2F;&#x2F;立即显示</span><br><span class="line">cc.hide ()&#x2F;&#x2F;立即隐藏</span><br><span class="line">cc.toggleVisibility()&#x2F;&#x2F;显隐切换</span><br><span class="line">cc.fadeIn(1)&#x2F;&#x2F;渐显效果</span><br><span class="line">cc.fadeOut(1)&#x2F;&#x2F;渐隐效果</span><br><span class="line">cc.delayTime(1)&#x2F;&#x2F;等待1秒</span><br><span class="line">node.runAction(cc.moveTo(1,0,0)); &#x2F;&#x2F;移动到当前节点（时间（s），X轴坐标，Y 轴坐标）</span><br><span class="line">node.runAction(cc.scaleTo(1,0.7,0.8));&#x2F;&#x2F;缩放到当前倍数节点（时间（s），X轴倍数，Y 轴倍数）</span><br><span class="line">node.runAction(cc.rotateTo(1,160,160));&#x2F;&#x2F;旋转到指定角度（时间（s），X轴角度，Y 轴角度）</span><br><span class="line">node.runAction(cc.skewTo(1,5,-5));&#x2F;&#x2F;变化节点倾斜度（时间（s），X轴倾斜度，Y 轴倾斜度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.fadeTo(2,0));&#x2F;&#x2F;变化当前节点的透明度（时间（s），透明度）</span><br><span class="line"></span><br><span class="line">node.runAction(cc.tintTo(2,255,255,0));&#x2F;&#x2F;变化当前节点颜色（时间，R,G,B）</span><br><span class="line">node.stopAllActions();&#x2F;&#x2F;停止所有动作</span><br><span class="line">&#x2F;&#x2F;自定义动作</span><br><span class="line">var action &#x3D; cc.moveTo(2, 100, 100);&#x2F;&#x2F; 创建一个移动动作</span><br><span class="line">node.runAction(action);&#x2F;&#x2F; 执行动作</span><br><span class="line">node.stopAction(action);&#x2F;&#x2F; 停止一个动作</span><br><span class="line"></span><br><span class="line">cc.sequence(action1,action2); &#x2F;&#x2F;按顺序连续执行，先action1，后action2</span><br><span class="line"></span><br><span class="line">cc.spawn(action1，action2); &#x2F;&#x2F;同时执行，action1和action2一起执行</span><br><span class="line"></span><br><span class="line">cc.repeatForever(cc.sequence(action1,action2)); &#x2F;&#x2F;一直重复括号里的动作</span><br></pre></td></tr></table></figure>

<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只用1次的计时器,2秒后执行</span><br><span class="line">        this.scheduleOnce(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,2); &#x2F;&#x2F;(function()&#123;&#125;,时间（s）)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每隔5秒执行1次</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句  </span><br><span class="line"></span><br><span class="line">        &#125;,5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算多次的计时器（1秒后，以0.1秒的执行间隔，执行10次）</span><br><span class="line">        this.schedule(function()&#123;</span><br><span class="line">            &#x2F;&#x2F;一条或多条执行语句</span><br><span class="line"></span><br><span class="line">        &#125;,0.1,10,1); &#x2F;&#x2F;(function()&#123;&#125;,间隔时间，次数，多久后开始)</span><br><span class="line"></span><br><span class="line">this.unscheduleAllCallbacks(this);&#x2F;&#x2F;停止某组件的所有计时器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义定时器执行内容（相比常规使用的定时器优势是：方便随时开启或关闭）</span><br><span class="line">var cb&#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;;</span><br><span class="line">this.schedule(cb,1);&#x2F;&#x2F;启动定时器</span><br><span class="line">this.unschedule(cb);&#x2F;&#x2F;取消定时器</span><br></pre></td></tr></table></figure>

<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(开始：&#39;touchstart&#39;，移动：&#39;touchmove&#39;，结束：&#39;touchend&#39;，取消：&#39;touchcancel&#39;)</span><br><span class="line">node.on(&#39;touchstart&#39;,function(event)&#123;</span><br><span class="line">    this.doSomething();</span><br><span class="line">&#125;,this);  </span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line">var a &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的坐标X</span><br><span class="line">var b &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的坐标Y</span><br><span class="line"></span><br><span class="line">cc.eventManager.addListener(&#123;</span><br><span class="line">            event: cc.EventListener.KEYBOARD&#x2F;TOUCH_ONE_BY_ONE,myfunction&#125;,self.node);</span><br></pre></td></tr></table></figure>

<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获得设备分辨率</span><br><span class="line">var b &#x3D; cc.director.getWinSizeInPixels()</span><br><span class="line">var bx &#x3D; b.width</span><br><span class="line">var by &#x3D; b.height</span><br><span class="line"></span><br><span class="line">cc.view.getCanvasSize().width;&#x2F;&#x2F;获得设备分辨率的宽度</span><br><span class="line">cc.view.getCanvasSize().height;&#x2F;&#x2F;获得设备分辨率的高度</span><br><span class="line">cc.director.setDisplayStats(true);&#x2F;&#x2F;显示帧数信息</span><br></pre></td></tr></table></figure>

<h2 id="音频控制"><a href="#音频控制" class="headerlink" title="音频控制"></a>音频控制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.audioEngine.playMusic(this.BGAudio,true);&#x2F;&#x2F;播放音乐（true代表循环）</span><br><span class="line">cc.audioEngine.stopMusic()&#x2F;&#x2F;停止播放背景音乐</span><br><span class="line">cc.audioEngine.playEffect(this.ClickAudio,false);&#x2F;&#x2F;播放音效（false代表只播放一次）</span><br><span class="line">cc.audioEngine.stopEffect(音效变量名);&#x2F;&#x2F;停止指定音效（需要先把音效赋值给变量）</span><br><span class="line">cc.audioEngine.AllEffects();&#x2F;&#x2F;停止所有音效</span><br><span class="line">cc.audioEngine.setMusicVolume(参数);  &#x2F;&#x2F;设置背景音乐的音量（该参数范围是0到1）</span><br><span class="line">cc.audioEngine.setEffectsVolume(参数);  &#x2F;&#x2F;设置音效的音量（该参数范围是0到1）</span><br></pre></td></tr></table></figure>

<h2 id="存档操作"><a href="#存档操作" class="headerlink" title="存档操作"></a>存档操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.localStorage.setItem(&#39;存储标识名&#39;,变量名);&#x2F;&#x2F;存储存档数据</span><br><span class="line">var a &#x3D; cc.sys.localStorage.getItem(&#39;存储标识名&#39;);&#x2F;&#x2F;读取存档数据</span><br><span class="line">cc.sys.localStorage.removeItem(&#39;存储标识名&#39;);&#x2F;&#x2F;擦除存档数据</span><br><span class="line">userData &#x3D; &#123;</span><br><span class="line">    name: &#39;Tracer&#39;,</span><br><span class="line">    level: 1,</span><br><span class="line">    gold: 100</span><br><span class="line">&#125;;</span><br><span class="line">cc.sys.localStorage.setItem(&#39;userData&#39;, JSON.stringify(userData));&#x2F;&#x2F;存取复杂对象数据</span><br><span class="line">var userData &#x3D; JSON.parse(cc.sys.localStorage.getItem(&#39;userData&#39;));&#x2F;&#x2F;读取复杂对象数据</span><br></pre></td></tr></table></figure>

<h2 id="判断平台"><a href="#判断平台" class="headerlink" title="判断平台"></a>判断平台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.sys.isNative  &#x2F;&#x2F;是否是本地</span><br><span class="line">cc.sys.isBrowser  &#x2F;&#x2F;是否是网页</span><br><span class="line">cc.sys.isMobile  &#x2F;&#x2F;是否是移动系统</span><br><span class="line">cc.sys.platform  &#x2F;&#x2F;正在运行的平台</span><br><span class="line">cc.sys.language  &#x2F;&#x2F;当前运行系统的语言</span><br><span class="line">cc.sys.os  &#x2F;&#x2F;当前正在运行的系统</span><br><span class="line">cc.sys.OS_IOS  &#x2F;&#x2F;是否是IOS系统</span><br><span class="line">cc.sys.OS_ANDROID  &#x2F;&#x2F;是否是android系统</span><br><span class="line">cc.sys.OS_WINDOWS  &#x2F;&#x2F;是否是windows系统</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);  &#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>

<h2 id="监听和发射事件"><a href="#监听和发射事件" class="headerlink" title="监听和发射事件"></a>监听和发射事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.node.pauseSystemEvents(true);&#x2F;&#x2F;暂停节点系统事件</span><br><span class="line">this.node.resumeSystemEvents(true);&#x2F;&#x2F;恢复节点系统事件</span><br><span class="line">this.node.targetOff(this);&#x2F;&#x2F;移除所有注册事件</span><br><span class="line"></span><br><span class="line">触摸监听：开始&#39;touchstart&#39;,移动&#39;touchmove&#39;,结束&#39;touchend&#39;,取消&#39;touchcancel&#39;</span><br><span class="line">var pos &#x3D; event.getLocation();&#x2F;&#x2F;获取触摸点的坐标(包含X和Y)</span><br><span class="line">var x &#x3D; event.getLocationX();&#x2F;&#x2F;获取触摸点的X坐标</span><br><span class="line">var y &#x3D; event.getLocationY();&#x2F;&#x2F;获取触摸点的Y坐标</span><br><span class="line">var a &#x3D; event.getID();&#x2F;&#x2F;获取触点的ID</span><br><span class="line"></span><br><span class="line">鼠标监听：鼠标按下&#39;mousedown&#39;,移入节点&#39;mouseenter&#39;,节点中移动&#39;mousemove&#39;,移出节点&#39;mouseleave,&#39;松开鼠标&#39;mouseup&#39;</span><br><span class="line">var a &#x3D; event.getScrollY();&#x2F;&#x2F;获取滚轮滚动的 Y 轴距离，只有滚动时才有效</span><br><span class="line">var a &#x3D; event.getLocation();&#x2F;&#x2F;获取鼠标位置对象，对象包含 x 和 y 属性</span><br><span class="line"></span><br><span class="line">输入框监听：获得焦点&#39;editing-did-began&#39;,文字变化&#39;text-changed&#39;,失去焦点&#39;editing-did-ended&#39;,按下回车&#39;editing-return&#39;</span><br><span class="line"></span><br><span class="line">属性变化监听：位置&#39;position-changed&#39;,宽高 &#39;size-changed&#39;,旋转&#39;rotation-changed&#39;,缩放&#39;scale-changed&#39;</span><br><span class="line"></span><br><span class="line">ScrollView控件监听：滚动中&#39;scrolling&#39;,停止滚动&#39;scroll-ended&#39;</span><br><span class="line"></span><br><span class="line">用户自定义事件:</span><br><span class="line">this.node.on(&#39;事件名&#39;,function,this);&#x2F;&#x2F;注册监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;);&#x2F;&#x2F;发送监听广播</span><br><span class="line">this.node.off(&#39;事件名&#39;,function,this);&#x2F;&#x2F;关闭监听</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册带参数监听</span><br><span class="line">this.node.on(&#39;事件名&#39;,function(event)&#123;</span><br><span class="line"></span><br><span class="line">“具体方法函数内容”</span><br><span class="line"></span><br><span class="line">&#125;,this);</span><br><span class="line">&#x2F;&#x2F;发送带参数的监听</span><br><span class="line">this.node.emit(&#39;事件名&#39;,&#123;id:1001&#125;);</span><br><span class="line">cc.eventManager.addListener(listener, node);&#x2F;&#x2F;添加事件</span><br><span class="line">cc.eventManager.removeListener((listener);&#x2F;&#x2F;移除事件</span><br></pre></td></tr></table></figure>

<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc.director.pause();&#x2F;&#x2F;暂停</span><br><span class="line">cc.director.resume();&#x2F;&#x2F;继续</span><br><span class="line">cc.director.end();&#x2F;&#x2F;退出整个应用</span><br><span class="line">cc.log(变量)  或 console.log(something);&#x2F;&#x2F;输出想要的信息</span><br><span class="line">let self &#x3D; this;&#x2F;&#x2F;锁定当前使用的this指向</span><br><span class="line">node.getLocalZOrder();&#x2F;&#x2F;层级获取</span><br><span class="line">node.setLocalZOrder(1);&#x2F;&#x2F;层级改变</span><br><span class="line">cc.find(&#39;canvas&#x2F;map&#39; + num)&#x2F;&#x2F;读取带变量的路径</span><br><span class="line">cc.sys.openURL(&#39;Http:&#x2F;&#x2F;www.baidu.com&#39;);&#x2F;&#x2F;打开网页</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>spriteAltas精灵图集使用方式</title>
    <url>/2020/04/07/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>之前，对于扑克牌的加载一直是散装加载，用<code>loadRes</code>动态的添加到游戏中，这样的缺陷是在动画的时候会闪一下，在网慢的情况下也许扑克牌不会加载出来而动画就执行了。因此，改用图集加载方式，将整幅扑克牌一起加载出来，用那种加载哪张就行了。</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>新加一个属性:</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407114816545.png" alt="image-20200407114816545"></p>
</li>
<li><p>我们用图集打包出来的是这样的文件：</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407114923862.png" alt="image-20200407114923862"></p>
</li>
<li><p>在<code>cocos</code>上将<code>plist</code>拖进属性中。</p>
<p><img src="/static/cocos/spriteAltas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/images/image-20200407115004375.png" alt="image-20200407115004375"></p>
</li>
<li><p>编写代码动态修改精灵图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setAtlasImg(node,spAtlas,spriteName)&#123;</span><br><span class="line">  <span class="keyword">let</span> sprite = node.getComponent(cc.Sprite);</span><br><span class="line">  <span class="keyword">if</span> (!sprite) &#123;</span><br><span class="line">    sprite = node.addComponent(cc.Sprite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mySprite =  spAtlas.getSpriteFrame(spriteName)</span><br><span class="line">  sprite.spriteFrame = mySprite;</span><br><span class="line">  <span class="keyword">return</span> mySprite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节点，图集组件，图集中文件名字</span></span><br><span class="line">setAtlasImg(<span class="keyword">this</span>.node, <span class="keyword">this</span>.spAtlas, <span class="string">"11"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>有关用node开发websocket多人聊天程序的后台</title>
    <url>/2020/04/06/node/%E6%9C%89%E5%85%B3%E7%94%A8node%E5%BC%80%E5%8F%91websocket%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8E%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>（开发过程中积累）</p>
<ul>
<li><code>ws</code>库的使用方法</li>
<li><code>node</code>的语言熟悉度</li>
<li>数据库增删改查的基础语法</li>
<li>明确的流程分析与功能</li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>node生成文件模板</title>
    <url>/2020/04/06/node/node%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<blockquote>
<p>主要用作生成文件模板，方便之后的一系列开发，能够快速的制作类似结构的复杂页面。</p>
<p><a href="https://www.npmjs.com/package/plop" target="_blank" rel="noopener">plop npm</a></p>
</blockquote>
<a id="more"></a>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i plop -D</span><br></pre></td></tr></table></figure>

<p>源码下载: <a href="/static/node/node生成文件模板/files/plop.zip">Hexo文章页面模板下载</a></p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>支付宝免签支付</title>
    <url>/2020/04/06/%E5%89%8D%E7%AB%AF/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%8D%E7%AD%BE%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<blockquote>
<p> 源码下载：<a href="/static/前端/业务相关/支付宝免签支付/files/支付宝免签支付.zip">点击下载</a></p>
<p>在最近的公司业务中，需要用到灰色地带的支付，因此不能使用正规的支付宝流程，经过一段事件的调查与研究，发现了有关支付宝的免签支付，不过也存在着几种方式，有些方式并不适用，都存在着一些无法避免的限制。</p>
</blockquote>
<a id="more"></a>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加看板娘</title>
    <url>/2020/04/05/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
    <content><![CDATA[<blockquote>
<p>源码下载：<a href="http://cloud.poorman.top/index.php?share/folder&user=1&sid=NgEfhW2k#" target="_blank" rel="noopener">点击下载</a> 源码地址：<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">live2d-widget</a></p>
<p>这是首先感谢原作者的插件，我根据Github上的项目克隆下载自定义的看板娘，在他的基础上添加了拖动效果，同时根据自己的博客自定义了不同的对话。</p>
</blockquote>
<a id="more"></a>

<h2 id="用法-Usage"><a href="#用法-Usage" class="headerlink" title="用法 Usage"></a>用法 Usage</h2><ol>
<li>首先下载上面的源码，这个<code>hexo-bolg</code>表示是我的博客根目录，然后再<code>source\js</code>目录下解压，得到以下的文件。</li>
</ol>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112453987.png" alt="image-20200405112453987"></p>
<ol start="2">
<li><p>如果是<code>next</code>主题，请根据目录打开以下文件:</p>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112653619.png" alt="image-20200405112653619"></p>
<p>将代码添加到如图所示的位置：</p>
<p><img src="/static/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/images/image-20200405112737704.png" alt="image-20200405112737704"></p>
</li>
<li><p>大功告成，将页面启动起来就能看见效果了。不过最好自己去改一下源码的<code>waifu-tips.json</code>的匹配条件，根据自己的博客做出对应的对话效果。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现全站变灰</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/css%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99%E5%8F%98%E7%81%B0/</url>
    <content><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">     <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-moz-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-ms-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">-o-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">     <span class="attribute">filter</span>: progid:DXImageTransfrom.Microsoft.<span class="built_in">BasicImage</span>(grayscale=<span class="number">1</span>);</span><br><span class="line">     <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack零散知识点</title>
    <url>/2020/04/04/webpack/webpack%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><ul>
<li><p><code>mode</code></p>
<p>主要区分为：<code>development</code>和<code>production</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>development</code></td>
<td>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>。启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</td>
</tr>
<tr>
<td><code>production</code></td>
<td>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>。启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code></td>
</tr>
</tbody></table>
<blockquote>
<p><em>记住，只设置</em> <code>NODE_ENV</code><em>，则不会自动设置</em> <code>mode</code>。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>entry</code></p>
<p>可以是数组或者对象</p>
<ul>
<li><p>数组</p>
<p>数组中表示的所有文件都将打包成一个文件，对应的是对象中键的<code>main</code>。也就是说</p>
<p>如果值是<code>[&#39;src/index.js&#39;]</code>的话，跟<code>{main:&#39;src/index.js&#39;}</code>效果是一样的。</p>
</li>
<li><p>对象</p>
<p>如果存在多个键值的话表示的就是多个入口，<code>webpack</code>将会从多个入口进入开始打包。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"entry"</span>:&#123;</span><br><span class="line">   <span class="string">"main"</span>:[<span class="string">"src/index.js"</span>],</span><br><span class="line">   <span class="string">"react"</span>:<span class="string">"react"</span>,</span><br><span class="line">   <span class="string">"vue"</span>:[<span class="string">"vue"</span>,<span class="string">"vue-router"</span>,<span class="string">"vuex"</span>]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如上的话就会打包出三个文件出来，分别是<code>main</code>,<code>react</code>,<code>vue</code>名字可以再输出的时候自定义。</p>
</li>
</ul>
</li>
<li><p><code>output</code></p>
<p>对象。作为此配置的最低要求，我们需要提供两个参数：1. <code>filename</code>表示将要输出的文件名字。2. <code>path</code>将要输出的路径</p>
<ul>
<li><p>单入口文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

<p>此配置将一个单独的 <code>bundle.js</code> 文件输出到 <code>/home/proj/public/assets</code> 目录中。</p>
</li>
<li><p>多入口文件</p>
<p>多入口不能单独的指定一个具体的文件名，而是需要提供一个占位符，由<code>webpack</code>提供各个文件的一些参数，但是具体的名字仍旧可以自己定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.webpackjs.com/concepts/output/" target="_blank" rel="noopener">publicPath</a>  (这个参数尚未用过)</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识漫游</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>前端大部分的知识流程梳理（2019）</p>
</blockquote>
<a id="more"></a>



<p><img src="/static/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%BC%AB%E6%B8%B8/images/image-20200405183952644.png" alt="image-20200405183952644"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>各种标签说明</title>
    <url>/2020/04/04/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p><strong>New</strong> : HTML5 中的新标签。</p>
<table>
<thead>
<tr>
<th><strong>标签</strong></th>
<th><strong>描述</strong></th>
<th>效果</th>
<th>浏览器支持情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!--...--&gt;</code></td>
<td>定义注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;!DOCTYPE&gt;</code></td>
<td>定义文档类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>定义锚点</td>
<td><a href="#">锚点</a></td>
<td></td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>定义缩写</td>
<td><abbr title="People's Republic of China">PRC</abbr></td>
<td></td>
</tr>
<tr>
<td><code>&lt;acronym&gt;</code></td>
<td>定义只取首字母的缩写</td>
<td><acronym title="World Wide Web">WWW</acronym></td>
<td></td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>定义文档作者或拥有者的联系信息。</td>
<td><address> Donald USA</address></td>
<td></td>
</tr>
<tr>
<td><code>&lt;area&gt;</code></td>
<td>定义图像映射内部的区域。</td>
<td><a href="https://www.w3school.com.cn/tags/tag_area.asp" target="_blank" rel="noopener">area说明</a></td>
<td></td>
</tr>
<tr>
<td><code>&lt;article&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义文章。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义页面内容之外的内容。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&lt;audio&gt;</code><img src="/static/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%90%84%E7%A7%8D%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/images/table_bg_html5.png" alt="img"></td>
<td>定义声音内容</td>
<td><audio></audio></td>
<td>基本都可以用</td>
</tr>
<tr>
<td><code>&lt;b&gt;</code></td>
<td>定义粗体字</td>
<td><b>粗体字</b></td>
<td>基本都可以用</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+typora 博客中插入图片</title>
    <url>/2020/04/04/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>在使用了hexo搭建了博客后，最大的问题便是如何使用一款markdown工具来编辑博客了，我采取的就是Typora，这工具免费简单易用没广告，而且把图片保存到本地还是很方便的，因此大家只要稍微了解点markdown语法就可以上手使用了。</p>
</blockquote>
<a id="more"></a>

<p>关于图片和图片路径的设置，有以下教程。</p>
<blockquote>
<p> 所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p>
</blockquote>
<ol>
<li><p><code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p>
</li>
<li><p>打开<code>Typora</code>的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p>
<p><img src="/static/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/images/image-20200411092155916.png" alt="image-20200411092155916"></p>
<p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p>
<p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p>
</li>
<li><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。<strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p>
<p>之后再该<code>md</code>文件头部会出现:<code>typora-root-url: ..\..\source</code>这样的代码，我们将这行代码复制进模板文件中</p>
</li>
<li><p>以下这三个都可以添加</p>
<p><img src="/static/hexo/hexo-typora-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/images/image-20200411092141854.png" alt="image-20200411092141854"></p>
<p>只要在第一个<code>---</code>下添加<code>typora-root-url: ..\..\source</code>就行了，这样<code>Typora</code>就能识别而不用每次都自己手动设置了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2020/04/03/hexo/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code>#生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务预览<br><code>hexo d</code> == <code>hexo deploy</code>#部署</p>
<a id="more"></a>

<h2 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上是文章摘要 &lt;!--more--&gt; 以下是余下全文</span><br></pre></td></tr></table></figure>

<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><code>hexo new page</code><br><code>hexo new post</code></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题</td>
</tr>
<tr>
<td>:year</td>
<td>建立的年份（4 位数）</td>
</tr>
<tr>
<td>:month</td>
<td>建立的月份（2 位数）</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立的月份（去掉开头的零）</td>
</tr>
<tr>
<td>:day</td>
<td>建立的日期（2 位数）</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立的日期（去掉开头的零）</td>
</tr>
</tbody></table>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p><code>hexo publish [layout] &lt;title&gt;</code></p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p><code>hexo new &quot;postName&quot;</code> #新建文章<br><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #将.deploy目录部署到GitHub</p>
<p><code>hexo new [layout]</code><br><code>hexo new photo &quot;My Gallery&quot;</code><br><code>hexo new &quot;Hello World&quot; --lang tw</code></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>文件建立日期</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">comments: true</span><br><span class="line">categories: Blog</span><br><span class="line">tags: [Hexo]</span><br><span class="line">keywords: Hexo, Blog</span><br><span class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</span><br></pre></td></tr></table></figure>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p>
<p><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令<br><code>hexo g</code> #生成静态网页<br><code>hexo d</code> #开始部署</p>
<h2 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h2><p><code>hexo generate</code> #使用 Hexo 生成静态文件快速而且简单<br><code>hexo generate --watch</code> #监视文件变动</p>
<h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><blockquote>
<p>两个命令的作用是相同的<br><code>hexo generate --deploy</code><br>hexo deploy –generate</p>
</blockquote>
<p><code>hexo deploy -g</code></p>
<p><code>hexo server -g</code></p>
<h2 id="新建Hexo项目"><a href="#新建Hexo项目" class="headerlink" title="新建Hexo项目"></a>新建Hexo项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure>



<!-- more -->

<p>飒飒</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>npm库个人常用整合</title>
    <url>/2020/04/01/npm/npm%E5%BA%93%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h3 id="数学计算库"><a href="#数学计算库" class="headerlink" title="数学计算库"></a>数学计算库</h3><ul>
<li><a href="https://www.npmjs.com/package/mathjs" target="_blank" rel="noopener">math.js</a></li>
</ul>
<h3 id="生成文件模板"><a href="#生成文件模板" class="headerlink" title="生成文件模板"></a>生成文件模板</h3><ul>
<li><a href="https://www.npmjs.com/package/plop" target="_blank" rel="noopener">plop</a> （用于快速生成模板文件，可提供变量定制化输出）</li>
</ul>
<h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ul>
<li><code>webpack</code> (大名鼎鼎的模块打包工具)</li>
</ul>
<h3 id="发布订阅库"><a href="#发布订阅库" class="headerlink" title="发布订阅库"></a>发布订阅库</h3><p><a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="noopener">PubSubJS</a>，<a href="https://www.npmjs.com/package/@types/pubsub-js" target="_blank" rel="noopener">@types/pubsub-js</a>，<a href="https://github.com/Gozala/events" target="_blank" rel="noopener">events</a></p>
<h2 id="Webpack常用库"><a href="#Webpack常用库" class="headerlink" title="Webpack常用库"></a>Webpack常用库</h2><ul>
<li><code>html-webpack-plugin</code> 打包<code>html</code>，提供脚本样式注入等功能</li>
</ul>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
  </entry>
  <entry>
    <title>lerna使用方法</title>
    <url>/2020/03/31/lerna/lerna%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><code>lerna</code>主要用于分模块管理<code>js</code>的依赖库，对于库项目开发者非常有友好，它可以将一个大的库项目分离成一个个独立的项目，但又不是完全独立的，而是全部由<code>lerna</code>进行管理。它的类似目录结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">my-lerna-repo/</span><br><span class="line">  package.json</span><br><span class="line">  packages/</span><br><span class="line">    package<span class="number">-1</span>/</span><br><span class="line">      package.json</span><br><span class="line">    package<span class="number">-2</span>/</span><br><span class="line">      package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装</span><br><span class="line">npm i -g lerna</span><br><span class="line">&#x2F;&#x2F; 局部安装</span><br><span class="line">npm i -D lerna</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 你的项目根目录</span><br><span class="line">&#x2F;&#x2F;全局安装的话执行下面这个</span><br><span class="line">lerna init</span><br><span class="line">&#x2F;&#x2F;局部安装的话执行下面这个</span><br><span class="line">npx lerna init</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>lerna</category>
      </categories>
  </entry>
</search>
